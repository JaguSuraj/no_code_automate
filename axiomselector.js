!function(g){var I={};function C(A){if(I[A])return I[A].exports;var t=I[A]={i:A,l:!1,exports:{}};return g[A].call(t.exports,t,t.exports,C),t.l=!0,t.exports}C.m=g,C.c=I,C.d=function(g,I,A){C.o(g,I)||Object.defineProperty(g,I,{enumerable:!0,get:A})},C.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},C.t=function(g,I){if(1&I&&(g=C(g)),8&I)return g;if(4&I&&"object"==typeof g&&g&&g.__esModule)return g;var A=Object.create(null);if(C.r(A),Object.defineProperty(A,"default",{enumerable:!0,value:g}),2&I&&"string"!=typeof g)for(var t in g)C.d(A,t,function(I){return g[I]}.bind(null,t));return A},C.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return C.d(I,"a",I),I},C.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},C.p="",C(C.s=808)}({13:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AxiomApiHelper\", function() { return AxiomApiHelper; });\n/* harmony import */ var _classes_models_RunningData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);\n/* harmony import */ var _classes_models_RunningData__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_classes_models_RunningData__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _axiombuilder_models_WidgetsNestable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(35);\n/* harmony import */ var _axiombuilder_models_WidgetsNestable__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_axiombuilder_models_WidgetsNestable__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n/**\n * Helper functions for running axioms\n *\n */\nclass AxiomApiHelper {\n\n    /**\n     * Transpose table data - swapping rows and columns\n     * @param {*} array a 2D array e.g. [[item1a, item1b], [item2a, item2b]]\n     * @example AxiomApiHelper.transpose([[item1a, item1b], [item2a, item2b]])\n     * @returns a 2D array e.g. [[item1a, item2a], [item1b, item2b]]\n     */\n    static transpose(array) {\n        let subArrayLength = 0\n        let newArray = []\n        for (let i = 0; i < array.length; i++) {\n            if (array[i].length > subArrayLength) {\n                subArrayLength = array[i].length\n            }\n        }\n        for (let i = 0; i < subArrayLength; i++) {\n            newArray.push([]);\n        }\n        for (let i = 0; i < array.length; i++) {\n            for(let j = 0; j < subArrayLength; j++) {\n                let jn = parseInt(j)\n                newArray[jn].push(array[i][jn])\n            }\n        }\n\n        return newArray;\n    }\n\n    /** \n    *\n    * Introduce a delay with a promise\n    * @param time - The time in milliseconds to delay\n    *\n    */\n\n    static delay(time, v) {\n        return new Promise(function(resolve) { \n            setTimeout(resolve.bind(null, v), time)\n        });\n     }\n\n    /**\n     * Convert a numerical index value into the column letter format\n     * used by spreadsheet applications i.e. 0 => 'A', 26 => 'AA', 30 => 'AE'\n     * @param {*} index the index of the column you want the corresponding column letter for e.g. 0\n     * @example AxiomApiHelper.getColLetter(30)\n     * @result a string representing the column in a spreadsheet that corresponds to the numerical index given e.g. 'AE'\n     */\n    static getColLetter(index) {\n        let ALPHA = ['!', 'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'];\n\n        let base = ALPHA.length-1\n        let n = index\n\n        let done = false\n        let res = []\n        let colLetters = ''\n\n        while (!done) {\n            let a = (n / base)\n            let remainder = (n % base)\n            if (res.length == 0) {\n                remainder += 1\n            }\n            res.push(remainder)\n            colLetters = ALPHA[remainder] + colLetters\n            n = Math.round(a - (remainder / base))\n            done = (n == 0)\n        }\n\n        return colLetters\n    }\n\n    /**\n     * Convert the column letter format value into a numerical index\n     * used by spreadsheet applications i.e. 'A' => 0, 'AA' => 26, 'AE' => 30\n     * @param {*} colLetters\n     * @example AxiomApiHelper.getColIndex('AE')\n     * @returns a numerical index e.g. 30\n     */\n    static getColIndex(colLetters) {\n        if (!colLetters) {\n            return -1\n        }\n        colLetters = colLetters.trim()\n        if (parseInt(colLetters, 10) >= 0) {\n            return colLetters\n        }\n        let s_numbers = [0];\n        for (let i = 0; i < colLetters.length; i++) {\n            let pow = Math.pow(26, colLetters.length - i - 1)\n            s_numbers[i] = (colLetters[i].charCodeAt(0) - 64) * pow\n        }\n        return s_numbers.reduce((accumulator, a) => {return accumulator + a}) - 1\n    }\n\n    /**\n     * Check whether a 2D array contains a 1D array\n     *\n     * usefull for checking whether row data exists in table data\n     *\n     * If columns are provided as a param then\n     * the arrays will only be compared by the contents of those columns\n     * and not the entire contents of each array\n     * @param {*} array1 a single dimensional array e.g. [\"A\", \"Example A\"]\n     * @param {*} array2 a two dimensional array e.g. [[\"A\", \"Example A\"], [\"B\", \"Example B\"]]\n     * @param {*} columns an array of column letters to compare by\n     * @example AxiomApiHelper.inArray([\"A\", \"Example A\"], [[\"A\", \"Example A\"], [\"B\", \"Example B\"]])\n     * @returns a boolean value e.g. true\n     */\n    static inArray(array1, array2, columns = null) {\n        let found = false\n\n        for (let array of array2) {\n            if (this.matchingArrays(array, array1, columns)) {\n                found = true\n            }\n        }\n        return found\n    }\n\n    static colString2indexArray(cols) {\n        let indeces = []\n        for (let col of cols.split(',')) {\n            col = col.trim()\n            if (Number.isInteger(col)) {\n                col = col -1\n            } else {\n                if (/[A-Za-z]/.test(col)) {\n                    if (/[a-z]/.test(col)) {\n                        col = col.toUpperCase()\n                    }\n                    col = this.getColIndex(col)\n                } else {\n                    col = Number(col) - 1\n                }\n            }\n            if (col > -1){\n                indeces.push(col)\n            }\n        }\n\n        return indeces\n    }\n\n    /**\n     * Checks whether two single dimensional arrays match - for comparing whether two rows of data match\n     *\n     * If columns are provided as a param then\n     * the arrays will only be compared by the contents of those columns\n     * and not the entire contents of each array\n     * @param {*} array1 the first array to compare\n     * @param {*} array2 the second array to compare against\n     * @param {*} columns an array of columns letters to compare within each array e.g. ['A','D']\n     * @example AxiomApiHelper.matchingArrays([0,0,0,0], [0,2,1,0], ['A','D'])\n     * @return a boolean value e.g. true\n     */\n    static matchingArrays(array1, array2, columns = null) {\n        let singleDimension = true\n        if (array1.length != array2.length) {\n            return false\n        }\n        if (Array.isArray(array1) != Array.isArray(array2)) {\n            return false\n        } else {\n            if (Array.isArray(array1)) {\n                singleDimension = false\n            }\n        }\n        let matching = true\n\n        if (Array.isArray(columns) && columns.length > 0) {\n        } else {\n            columns = []\n            let tableWidth = (array1.length > array2.length) ? array1.length : array2.length\n            for (let i = 0; i < tableWidth; i ++) {\n                columns.push(this.getColLetter(i+1))\n            }\n        }\n\n        for (let colLetters of columns) {\n            let i = this.getColIndex(colLetters)\n\n            if (array1[i] != array2[i]) {\n                matching = false\n            }\n        }\n\n        return matching\n    }\n\n    static clone(array) {\n        if (!array) {\n            return [[\"\"]]\n        }\n        let cloned = []\n        if (Array.isArray(array[0])) {\n            for (let item of array) {\n                cloned[array.indexOf(item)] = this.clone(item)\n            }\n        } else {\n            for (let key of Object.keys(array)) {\n                cloned[key] = array[key].valueOf()\n            }\n        }\n        return cloned\n    }\n\n    static getRoute(url) {\n        let domain = url\n        if (/\\/\\//.test(url)) {\n            var split = url.split('//')\n            var protocol = split[0]\n            domain = split[split.length -1]\n            var domainSegs = domain.split('.')\n            if (domainSegs.length > 2) {\n                var net = domainSegs.shift()\n            }\n            let route = domainSegs.pop()\n            route = route.split('/')\n            route.pop()\n            domain = domainSegs.join('.') + '.' + route.join('/')\n        }\n        return domain\n    }\n\n    /**\n     * Send a message to the tab window.\n     */\n    static sendTabMessage(action, params) {\n        return new Promise((resolve, reject) => {\n            let rd = new _classes_models_RunningData__WEBPACK_IMPORTED_MODULE_0___default.a()\n            rd.load().then(() => {\n                params.action = action\n                chrome.tabs.sendMessage(rd.states[0].tab_id, params, response => {\n                    if (chrome.runtime.hasOwnProperty(\"lastError\")) {\n                        switch (action) {\n                            case \"display_message\":\n                                resolve('')\n                                break\n                            default:\n                                resolve({error: {message: chrome.runtime.lastError.message}})\n                                break\n                        }\n                    } else {\n                        resolve(response)\n                    }\n                })\n            })\n        })\n    }\n\n    static isValidJson(str) {\n        try {\n            const obj = JSON.parse(str)\n\n            if (obj && typeof obj === 'object') {\n                return true\n            }\n        } catch (e) {\n        }\n\n        return false\n    }\n\n    static buildSelectorArray(selector, resultType) {\n        let selectors = []\n        let resultTypes = []\n        if (!Array.isArray(selector)) {\n            if (typeof selector === 'string') {\n                selectors = selector.split(',')// TODO - replace with split\n                let trimmed = []\n                for (let s of selectors) {\n                    trimmed.push(s.trim())\n                    if (typeof resultType === 'string') {\n                        resultTypes.push(resultType)\n                    } else {\n                        resultTypes.push('textContent')\n                    }\n                }\n                selectors = trimmed\n            }\n        } else {\n            if (selector[0].resultType !== undefined) {\n                resultTypes = selector.map(s => {\n                    return s.resultType\n                })\n                selectors = selector.map(s => {\n                    return s.selector\n                })\n            }\n        }\n        return {selectors, resultTypes}\n    }\n\n    static applyToIframes(callback) {\n        jQuery('iframe').each((index, el) => {\n            const content = jQuery(el).contents()\n            if (content && content.length) {\n                callback(index, content)\n            }\n        })\n    }\n\n    /**\n     * Extracts form data from an axiom / task object\n     * @param {} task \n     */\n    static extractFormData(task, keepDisabled = false) {\n        let formData = []\n        while (typeof task.data === 'string') {\n            task.data = JSON.parse(task.data)\n        }\n        // remove all disabled widgets from task before run.\n        // used `for in` to take the index\n        for (let wid in task.data.form) {\n            if(keepDisabled || !(task.data.form[wid].is_disable !== undefined && task.data.form[wid].is_disable === true)) {\n                formData.push(task.data.form[wid])\n            }\n        }\n        return formData\n    }\n\n    /**\n     * Loads the campaign cookie from the Axiom website, if one is set\n     */\n    static async getCampaign() {\n        return new Promise(resolve => {\n            chrome.cookies.getAll({name: \"axiom_ga_query_params\"}, res => {\n                if (res.length > 0) {\n                    const desiredCookie = res.filter(item => item.path === '/')[0]\n                    if (desiredCookie) {\n                        resolve(desiredCookie.value)\n                    } else {\n                        resolve(res[0].value)\n                    }\n                } else {\n                    resolve('')\n                }\n            })\n        })\n    }\n\n    static getStepNumbering(widgets, nestingData) {\n        if (!nestingData) {\n            const wn = new _axiombuilder_models_WidgetsNestable__WEBPACK_IMPORTED_MODULE_1__[\"WidgetsNestable\"]()\n            nestingData = wn.buildNestingData(widgets)\n        }\n        let parts = [0, 0, 0, 0, 0]\n        for (let windex in nestingData) {\n            if (!nestingData[windex].endingBlock) {\n                parts[nestingData[windex].indent]++\n            } else if (nestingData[windex-1] && nestingData[windex-1].indent > nestingData[windex].indent) {\n                parts[nestingData[windex-1].indent] = 0\n            }\n            widgets[windex].stepNumber = parts.slice(0, nestingData[windex].indent + 1).join('.')\n        }\n    }\n\n    static getTrimmedUrl(url) {\n        try {\n            let trimmed = url.trim().toLowerCase()\n            let urlObject = new URL(trimmed)\n\n            urlObject.hash = ''\n            urlObject.search = ''\n            urlObject.pathname = ''\n\n            return urlObject.toString()\n        } catch(e) {\n            return url\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGliL2F4aW9tYXBpL0F4aW9tQXBpSGVscGVyLmpzP2QwNTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJ1bm5pbmdEYXRhIGZyb20gXCIuLi8uLi9jbGFzc2VzL21vZGVscy9SdW5uaW5nRGF0YVwiXG5pbXBvcnQge1dpZGdldHNOZXN0YWJsZX0gZnJvbSBcIi4uLy4uL2F4aW9tYnVpbGRlci9tb2RlbHMvV2lkZ2V0c05lc3RhYmxlXCJcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBydW5uaW5nIGF4aW9tc1xuICpcbiAqL1xuZXhwb3J0IGNsYXNzIEF4aW9tQXBpSGVscGVyIHtcblxuICAgIC8qKlxuICAgICAqIFRyYW5zcG9zZSB0YWJsZSBkYXRhIC0gc3dhcHBpbmcgcm93cyBhbmQgY29sdW1uc1xuICAgICAqIEBwYXJhbSB7Kn0gYXJyYXkgYSAyRCBhcnJheSBlLmcuIFtbaXRlbTFhLCBpdGVtMWJdLCBbaXRlbTJhLCBpdGVtMmJdXVxuICAgICAqIEBleGFtcGxlIEF4aW9tQXBpSGVscGVyLnRyYW5zcG9zZShbW2l0ZW0xYSwgaXRlbTFiXSwgW2l0ZW0yYSwgaXRlbTJiXV0pXG4gICAgICogQHJldHVybnMgYSAyRCBhcnJheSBlLmcuIFtbaXRlbTFhLCBpdGVtMmFdLCBbaXRlbTFiLCBpdGVtMmJdXVxuICAgICAqL1xuICAgIHN0YXRpYyB0cmFuc3Bvc2UoYXJyYXkpIHtcbiAgICAgICAgbGV0IHN1YkFycmF5TGVuZ3RoID0gMFxuICAgICAgICBsZXQgbmV3QXJyYXkgPSBbXVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXJyYXlbaV0ubGVuZ3RoID4gc3ViQXJyYXlMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzdWJBcnJheUxlbmd0aCA9IGFycmF5W2ldLmxlbmd0aFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3ViQXJyYXlMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbmV3QXJyYXkucHVzaChbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IHN1YkFycmF5TGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgam4gPSBwYXJzZUludChqKVxuICAgICAgICAgICAgICAgIG5ld0FycmF5W2puXS5wdXNoKGFycmF5W2ldW2puXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdBcnJheTtcbiAgICB9XG5cbiAgICAvKiogXG4gICAgKlxuICAgICogSW50cm9kdWNlIGEgZGVsYXkgd2l0aCBhIHByb21pc2VcbiAgICAqIEBwYXJhbSB0aW1lIC0gVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIGRlbGF5XG4gICAgKlxuICAgICovXG5cbiAgICBzdGF0aWMgZGVsYXkodGltZSwgdikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkgeyBcbiAgICAgICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZS5iaW5kKG51bGwsIHYpLCB0aW1lKVxuICAgICAgICB9KTtcbiAgICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIG51bWVyaWNhbCBpbmRleCB2YWx1ZSBpbnRvIHRoZSBjb2x1bW4gbGV0dGVyIGZvcm1hdFxuICAgICAqIHVzZWQgYnkgc3ByZWFkc2hlZXQgYXBwbGljYXRpb25zIGkuZS4gMCA9PiAnQScsIDI2ID0+ICdBQScsIDMwID0+ICdBRSdcbiAgICAgKiBAcGFyYW0geyp9IGluZGV4IHRoZSBpbmRleCBvZiB0aGUgY29sdW1uIHlvdSB3YW50IHRoZSBjb3JyZXNwb25kaW5nIGNvbHVtbiBsZXR0ZXIgZm9yIGUuZy4gMFxuICAgICAqIEBleGFtcGxlIEF4aW9tQXBpSGVscGVyLmdldENvbExldHRlcigzMClcbiAgICAgKiBAcmVzdWx0IGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY29sdW1uIGluIGEgc3ByZWFkc2hlZXQgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgbnVtZXJpY2FsIGluZGV4IGdpdmVuIGUuZy4gJ0FFJ1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDb2xMZXR0ZXIoaW5kZXgpIHtcbiAgICAgICAgbGV0IEFMUEhBID0gWychJywgJ0EnLCdCJywnQycsJ0QnLCdFJywnRicsJ0cnLCdIJywnSScsJ0onLCdLJywnTCcsJ00nLCdOJywnTycsJ1AnLCdRJywnUicsJ1MnLCdUJywnVScsJ1YnLCdXJywnWCcsJ1knLCdaJ107XG5cbiAgICAgICAgbGV0IGJhc2UgPSBBTFBIQS5sZW5ndGgtMVxuICAgICAgICBsZXQgbiA9IGluZGV4XG5cbiAgICAgICAgbGV0IGRvbmUgPSBmYWxzZVxuICAgICAgICBsZXQgcmVzID0gW11cbiAgICAgICAgbGV0IGNvbExldHRlcnMgPSAnJ1xuXG4gICAgICAgIHdoaWxlICghZG9uZSkge1xuICAgICAgICAgICAgbGV0IGEgPSAobiAvIGJhc2UpXG4gICAgICAgICAgICBsZXQgcmVtYWluZGVyID0gKG4gJSBiYXNlKVxuICAgICAgICAgICAgaWYgKHJlcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIHJlbWFpbmRlciArPSAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMucHVzaChyZW1haW5kZXIpXG4gICAgICAgICAgICBjb2xMZXR0ZXJzID0gQUxQSEFbcmVtYWluZGVyXSArIGNvbExldHRlcnNcbiAgICAgICAgICAgIG4gPSBNYXRoLnJvdW5kKGEgLSAocmVtYWluZGVyIC8gYmFzZSkpXG4gICAgICAgICAgICBkb25lID0gKG4gPT0gMClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb2xMZXR0ZXJzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgY29sdW1uIGxldHRlciBmb3JtYXQgdmFsdWUgaW50byBhIG51bWVyaWNhbCBpbmRleFxuICAgICAqIHVzZWQgYnkgc3ByZWFkc2hlZXQgYXBwbGljYXRpb25zIGkuZS4gJ0EnID0+IDAsICdBQScgPT4gMjYsICdBRScgPT4gMzBcbiAgICAgKiBAcGFyYW0geyp9IGNvbExldHRlcnNcbiAgICAgKiBAZXhhbXBsZSBBeGlvbUFwaUhlbHBlci5nZXRDb2xJbmRleCgnQUUnKVxuICAgICAqIEByZXR1cm5zIGEgbnVtZXJpY2FsIGluZGV4IGUuZy4gMzBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q29sSW5kZXgoY29sTGV0dGVycykge1xuICAgICAgICBpZiAoIWNvbExldHRlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICB9XG4gICAgICAgIGNvbExldHRlcnMgPSBjb2xMZXR0ZXJzLnRyaW0oKVxuICAgICAgICBpZiAocGFyc2VJbnQoY29sTGV0dGVycywgMTApID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xMZXR0ZXJzXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNfbnVtYmVycyA9IFswXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xMZXR0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcG93ID0gTWF0aC5wb3coMjYsIGNvbExldHRlcnMubGVuZ3RoIC0gaSAtIDEpXG4gICAgICAgICAgICBzX251bWJlcnNbaV0gPSAoY29sTGV0dGVyc1tpXS5jaGFyQ29kZUF0KDApIC0gNjQpICogcG93XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNfbnVtYmVycy5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBhKSA9PiB7cmV0dXJuIGFjY3VtdWxhdG9yICsgYX0pIC0gMVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgYSAyRCBhcnJheSBjb250YWlucyBhIDFEIGFycmF5XG4gICAgICpcbiAgICAgKiB1c2VmdWxsIGZvciBjaGVja2luZyB3aGV0aGVyIHJvdyBkYXRhIGV4aXN0cyBpbiB0YWJsZSBkYXRhXG4gICAgICpcbiAgICAgKiBJZiBjb2x1bW5zIGFyZSBwcm92aWRlZCBhcyBhIHBhcmFtIHRoZW5cbiAgICAgKiB0aGUgYXJyYXlzIHdpbGwgb25seSBiZSBjb21wYXJlZCBieSB0aGUgY29udGVudHMgb2YgdGhvc2UgY29sdW1uc1xuICAgICAqIGFuZCBub3QgdGhlIGVudGlyZSBjb250ZW50cyBvZiBlYWNoIGFycmF5XG4gICAgICogQHBhcmFtIHsqfSBhcnJheTEgYSBzaW5nbGUgZGltZW5zaW9uYWwgYXJyYXkgZS5nLiBbXCJBXCIsIFwiRXhhbXBsZSBBXCJdXG4gICAgICogQHBhcmFtIHsqfSBhcnJheTIgYSB0d28gZGltZW5zaW9uYWwgYXJyYXkgZS5nLiBbW1wiQVwiLCBcIkV4YW1wbGUgQVwiXSwgW1wiQlwiLCBcIkV4YW1wbGUgQlwiXV1cbiAgICAgKiBAcGFyYW0geyp9IGNvbHVtbnMgYW4gYXJyYXkgb2YgY29sdW1uIGxldHRlcnMgdG8gY29tcGFyZSBieVxuICAgICAqIEBleGFtcGxlIEF4aW9tQXBpSGVscGVyLmluQXJyYXkoW1wiQVwiLCBcIkV4YW1wbGUgQVwiXSwgW1tcIkFcIiwgXCJFeGFtcGxlIEFcIl0sIFtcIkJcIiwgXCJFeGFtcGxlIEJcIl1dKVxuICAgICAqIEByZXR1cm5zIGEgYm9vbGVhbiB2YWx1ZSBlLmcuIHRydWVcbiAgICAgKi9cbiAgICBzdGF0aWMgaW5BcnJheShhcnJheTEsIGFycmF5MiwgY29sdW1ucyA9IG51bGwpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2VcblxuICAgICAgICBmb3IgKGxldCBhcnJheSBvZiBhcnJheTIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoaW5nQXJyYXlzKGFycmF5LCBhcnJheTEsIGNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kXG4gICAgfVxuXG4gICAgc3RhdGljIGNvbFN0cmluZzJpbmRleEFycmF5KGNvbHMpIHtcbiAgICAgICAgbGV0IGluZGVjZXMgPSBbXVxuICAgICAgICBmb3IgKGxldCBjb2wgb2YgY29scy5zcGxpdCgnLCcpKSB7XG4gICAgICAgICAgICBjb2wgPSBjb2wudHJpbSgpXG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihjb2wpKSB7XG4gICAgICAgICAgICAgICAgY29sID0gY29sIC0xXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgvW0EtWmEtel0vLnRlc3QoY29sKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoL1thLXpdLy50ZXN0KGNvbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbCA9IGNvbC50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29sID0gdGhpcy5nZXRDb2xJbmRleChjb2wpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29sID0gTnVtYmVyKGNvbCkgLSAxXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbCA+IC0xKXtcbiAgICAgICAgICAgICAgICBpbmRlY2VzLnB1c2goY29sKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZGVjZXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0d28gc2luZ2xlIGRpbWVuc2lvbmFsIGFycmF5cyBtYXRjaCAtIGZvciBjb21wYXJpbmcgd2hldGhlciB0d28gcm93cyBvZiBkYXRhIG1hdGNoXG4gICAgICpcbiAgICAgKiBJZiBjb2x1bW5zIGFyZSBwcm92aWRlZCBhcyBhIHBhcmFtIHRoZW5cbiAgICAgKiB0aGUgYXJyYXlzIHdpbGwgb25seSBiZSBjb21wYXJlZCBieSB0aGUgY29udGVudHMgb2YgdGhvc2UgY29sdW1uc1xuICAgICAqIGFuZCBub3QgdGhlIGVudGlyZSBjb250ZW50cyBvZiBlYWNoIGFycmF5XG4gICAgICogQHBhcmFtIHsqfSBhcnJheTEgdGhlIGZpcnN0IGFycmF5IHRvIGNvbXBhcmVcbiAgICAgKiBAcGFyYW0geyp9IGFycmF5MiB0aGUgc2Vjb25kIGFycmF5IHRvIGNvbXBhcmUgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7Kn0gY29sdW1ucyBhbiBhcnJheSBvZiBjb2x1bW5zIGxldHRlcnMgdG8gY29tcGFyZSB3aXRoaW4gZWFjaCBhcnJheSBlLmcuIFsnQScsJ0QnXVxuICAgICAqIEBleGFtcGxlIEF4aW9tQXBpSGVscGVyLm1hdGNoaW5nQXJyYXlzKFswLDAsMCwwXSwgWzAsMiwxLDBdLCBbJ0EnLCdEJ10pXG4gICAgICogQHJldHVybiBhIGJvb2xlYW4gdmFsdWUgZS5nLiB0cnVlXG4gICAgICovXG4gICAgc3RhdGljIG1hdGNoaW5nQXJyYXlzKGFycmF5MSwgYXJyYXkyLCBjb2x1bW5zID0gbnVsbCkge1xuICAgICAgICBsZXQgc2luZ2xlRGltZW5zaW9uID0gdHJ1ZVxuICAgICAgICBpZiAoYXJyYXkxLmxlbmd0aCAhPSBhcnJheTIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJheTEpICE9IEFycmF5LmlzQXJyYXkoYXJyYXkyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJheTEpKSB7XG4gICAgICAgICAgICAgICAgc2luZ2xlRGltZW5zaW9uID0gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWF0Y2hpbmcgPSB0cnVlXG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29sdW1ucykgJiYgY29sdW1ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2x1bW5zID0gW11cbiAgICAgICAgICAgIGxldCB0YWJsZVdpZHRoID0gKGFycmF5MS5sZW5ndGggPiBhcnJheTIubGVuZ3RoKSA/IGFycmF5MS5sZW5ndGggOiBhcnJheTIubGVuZ3RoXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYmxlV2lkdGg7IGkgKyspIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5zLnB1c2godGhpcy5nZXRDb2xMZXR0ZXIoaSsxKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGNvbExldHRlcnMgb2YgY29sdW1ucykge1xuICAgICAgICAgICAgbGV0IGkgPSB0aGlzLmdldENvbEluZGV4KGNvbExldHRlcnMpXG5cbiAgICAgICAgICAgIGlmIChhcnJheTFbaV0gIT0gYXJyYXkyW2ldKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hpbmcgPSBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hdGNoaW5nXG4gICAgfVxuXG4gICAgc3RhdGljIGNsb25lKGFycmF5KSB7XG4gICAgICAgIGlmICghYXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBbW1wiXCJdXVxuICAgICAgICB9XG4gICAgICAgIGxldCBjbG9uZWQgPSBbXVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJheVswXSkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGl0ZW0gb2YgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBjbG9uZWRbYXJyYXkuaW5kZXhPZihpdGVtKV0gPSB0aGlzLmNsb25lKGl0ZW0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmtleXMoYXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgY2xvbmVkW2tleV0gPSBhcnJheVtrZXldLnZhbHVlT2YoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9uZWRcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0Um91dGUodXJsKSB7XG4gICAgICAgIGxldCBkb21haW4gPSB1cmxcbiAgICAgICAgaWYgKC9cXC9cXC8vLnRlc3QodXJsKSkge1xuICAgICAgICAgICAgdmFyIHNwbGl0ID0gdXJsLnNwbGl0KCcvLycpXG4gICAgICAgICAgICB2YXIgcHJvdG9jb2wgPSBzcGxpdFswXVxuICAgICAgICAgICAgZG9tYWluID0gc3BsaXRbc3BsaXQubGVuZ3RoIC0xXVxuICAgICAgICAgICAgdmFyIGRvbWFpblNlZ3MgPSBkb21haW4uc3BsaXQoJy4nKVxuICAgICAgICAgICAgaWYgKGRvbWFpblNlZ3MubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIHZhciBuZXQgPSBkb21haW5TZWdzLnNoaWZ0KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByb3V0ZSA9IGRvbWFpblNlZ3MucG9wKClcbiAgICAgICAgICAgIHJvdXRlID0gcm91dGUuc3BsaXQoJy8nKVxuICAgICAgICAgICAgcm91dGUucG9wKClcbiAgICAgICAgICAgIGRvbWFpbiA9IGRvbWFpblNlZ3Muam9pbignLicpICsgJy4nICsgcm91dGUuam9pbignLycpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvbWFpblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSB0YWIgd2luZG93LlxuICAgICAqL1xuICAgIHN0YXRpYyBzZW5kVGFiTWVzc2FnZShhY3Rpb24sIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IHJkID0gbmV3IFJ1bm5pbmdEYXRhKClcbiAgICAgICAgICAgIHJkLmxvYWQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYWN0aW9uID0gYWN0aW9uXG4gICAgICAgICAgICAgICAgY2hyb21lLnRhYnMuc2VuZE1lc3NhZ2UocmQuc3RhdGVzWzBdLnRhYl9pZCwgcGFyYW1zLCByZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHJvbWUucnVudGltZS5oYXNPd25Qcm9wZXJ0eShcImxhc3RFcnJvclwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGlzcGxheV9tZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7ZXJyb3I6IHttZXNzYWdlOiBjaHJvbWUucnVudGltZS5sYXN0RXJyb3IubWVzc2FnZX19KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHN0YXRpYyBpc1ZhbGlkSnNvbihzdHIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IEpTT04ucGFyc2Uoc3RyKVxuXG4gICAgICAgICAgICBpZiAob2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgc3RhdGljIGJ1aWxkU2VsZWN0b3JBcnJheShzZWxlY3RvciwgcmVzdWx0VHlwZSkge1xuICAgICAgICBsZXQgc2VsZWN0b3JzID0gW11cbiAgICAgICAgbGV0IHJlc3VsdFR5cGVzID0gW11cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnMgPSBzZWxlY3Rvci5zcGxpdCgnLCcpLy8gVE9ETyAtIHJlcGxhY2Ugd2l0aCBzcGxpdFxuICAgICAgICAgICAgICAgIGxldCB0cmltbWVkID0gW11cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzIG9mIHNlbGVjdG9ycykge1xuICAgICAgICAgICAgICAgICAgICB0cmltbWVkLnB1c2gocy50cmltKCkpXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0VHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFR5cGVzLnB1c2gocmVzdWx0VHlwZSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFR5cGVzLnB1c2goJ3RleHRDb250ZW50JylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxlY3RvcnMgPSB0cmltbWVkXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0b3JbMF0ucmVzdWx0VHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0VHlwZXMgPSBzZWxlY3Rvci5tYXAocyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzLnJlc3VsdFR5cGVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIHNlbGVjdG9ycyA9IHNlbGVjdG9yLm1hcChzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMuc2VsZWN0b3JcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7c2VsZWN0b3JzLCByZXN1bHRUeXBlc31cbiAgICB9XG5cbiAgICBzdGF0aWMgYXBwbHlUb0lmcmFtZXMoY2FsbGJhY2spIHtcbiAgICAgICAgalF1ZXJ5KCdpZnJhbWUnKS5lYWNoKChpbmRleCwgZWwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBqUXVlcnkoZWwpLmNvbnRlbnRzKClcbiAgICAgICAgICAgIGlmIChjb250ZW50ICYmIGNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soaW5kZXgsIGNvbnRlbnQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgZm9ybSBkYXRhIGZyb20gYW4gYXhpb20gLyB0YXNrIG9iamVjdFxuICAgICAqIEBwYXJhbSB7fSB0YXNrIFxuICAgICAqL1xuICAgIHN0YXRpYyBleHRyYWN0Rm9ybURhdGEodGFzaywga2VlcERpc2FibGVkID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGZvcm1EYXRhID0gW11cbiAgICAgICAgd2hpbGUgKHR5cGVvZiB0YXNrLmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0YXNrLmRhdGEgPSBKU09OLnBhcnNlKHRhc2suZGF0YSlcbiAgICAgICAgfVxuICAgICAgICAvLyByZW1vdmUgYWxsIGRpc2FibGVkIHdpZGdldHMgZnJvbSB0YXNrIGJlZm9yZSBydW4uXG4gICAgICAgIC8vIHVzZWQgYGZvciBpbmAgdG8gdGFrZSB0aGUgaW5kZXhcbiAgICAgICAgZm9yIChsZXQgd2lkIGluIHRhc2suZGF0YS5mb3JtKSB7XG4gICAgICAgICAgICBpZihrZWVwRGlzYWJsZWQgfHwgISh0YXNrLmRhdGEuZm9ybVt3aWRdLmlzX2Rpc2FibGUgIT09IHVuZGVmaW5lZCAmJiB0YXNrLmRhdGEuZm9ybVt3aWRdLmlzX2Rpc2FibGUgPT09IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgZm9ybURhdGEucHVzaCh0YXNrLmRhdGEuZm9ybVt3aWRdKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtRGF0YVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIHRoZSBjYW1wYWlnbiBjb29raWUgZnJvbSB0aGUgQXhpb20gd2Vic2l0ZSwgaWYgb25lIGlzIHNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBnZXRDYW1wYWlnbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgY2hyb21lLmNvb2tpZXMuZ2V0QWxsKHtuYW1lOiBcImF4aW9tX2dhX3F1ZXJ5X3BhcmFtc1wifSwgcmVzID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzaXJlZENvb2tpZSA9IHJlcy5maWx0ZXIoaXRlbSA9PiBpdGVtLnBhdGggPT09ICcvJylbMF1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2lyZWRDb29raWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGVzaXJlZENvb2tpZS52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzWzBdLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgnJylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHN0YXRpYyBnZXRTdGVwTnVtYmVyaW5nKHdpZGdldHMsIG5lc3RpbmdEYXRhKSB7XG4gICAgICAgIGlmICghbmVzdGluZ0RhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHduID0gbmV3IFdpZGdldHNOZXN0YWJsZSgpXG4gICAgICAgICAgICBuZXN0aW5nRGF0YSA9IHduLmJ1aWxkTmVzdGluZ0RhdGEod2lkZ2V0cylcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFydHMgPSBbMCwgMCwgMCwgMCwgMF1cbiAgICAgICAgZm9yIChsZXQgd2luZGV4IGluIG5lc3RpbmdEYXRhKSB7XG4gICAgICAgICAgICBpZiAoIW5lc3RpbmdEYXRhW3dpbmRleF0uZW5kaW5nQmxvY2spIHtcbiAgICAgICAgICAgICAgICBwYXJ0c1tuZXN0aW5nRGF0YVt3aW5kZXhdLmluZGVudF0rK1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuZXN0aW5nRGF0YVt3aW5kZXgtMV0gJiYgbmVzdGluZ0RhdGFbd2luZGV4LTFdLmluZGVudCA+IG5lc3RpbmdEYXRhW3dpbmRleF0uaW5kZW50KSB7XG4gICAgICAgICAgICAgICAgcGFydHNbbmVzdGluZ0RhdGFbd2luZGV4LTFdLmluZGVudF0gPSAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aWRnZXRzW3dpbmRleF0uc3RlcE51bWJlciA9IHBhcnRzLnNsaWNlKDAsIG5lc3RpbmdEYXRhW3dpbmRleF0uaW5kZW50ICsgMSkuam9pbignLicpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0VHJpbW1lZFVybCh1cmwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCB0cmltbWVkID0gdXJsLnRyaW0oKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICBsZXQgdXJsT2JqZWN0ID0gbmV3IFVSTCh0cmltbWVkKVxuXG4gICAgICAgICAgICB1cmxPYmplY3QuaGFzaCA9ICcnXG4gICAgICAgICAgICB1cmxPYmplY3Quc2VhcmNoID0gJydcbiAgICAgICAgICAgIHVybE9iamVjdC5wYXRobmFtZSA9ICcnXG5cbiAgICAgICAgICAgIHJldHVybiB1cmxPYmplY3QudG9TdHJpbmcoKVxuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB1cmxcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///13\n")},17:function(module,exports,__webpack_require__){"use strict";eval('\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError("Generator is already executing.");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nvar CacheHandler = /** @class */ (function () {\n    function CacheHandler() {\n        this.data = {};\n        chrome.storage.local.set({ axiom_cache: [] });\n    }\n    CacheHandler.prototype.refresh = function (key, data) {\n        return __awaiter(this, void 0, void 0, function () {\n            var k;\n            var _this = this;\n            return __generator(this, function (_a) {\n                this.data[key] = {\n                    expired: false,\n                    data: {}\n                };\n                for (k in data) {\n                    if (typeof data[k] !== \'function\') {\n                        this.data[key].data[k] = data[k];\n                    }\n                }\n                return [2 /*return*/, new Promise(function (resolve) {\n                        chrome.storage.local.set({ axiom_cache: _this.data }, function () {\n                            resolve();\n                        });\n                    })];\n            });\n        });\n    };\n    CacheHandler.prototype.retrieve = function (key, model) {\n        return __awaiter(this, void 0, Promise, function () {\n            var obj, k;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!!this.data[key]) return [3 /*break*/, 2];\n                        return [4 /*yield*/, new Promise(function (resolve) {\n                                chrome.storage.local.get(\'axiom_cache\', function (res) {\n                                    _this.data = res.axiom_cache;\n                                    resolve();\n                                });\n                            })];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2:\n                        try {\n                            obj = this.data[key];\n                            for (k in model) {\n                                if (typeof model[k] !== \'function\') {\n                                    model[k] = obj.data[k];\n                                }\n                            }\n                            return [2 /*return*/, true];\n                        }\n                        catch (e) {\n                            console.error(\'Error retrieving from cache for \' + key, e);\n                            return [2 /*return*/, false];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    CacheHandler.prototype.isExpired = function (key) {\n        if (this.data[key]) {\n            return this.data[key].expired;\n        }\n        return true;\n    };\n    CacheHandler.prototype.expire = function (key) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n                return [2 /*return*/, new Promise(function (resolve) {\n                        chrome.storage.local.get(\'axiom_cache\', function (res) {\n                            _this.data = res.axiom_cache;\n                            if (!_this.data[key]) {\n                                _this.data[key] = {\n                                    expired: true\n                                };\n                            }\n                            else {\n                                if (_this.data[key].expired) {\n                                    resolve(true);\n                                }\n                                _this.data[key].expired = true;\n                            }\n                            chrome.storage.local.set({ axiom_cache: _this.data }, function () {\n                                resolve(true);\n                            });\n                        });\n                    })];\n            });\n        });\n    };\n    CacheHandler.prototype.clearAll = function () {\n        this.data = {};\n        chrome.storage.local.set({ axiom_cache: this.data });\n    };\n    return CacheHandler;\n}());\nvar CacheHandlerService = new CacheHandler();\nexports.default = CacheHandlerService;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY2xhc3Nlcy9zZXJ2aWNlcy9DYWNoZUhhbmRsZXIudHM/ZDJmZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ2FjaGVIYW5kbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhY2hlSGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5kYXRhID0ge307XG4gICAgICAgIGNocm9tZS5zdG9yYWdlLmxvY2FsLnNldCh7IGF4aW9tX2NhY2hlOiBbXSB9KTtcbiAgICB9XG4gICAgQ2FjaGVIYW5kbGVyLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKGtleSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaztcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGlyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7fVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZm9yIChrIGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2tdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFba2V5XS5kYXRhW2tdID0gZGF0YVtrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tZS5zdG9yYWdlLmxvY2FsLnNldCh7IGF4aW9tX2NhY2hlOiBfdGhpcy5kYXRhIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2FjaGVIYW5kbGVyLnByb3RvdHlwZS5yZXRyaWV2ZSA9IGZ1bmN0aW9uIChrZXksIG1vZGVsKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCBQcm9taXNlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2JqLCBrO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIXRoaXMuZGF0YVtrZXldKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tZS5zdG9yYWdlLmxvY2FsLmdldCgnYXhpb21fY2FjaGUnLCBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kYXRhID0gcmVzLmF4aW9tX2NhY2hlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmogPSB0aGlzLmRhdGFba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgaW4gbW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtb2RlbFtrXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxba10gPSBvYmouZGF0YVtrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdHJ1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJldHJpZXZpbmcgZnJvbSBjYWNoZSBmb3IgJyArIGtleSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZhbHNlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDYWNoZUhhbmRsZXIucHJvdG90eXBlLmlzRXhwaXJlZCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVtrZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhW2tleV0uZXhwaXJlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIENhY2hlSGFuZGxlci5wcm90b3R5cGUuZXhwaXJlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hyb21lLnN0b3JhZ2UubG9jYWwuZ2V0KCdheGlvbV9jYWNoZScsIGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kYXRhID0gcmVzLmF4aW9tX2NhY2hlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuZGF0YVtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmRhdGFba2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGlyZWQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5kYXRhW2tleV0uZXhwaXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kYXRhW2tleV0uZXhwaXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tZS5zdG9yYWdlLmxvY2FsLnNldCh7IGF4aW9tX2NhY2hlOiBfdGhpcy5kYXRhIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDYWNoZUhhbmRsZXIucHJvdG90eXBlLmNsZWFyQWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSB7fTtcbiAgICAgICAgY2hyb21lLnN0b3JhZ2UubG9jYWwuc2V0KHsgYXhpb21fY2FjaGU6IHRoaXMuZGF0YSB9KTtcbiAgICB9O1xuICAgIHJldHVybiBDYWNoZUhhbmRsZXI7XG59KCkpO1xudmFyIENhY2hlSGFuZGxlclNlcnZpY2UgPSBuZXcgQ2FjaGVIYW5kbGVyKCk7XG5leHBvcnRzLmRlZmF1bHQgPSBDYWNoZUhhbmRsZXJTZXJ2aWNlO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///17\n')},20:function(module,exports,__webpack_require__){"use strict";eval('\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError("Generator is already executing.");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nvar CacheHandler_1 = __importDefault(__webpack_require__(17));\nvar AppChecker_1 = __webpack_require__(25);\nvar RunningState = /** @class */ (function () {\n    function RunningState() {\n        this.id = null;\n        this.running = false;\n        this.progress = 0;\n        this.locked = false;\n        this.state = \'ready\';\n        this.tab_id = null;\n        this.cloud = false;\n    }\n    return RunningState;\n}());\nvar RunningData = /** @class */ (function () {\n    function RunningData() {\n        this.states = [];\n    }\n    RunningData.prototype.store = function (skipEvent) {\n        if (skipEvent === void 0) { skipEvent = false; }\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n                // Prune any running states that have gone dead\n                this.states = this.states.filter(function (state) { return state.id; });\n                return [2 /*return*/, new Promise(function (resolve) {\n                        chrome.storage.local.set({ running: { states: _this.states } }, function () { return __awaiter(_this, void 0, void 0, function () {\n                            return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                    case 0:\n                                        // Send message for UI to refresh any data it\'s holding\n                                        chrome.runtime.sendMessage({ action: \'load_running_data\', skipEvent: skipEvent });\n                                        return [4 /*yield*/, CacheHandler_1.default.expire(\'RuntimeModel\')];\n                                    case 1:\n                                        _a.sent();\n                                        resolve(null);\n                                        return [2 /*return*/];\n                                }\n                            });\n                        }); });\n                    })];\n            });\n        });\n    };\n    RunningData.prototype.load = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var appChecker, res, e_1;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, new Promise(function (resolve) {\n                            chrome.storage.local.get(\'running\', function (res) {\n                                if (res.running && res.running.states) {\n                                    _this.states = res.running.states;\n                                }\n                                else {\n                                    _this.states = [];\n                                }\n                                resolve(null);\n                            });\n                        })\n                        // Automatically filter out desktop states if the desktop app is off\n                    ];\n                    case 1:\n                        _a.sent();\n                        appChecker = new AppChecker_1.AppChecker();\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, appChecker.getInstalledVersion()];\n                    case 3:\n                        res = _a.sent();\n                        if (!res.installed) {\n                            this.states = this.states.filter(function (state) { return state.cloud; });\n                        }\n                        return [3 /*break*/, 5];\n                    case 4:\n                        e_1 = _a.sent();\n                        this.states = this.states.filter(function (state) { return state.cloud; });\n                        return [3 /*break*/, 5];\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    RunningData.prototype.loadState = function (id) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _i, _a, state;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, this.load()\n                        // Return a dead object if there are no running states\n                    ];\n                    case 1:\n                        _b.sent();\n                        // Return a dead object if there are no running states\n                        if (this.states.length === 0) {\n                            return [2 /*return*/, new RunningState()];\n                        }\n                        for (_i = 0, _a = this.states; _i < _a.length; _i++) {\n                            state = _a[_i];\n                            if (state.id === id) {\n                                return [2 /*return*/, state];\n                            }\n                        }\n                        return [2 /*return*/, new RunningState()];\n                }\n            });\n        });\n    };\n    RunningData.prototype.addState = function (id, state, cloud) {\n        if (cloud === void 0) { cloud = false; }\n        // See if there is an existing state\n        for (var _i = 0, _a = this.states; _i < _a.length; _i++) {\n            var st = _a[_i];\n            if (st.id === id) {\n                st.state = state;\n                return st;\n            }\n        }\n        var rs = new RunningState();\n        rs.id = id;\n        rs.state = state;\n        rs.cloud = cloud;\n        this.states.push(rs);\n        return rs;\n    };\n    RunningData.prototype.clearState = function (id) {\n        this.states = this.states.filter(function (state) { return state.id != id; });\n    };\n    RunningData.prototype.cloudStateCount = function () {\n        var count = 0;\n        for (var _i = 0, _a = this.states; _i < _a.length; _i++) {\n            var s = _a[_i];\n            if (s.cloud) {\n                count++;\n            }\n        }\n        return count;\n    };\n    RunningData.prototype.desktopStateCount = function () {\n        var count = 0;\n        for (var _i = 0, _a = this.states; _i < _a.length; _i++) {\n            var s = _a[_i];\n            if (!s.cloud) {\n                count++;\n            }\n        }\n        return count;\n    };\n    return RunningData;\n}());\nexports.default = RunningData;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY2xhc3Nlcy9tb2RlbHMvUnVubmluZ0RhdGEudHM/Y2Q2MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ2FjaGVIYW5kbGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3NlcnZpY2VzL0NhY2hlSGFuZGxlclwiKSk7XG52YXIgQXBwQ2hlY2tlcl8xID0gcmVxdWlyZShcIi4uL3NlcnZpY2VzL0FwcENoZWNrZXJcIik7XG52YXIgUnVubmluZ1N0YXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJ1bm5pbmdTdGF0ZSgpIHtcbiAgICAgICAgdGhpcy5pZCA9IG51bGw7XG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByb2dyZXNzID0gMDtcbiAgICAgICAgdGhpcy5sb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9ICdyZWFkeSc7XG4gICAgICAgIHRoaXMudGFiX2lkID0gbnVsbDtcbiAgICAgICAgdGhpcy5jbG91ZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gUnVubmluZ1N0YXRlO1xufSgpKTtcbnZhciBSdW5uaW5nRGF0YSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSdW5uaW5nRGF0YSgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSBbXTtcbiAgICB9XG4gICAgUnVubmluZ0RhdGEucHJvdG90eXBlLnN0b3JlID0gZnVuY3Rpb24gKHNraXBFdmVudCkge1xuICAgICAgICBpZiAoc2tpcEV2ZW50ID09PSB2b2lkIDApIHsgc2tpcEV2ZW50ID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAvLyBQcnVuZSBhbnkgcnVubmluZyBzdGF0ZXMgdGhhdCBoYXZlIGdvbmUgZGVhZFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVzID0gdGhpcy5zdGF0ZXMuZmlsdGVyKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gc3RhdGUuaWQ7IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hyb21lLnN0b3JhZ2UubG9jYWwuc2V0KHsgcnVubmluZzogeyBzdGF0ZXM6IF90aGlzLnN0YXRlcyB9IH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZW5kIG1lc3NhZ2UgZm9yIFVJIHRvIHJlZnJlc2ggYW55IGRhdGEgaXQncyBob2xkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hyb21lLnJ1bnRpbWUuc2VuZE1lc3NhZ2UoeyBhY3Rpb246ICdsb2FkX3J1bm5pbmdfZGF0YScsIHNraXBFdmVudDogc2tpcEV2ZW50IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIENhY2hlSGFuZGxlcl8xLmRlZmF1bHQuZXhwaXJlKCdSdW50aW1lTW9kZWwnKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJ1bm5pbmdEYXRhLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXBwQ2hlY2tlciwgcmVzLCBlXzE7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tZS5zdG9yYWdlLmxvY2FsLmdldCgncnVubmluZycsIGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5ydW5uaW5nICYmIHJlcy5ydW5uaW5nLnN0YXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RhdGVzID0gcmVzLnJ1bm5pbmcuc3RhdGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RhdGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdXRvbWF0aWNhbGx5IGZpbHRlciBvdXQgZGVza3RvcCBzdGF0ZXMgaWYgdGhlIGRlc2t0b3AgYXBwIGlzIG9mZlxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBDaGVja2VyID0gbmV3IEFwcENoZWNrZXJfMS5BcHBDaGVja2VyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMiwgNCwgLCA1XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBhcHBDaGVja2VyLmdldEluc3RhbGxlZFZlcnNpb24oKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzLmluc3RhbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVzID0gdGhpcy5zdGF0ZXMuZmlsdGVyKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gc3RhdGUuY2xvdWQ7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVzID0gdGhpcy5zdGF0ZXMuZmlsdGVyKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gc3RhdGUuY2xvdWQ7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJ1bm5pbmdEYXRhLnByb3RvdHlwZS5sb2FkU3RhdGUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9pLCBfYSwgc3RhdGU7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMubG9hZCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gYSBkZWFkIG9iamVjdCBpZiB0aGVyZSBhcmUgbm8gcnVubmluZyBzdGF0ZXNcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIGEgZGVhZCBvYmplY3QgaWYgdGhlcmUgYXJlIG5vIHJ1bm5pbmcgc3RhdGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBSdW5uaW5nU3RhdGUoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKF9pID0gMCwgX2EgPSB0aGlzLnN0YXRlczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBzdGF0ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBSdW5uaW5nU3RhdGUoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUnVubmluZ0RhdGEucHJvdG90eXBlLmFkZFN0YXRlID0gZnVuY3Rpb24gKGlkLCBzdGF0ZSwgY2xvdWQpIHtcbiAgICAgICAgaWYgKGNsb3VkID09PSB2b2lkIDApIHsgY2xvdWQgPSBmYWxzZTsgfVxuICAgICAgICAvLyBTZWUgaWYgdGhlcmUgaXMgYW4gZXhpc3Rpbmcgc3RhdGVcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuc3RhdGVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHN0ID0gX2FbX2ldO1xuICAgICAgICAgICAgaWYgKHN0LmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgIHN0LnN0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBycyA9IG5ldyBSdW5uaW5nU3RhdGUoKTtcbiAgICAgICAgcnMuaWQgPSBpZDtcbiAgICAgICAgcnMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgcnMuY2xvdWQgPSBjbG91ZDtcbiAgICAgICAgdGhpcy5zdGF0ZXMucHVzaChycyk7XG4gICAgICAgIHJldHVybiBycztcbiAgICB9O1xuICAgIFJ1bm5pbmdEYXRhLnByb3RvdHlwZS5jbGVhclN0YXRlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHRoaXMuc3RhdGVzID0gdGhpcy5zdGF0ZXMuZmlsdGVyKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gc3RhdGUuaWQgIT0gaWQ7IH0pO1xuICAgIH07XG4gICAgUnVubmluZ0RhdGEucHJvdG90eXBlLmNsb3VkU3RhdGVDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuc3RhdGVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHMgPSBfYVtfaV07XG4gICAgICAgICAgICBpZiAocy5jbG91ZCkge1xuICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH07XG4gICAgUnVubmluZ0RhdGEucHJvdG90eXBlLmRlc2t0b3BTdGF0ZUNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5zdGF0ZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcyA9IF9hW19pXTtcbiAgICAgICAgICAgIGlmICghcy5jbG91ZCkge1xuICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH07XG4gICAgcmV0dXJuIFJ1bm5pbmdEYXRhO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJ1bm5pbmdEYXRhO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///20\n')},25:function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * AppChecker\n * Deals with retrieving the status of the Puppeteer app - installed, running etc.\n */\nvar AppChecker = /** @class */ (function () {\n    function AppChecker() {\n    }\n    /**\n     * Check if server is currently online or out of action\n     * @return boolean True if running, False if not\n     */\n    AppChecker.prototype.serverOnline = function () {\n        return new Promise(function (resolve, reject) {\n            var a = new XMLHttpRequest();\n            a.onreadystatechange = function () {\n                if (a.readyState === a.HEADERS_RECEIVED) {\n                    a.abort();\n                    resolve(true);\n                }\n            };\n            try {\n                a.open("GET", "https://lar.axiom.ai/graphql");\n                a.send(null);\n            }\n            catch (e) {\n                resolve(false);\n            }\n        });\n    };\n    /**\n     * Launch the Desktop application using the axiomai protocol axiomai://\n     */\n    AppChecker.prototype.launchDesktopApp = function () {\n        chrome.tabs.create({ url: "axiomai://run" });\n    };\n    /**\n     * Get the installed version of Axiom\n     * @return string The version number\n     */\n    AppChecker.prototype.launchApplication = function () {\n        return new Promise(function (resolve, reject) {\n            var xhr = new XMLHttpRequest();\n            var testEndpoint = "http://localhost:3333/axiom/isrunning";\n            var currVersion = "";\n            xhr.onreadystatechange = function () {\n                if (xhr.readyState === 4 && xhr.status === 200) {\n                    currVersion = xhr.responseText;\n                    resolve({ installed: true, version: currVersion });\n                }\n                else if (xhr.readyState === 4) {\n                    reject({ installed: false, version: "" });\n                }\n            };\n            xhr.onerror = function (e) {\n                reject({ installed: false, version: "" });\n            };\n            try {\n                xhr.open("GET", testEndpoint, true);\n                xhr.timeout = 1000;\n                xhr.send();\n            }\n            catch (e) {\n                reject({ installed: false, version: "" });\n            }\n        });\n    };\n    /**\n     * Get the installed version of Axiom\n     * @return string The version number\n     */\n    AppChecker.prototype.getInstalledVersion = function (autostart) {\n        if (autostart === void 0) { autostart = false; }\n        return new Promise(function (resolve, reject) {\n            var xhr = new XMLHttpRequest();\n            var testEndpoint = "http://localhost:3333/axiom/isrunning";\n            var currVersion = "";\n            xhr.onreadystatechange = function () {\n                if (xhr.readyState === 4 && xhr.status === 200) {\n                    currVersion = xhr.responseText;\n                    resolve({ installed: true, version: currVersion });\n                }\n                else if (xhr.readyState === 4) {\n                    reject({ installed: false, version: "" });\n                }\n            };\n            xhr.onerror = function (e) {\n                reject({ installed: false, version: "" });\n            };\n            try {\n                xhr.open("GET", testEndpoint, true);\n                xhr.timeout = 1000;\n                xhr.send();\n            }\n            catch (e) {\n                reject({ installed: false, version: "" });\n            }\n        });\n    };\n    /**\n     * Retrieve the current running status of the axiom app\n     * @returns Promise<{status: string}>\n     */\n    AppChecker.prototype.getRunStatus = function () {\n        return new Promise(function (resolve, reject) {\n            var xhr = new XMLHttpRequest();\n            var testEndpoint = "http://localhost:3333/axiom/getstatus";\n            xhr.onreadystatechange = function () {\n                if (xhr.readyState === 4 && xhr.status === 200) {\n                    resolve({ status: xhr.responseText });\n                }\n                else if (xhr.readyState === 4) {\n                    reject({ status: \'closed\' });\n                }\n            };\n            xhr.onerror = function (e) {\n                reject({ status: \'closed\' });\n            };\n            try {\n                xhr.open("GET", testEndpoint, true);\n                xhr.timeout = 1000;\n                xhr.send();\n            }\n            catch (e) {\n                reject({ status: \'closed\' });\n            }\n        });\n    };\n    return AppChecker;\n}());\nexports.AppChecker = AppChecker;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY2xhc3Nlcy9zZXJ2aWNlcy9BcHBDaGVja2VyLnRzPzllMDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEFwcENoZWNrZXJcbiAqIERlYWxzIHdpdGggcmV0cmlldmluZyB0aGUgc3RhdHVzIG9mIHRoZSBQdXBwZXRlZXIgYXBwIC0gaW5zdGFsbGVkLCBydW5uaW5nIGV0Yy5cbiAqL1xudmFyIEFwcENoZWNrZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXBwQ2hlY2tlcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgc2VydmVyIGlzIGN1cnJlbnRseSBvbmxpbmUgb3Igb3V0IG9mIGFjdGlvblxuICAgICAqIEByZXR1cm4gYm9vbGVhbiBUcnVlIGlmIHJ1bm5pbmcsIEZhbHNlIGlmIG5vdFxuICAgICAqL1xuICAgIEFwcENoZWNrZXIucHJvdG90eXBlLnNlcnZlck9ubGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBhID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICBhLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoYS5yZWFkeVN0YXRlID09PSBhLkhFQURFUlNfUkVDRUlWRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgYS5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGEub3BlbihcIkdFVFwiLCBwcm9jZXNzLmVudi5HUkFQSFFMX1VSTCk7XG4gICAgICAgICAgICAgICAgYS5zZW5kKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMYXVuY2ggdGhlIERlc2t0b3AgYXBwbGljYXRpb24gdXNpbmcgdGhlIGF4aW9tYWkgcHJvdG9jb2wgYXhpb21haTovL1xuICAgICAqL1xuICAgIEFwcENoZWNrZXIucHJvdG90eXBlLmxhdW5jaERlc2t0b3BBcHAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNocm9tZS50YWJzLmNyZWF0ZSh7IHVybDogXCJheGlvbWFpOi8vcnVuXCIgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGluc3RhbGxlZCB2ZXJzaW9uIG9mIEF4aW9tXG4gICAgICogQHJldHVybiBzdHJpbmcgVGhlIHZlcnNpb24gbnVtYmVyXG4gICAgICovXG4gICAgQXBwQ2hlY2tlci5wcm90b3R5cGUubGF1bmNoQXBwbGljYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICB2YXIgdGVzdEVuZHBvaW50ID0gXCJodHRwOi8vbG9jYWxob3N0OjMzMzMvYXhpb20vaXNydW5uaW5nXCI7XG4gICAgICAgICAgICB2YXIgY3VyclZlcnNpb24gPSBcIlwiO1xuICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQgJiYgeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJWZXJzaW9uID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IGluc3RhbGxlZDogdHJ1ZSwgdmVyc2lvbjogY3VyclZlcnNpb24gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCh7IGluc3RhbGxlZDogZmFsc2UsIHZlcnNpb246IFwiXCIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoeyBpbnN0YWxsZWQ6IGZhbHNlLCB2ZXJzaW9uOiBcIlwiIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgeGhyLm9wZW4oXCJHRVRcIiwgdGVzdEVuZHBvaW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB4aHIudGltZW91dCA9IDEwMDA7XG4gICAgICAgICAgICAgICAgeGhyLnNlbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KHsgaW5zdGFsbGVkOiBmYWxzZSwgdmVyc2lvbjogXCJcIiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGluc3RhbGxlZCB2ZXJzaW9uIG9mIEF4aW9tXG4gICAgICogQHJldHVybiBzdHJpbmcgVGhlIHZlcnNpb24gbnVtYmVyXG4gICAgICovXG4gICAgQXBwQ2hlY2tlci5wcm90b3R5cGUuZ2V0SW5zdGFsbGVkVmVyc2lvbiA9IGZ1bmN0aW9uIChhdXRvc3RhcnQpIHtcbiAgICAgICAgaWYgKGF1dG9zdGFydCA9PT0gdm9pZCAwKSB7IGF1dG9zdGFydCA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICB2YXIgdGVzdEVuZHBvaW50ID0gXCJodHRwOi8vbG9jYWxob3N0OjMzMzMvYXhpb20vaXNydW5uaW5nXCI7XG4gICAgICAgICAgICB2YXIgY3VyclZlcnNpb24gPSBcIlwiO1xuICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQgJiYgeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJWZXJzaW9uID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IGluc3RhbGxlZDogdHJ1ZSwgdmVyc2lvbjogY3VyclZlcnNpb24gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCh7IGluc3RhbGxlZDogZmFsc2UsIHZlcnNpb246IFwiXCIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoeyBpbnN0YWxsZWQ6IGZhbHNlLCB2ZXJzaW9uOiBcIlwiIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgeGhyLm9wZW4oXCJHRVRcIiwgdGVzdEVuZHBvaW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB4aHIudGltZW91dCA9IDEwMDA7XG4gICAgICAgICAgICAgICAgeGhyLnNlbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KHsgaW5zdGFsbGVkOiBmYWxzZSwgdmVyc2lvbjogXCJcIiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBydW5uaW5nIHN0YXR1cyBvZiB0aGUgYXhpb20gYXBwXG4gICAgICogQHJldHVybnMgUHJvbWlzZTx7c3RhdHVzOiBzdHJpbmd9PlxuICAgICAqL1xuICAgIEFwcENoZWNrZXIucHJvdG90eXBlLmdldFJ1blN0YXR1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHZhciB0ZXN0RW5kcG9pbnQgPSBcImh0dHA6Ly9sb2NhbGhvc3Q6MzMzMy9heGlvbS9nZXRzdGF0dXNcIjtcbiAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0ICYmIHhoci5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgc3RhdHVzOiB4aHIucmVzcG9uc2VUZXh0IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoeyBzdGF0dXM6ICdjbG9zZWQnIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KHsgc3RhdHVzOiAnY2xvc2VkJyB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHhoci5vcGVuKFwiR0VUXCIsIHRlc3RFbmRwb2ludCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgeGhyLnRpbWVvdXQgPSAxMDAwO1xuICAgICAgICAgICAgICAgIHhoci5zZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdCh7IHN0YXR1czogJ2Nsb3NlZCcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEFwcENoZWNrZXI7XG59KCkpO1xuZXhwb3J0cy5BcHBDaGVja2VyID0gQXBwQ2hlY2tlcjtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///25\n')},35:function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar WidgetNestable = /** @class */ (function () {\n    function WidgetNestable(indent, outdent, middent, widgetShow) {\n        if (middent === void 0) { middent = ''; }\n        if (widgetShow === void 0) { widgetShow = 'all'; }\n        this.indent = indent;\n        this.middent = middent;\n        this.outdent = outdent;\n        this.widgetShow = widgetShow;\n    }\n    return WidgetNestable;\n}());\nvar NestingData = /** @class */ (function () {\n    function NestingData(indent, startingBlock, endingBlock, midBlock) {\n        if (midBlock === void 0) { midBlock = false; }\n        this.indent = indent;\n        this.startingBlock = startingBlock;\n        this.midBlock = midBlock;\n        this.endingBlock = endingBlock;\n        this.outputShow = false;\n    }\n    return NestingData;\n}());\nexports.NestingData = NestingData;\nvar WidgetsNestable = /** @class */ (function () {\n    function WidgetsNestable() {\n        this.list = [\n            new WidgetNestable('WidgetBotCreate', 'WidgetBotComplete'),\n            new WidgetNestable('TemplateUIBot', 'TemplateUIBot'),\n            new WidgetNestable('WidgetIf', 'WidgetIfEnd'),\n            new WidgetNestable('WidgetTry', 'WidgetTryCatchEnd', 'WidgetCatch'),\n            new WidgetNestable('TemplateIfStatememt', 'TemplateIfStatement'),\n            new WidgetNestable('TemplateLoopThroughData', 'TemplateLoopThroughData'),\n            new WidgetNestable('TemplateTryCatch', 'TemplateTryCatch')\n        ];\n    }\n    WidgetsNestable.prototype.getWidgetList = function (widgets, windex) {\n        for (var _i = 0, _a = this.list; _i < _a.length; _i++) {\n            var wn = _a[_i];\n            for (var i = windex - 1; i >= 0; i--) {\n                if (wn.indent === widgets[i].machine_name) {\n                    for (var j = windex; j < widgets.length; j++) {\n                        if (wn.outdent === widgets[j].machine_name) {\n                            return wn.widgetShow;\n                        }\n                    }\n                }\n            }\n        }\n        return 'all';\n    };\n    WidgetsNestable.prototype.getIndentWindex = function (widgets, windex, indent) {\n        var wn = this.list.filter(function (item) {\n            return item.indent === indent;\n        });\n        if (!wn || wn.length === 0) {\n            return -1;\n        }\n        for (var i = windex; i >= 0; i--) {\n            if (wn[0].indent === widgets[i].machine_name) {\n                return i;\n            }\n        }\n        return -1;\n    };\n    WidgetsNestable.prototype.isNestable = function (widget) {\n        if (!widget) {\n            return 0;\n        }\n        for (var _i = 0, _a = this.list; _i < _a.length; _i++) {\n            var item = _a[_i];\n            if (item.indent === widget.machine_name) {\n                return 1;\n            }\n            else if (item.outdent === widget.machine_name) {\n                return 2;\n            }\n            else if (item.middent === widget.machine_name) {\n                return 3;\n            }\n        }\n        return 0;\n    };\n    WidgetsNestable.prototype.buildNestingData = function (widgets) {\n        var indents = [];\n        var indent = 0;\n        for (var windex in widgets) {\n            var isNestable = this.isNestable(widgets[windex]);\n            switch (isNestable) {\n                case 0:\n                    indents[windex] = new NestingData(indent, false, false);\n                    break;\n                case 1:\n                    indents[windex] = new NestingData(indent, true, false);\n                    indent++;\n                    break;\n                case 2:\n                    indent--;\n                    indents[windex] = new NestingData(indent, false, true);\n                    break;\n                case 3:\n                    indents[windex] = new NestingData(indent, false, false, true);\n            }\n        }\n        return indents;\n    };\n    WidgetsNestable.prototype.nullNestingData = function () {\n        return new NestingData(0, false, false);\n    };\n    return WidgetsNestable;\n}());\nexports.WidgetsNestable = WidgetsNestable;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXhpb21idWlsZGVyL21vZGVscy9XaWRnZXRzTmVzdGFibGUudHM/NTJjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBXaWRnZXROZXN0YWJsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXaWRnZXROZXN0YWJsZShpbmRlbnQsIG91dGRlbnQsIG1pZGRlbnQsIHdpZGdldFNob3cpIHtcbiAgICAgICAgaWYgKG1pZGRlbnQgPT09IHZvaWQgMCkgeyBtaWRkZW50ID0gJyc7IH1cbiAgICAgICAgaWYgKHdpZGdldFNob3cgPT09IHZvaWQgMCkgeyB3aWRnZXRTaG93ID0gJ2FsbCc7IH1cbiAgICAgICAgdGhpcy5pbmRlbnQgPSBpbmRlbnQ7XG4gICAgICAgIHRoaXMubWlkZGVudCA9IG1pZGRlbnQ7XG4gICAgICAgIHRoaXMub3V0ZGVudCA9IG91dGRlbnQ7XG4gICAgICAgIHRoaXMud2lkZ2V0U2hvdyA9IHdpZGdldFNob3c7XG4gICAgfVxuICAgIHJldHVybiBXaWRnZXROZXN0YWJsZTtcbn0oKSk7XG52YXIgTmVzdGluZ0RhdGEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmVzdGluZ0RhdGEoaW5kZW50LCBzdGFydGluZ0Jsb2NrLCBlbmRpbmdCbG9jaywgbWlkQmxvY2spIHtcbiAgICAgICAgaWYgKG1pZEJsb2NrID09PSB2b2lkIDApIHsgbWlkQmxvY2sgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLmluZGVudCA9IGluZGVudDtcbiAgICAgICAgdGhpcy5zdGFydGluZ0Jsb2NrID0gc3RhcnRpbmdCbG9jaztcbiAgICAgICAgdGhpcy5taWRCbG9jayA9IG1pZEJsb2NrO1xuICAgICAgICB0aGlzLmVuZGluZ0Jsb2NrID0gZW5kaW5nQmxvY2s7XG4gICAgICAgIHRoaXMub3V0cHV0U2hvdyA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gTmVzdGluZ0RhdGE7XG59KCkpO1xuZXhwb3J0cy5OZXN0aW5nRGF0YSA9IE5lc3RpbmdEYXRhO1xudmFyIFdpZGdldHNOZXN0YWJsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXaWRnZXRzTmVzdGFibGUoKSB7XG4gICAgICAgIHRoaXMubGlzdCA9IFtcbiAgICAgICAgICAgIG5ldyBXaWRnZXROZXN0YWJsZSgnV2lkZ2V0Qm90Q3JlYXRlJywgJ1dpZGdldEJvdENvbXBsZXRlJyksXG4gICAgICAgICAgICBuZXcgV2lkZ2V0TmVzdGFibGUoJ1RlbXBsYXRlVUlCb3QnLCAnVGVtcGxhdGVVSUJvdCcpLFxuICAgICAgICAgICAgbmV3IFdpZGdldE5lc3RhYmxlKCdXaWRnZXRJZicsICdXaWRnZXRJZkVuZCcpLFxuICAgICAgICAgICAgbmV3IFdpZGdldE5lc3RhYmxlKCdXaWRnZXRUcnknLCAnV2lkZ2V0VHJ5Q2F0Y2hFbmQnLCAnV2lkZ2V0Q2F0Y2gnKSxcbiAgICAgICAgICAgIG5ldyBXaWRnZXROZXN0YWJsZSgnVGVtcGxhdGVJZlN0YXRlbWVtdCcsICdUZW1wbGF0ZUlmU3RhdGVtZW50JyksXG4gICAgICAgICAgICBuZXcgV2lkZ2V0TmVzdGFibGUoJ1RlbXBsYXRlTG9vcFRocm91Z2hEYXRhJywgJ1RlbXBsYXRlTG9vcFRocm91Z2hEYXRhJyksXG4gICAgICAgICAgICBuZXcgV2lkZ2V0TmVzdGFibGUoJ1RlbXBsYXRlVHJ5Q2F0Y2gnLCAnVGVtcGxhdGVUcnlDYXRjaCcpXG4gICAgICAgIF07XG4gICAgfVxuICAgIFdpZGdldHNOZXN0YWJsZS5wcm90b3R5cGUuZ2V0V2lkZ2V0TGlzdCA9IGZ1bmN0aW9uICh3aWRnZXRzLCB3aW5kZXgpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMubGlzdDsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciB3biA9IF9hW19pXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB3aW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmICh3bi5pbmRlbnQgPT09IHdpZGdldHNbaV0ubWFjaGluZV9uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSB3aW5kZXg7IGogPCB3aWRnZXRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod24ub3V0ZGVudCA9PT0gd2lkZ2V0c1tqXS5tYWNoaW5lX25hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd24ud2lkZ2V0U2hvdztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ2FsbCc7XG4gICAgfTtcbiAgICBXaWRnZXRzTmVzdGFibGUucHJvdG90eXBlLmdldEluZGVudFdpbmRleCA9IGZ1bmN0aW9uICh3aWRnZXRzLCB3aW5kZXgsIGluZGVudCkge1xuICAgICAgICB2YXIgd24gPSB0aGlzLmxpc3QuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5pbmRlbnQgPT09IGluZGVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghd24gfHwgd24ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IHdpbmRleDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmICh3blswXS5pbmRlbnQgPT09IHdpZGdldHNbaV0ubWFjaGluZV9uYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gICAgV2lkZ2V0c05lc3RhYmxlLnByb3RvdHlwZS5pc05lc3RhYmxlID0gZnVuY3Rpb24gKHdpZGdldCkge1xuICAgICAgICBpZiAoIXdpZGdldCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMubGlzdDsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gX2FbX2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0uaW5kZW50ID09PSB3aWRnZXQubWFjaGluZV9uYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtLm91dGRlbnQgPT09IHdpZGdldC5tYWNoaW5lX25hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0ubWlkZGVudCA9PT0gd2lkZ2V0Lm1hY2hpbmVfbmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgV2lkZ2V0c05lc3RhYmxlLnByb3RvdHlwZS5idWlsZE5lc3RpbmdEYXRhID0gZnVuY3Rpb24gKHdpZGdldHMpIHtcbiAgICAgICAgdmFyIGluZGVudHMgPSBbXTtcbiAgICAgICAgdmFyIGluZGVudCA9IDA7XG4gICAgICAgIGZvciAodmFyIHdpbmRleCBpbiB3aWRnZXRzKSB7XG4gICAgICAgICAgICB2YXIgaXNOZXN0YWJsZSA9IHRoaXMuaXNOZXN0YWJsZSh3aWRnZXRzW3dpbmRleF0pO1xuICAgICAgICAgICAgc3dpdGNoIChpc05lc3RhYmxlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBpbmRlbnRzW3dpbmRleF0gPSBuZXcgTmVzdGluZ0RhdGEoaW5kZW50LCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGluZGVudHNbd2luZGV4XSA9IG5ldyBOZXN0aW5nRGF0YShpbmRlbnQsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50LS07XG4gICAgICAgICAgICAgICAgICAgIGluZGVudHNbd2luZGV4XSA9IG5ldyBOZXN0aW5nRGF0YShpbmRlbnQsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBpbmRlbnRzW3dpbmRleF0gPSBuZXcgTmVzdGluZ0RhdGEoaW5kZW50LCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRlbnRzO1xuICAgIH07XG4gICAgV2lkZ2V0c05lc3RhYmxlLnByb3RvdHlwZS5udWxsTmVzdGluZ0RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTmVzdGluZ0RhdGEoMCwgZmFsc2UsIGZhbHNlKTtcbiAgICB9O1xuICAgIHJldHVybiBXaWRnZXRzTmVzdGFibGU7XG59KCkpO1xuZXhwb3J0cy5XaWRnZXRzTmVzdGFibGUgPSBXaWRnZXRzTmVzdGFibGU7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///35\n")},38:function(module,exports){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///38\n')},404:function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar diff_match_patch_typescript_1 = __webpack_require__(820);\n/**\n * Generates a selector for the hierarchy of the target element from DOM\n */\nvar AttributeSelector = /** @class */ (function () {\n    function AttributeSelector() {\n    }\n    AttributeSelector.prototype.getSelector = function (el) {\n        var hierarchy = [];\n        var parentEl = el;\n        while (parentEl && parentEl.tagName.toLowerCase() !== 'html') {\n            var attr = (parentEl.tagName) ? parentEl.tagName.toLowerCase() : '';\n            var map = (parentEl.attributes) ? parentEl.attributes : [];\n            for (var _i = 0, map_1 = map; _i < map_1.length; _i++) {\n                var mp = map_1[_i];\n                if (!/click|style|\\-|href|src|on\\w+/g.test(mp.name)) {\n                    if (mp.name === 'class') {\n                        var classes = mp.value.split(' ');\n                        for (var _a = 0, classes_1 = classes; _a < classes_1.length; _a++) {\n                            var sClass = classes_1[_a];\n                            // Can remove the selectorgadget_ matcher from regex when we are done with the front-end part of the selector tool\n                            if (sClass !== '' && !/\\:|\\:\\/\\/|[\\(\\)\\$\\{\\}]|axiom-matched|axiom-suggested-group|axiom-link|axiom-download|axiom-sel-\\S+|selectorgadget_\\w+/g.test(sClass)) {\n                                attr += '[class~=\"' + sClass + '\"]';\n                            }\n                        }\n                    }\n                    else {\n                        if (!/value|data|\\[|\\]/gi.test(mp.name) && mp.value !== '' && !/\\:|\\:\\/\\//gi.test(mp.value)) {\n                            attr += '[' + mp.name + '=\"' + mp.value.replace(/\\\"/g, '\\\\\"') + '\"]';\n                        }\n                    }\n                }\n            }\n            hierarchy.unshift((attr === '') ? parentEl.tagName.toLowerCase() : attr);\n            parentEl = parentEl.parentElement;\n        }\n        // Useful sanity test - commented out because it shouldn't run in production\n        /*for (let h of hierarchy) {\n            try {\n                document.querySelectorAll(h)\n            } catch (e) {\n                console.error(\"failed querySelector: \", h)\n            }\n        }*/\n        return hierarchy.join(' > ');\n    };\n    /**\n     * Fetches the group selector out of a list of attribute selector\n     *\n     */\n    AttributeSelector.prototype.groupAttributeSelectors = function (selectors) {\n        var commonAncestor = selectors[0];\n        if (selectors.length > 1) {\n            var dmp = new diff_match_patch_typescript_1.DiffMatchPatch();\n            for (var i = 1; i < selectors.length; i++) {\n                var tempDiff = [];\n                tempDiff = dmp.diff_main(commonAncestor, selectors[i]);\n                commonAncestor = '';\n                for (var _i = 0, tempDiff_1 = tempDiff; _i < tempDiff_1.length; _i++) {\n                    var diff = tempDiff_1[_i];\n                    if (diff[0] === 0) {\n                        commonAncestor += diff[1];\n                    }\n                    if (commonAncestor !== '' && diff[0] !== 0) {\n                        break;\n                    }\n                }\n            }\n        }\n        var cleanedGroup = this.cleanupGroupingSelector(commonAncestor);\n        while (this.groupSelectorValidator(cleanedGroup, selectors) !== true) {\n            // trims away the last element from the selector\n            cleanedGroup = cleanedGroup.replace(/(\\s>\\s)(\\S*\\[\\S*\\]|\\S)$/gm, '');\n        }\n        return cleanedGroup;\n    };\n    /**\n     * Validates whether the group selector selects targetted elements\n     *\n     * @param groupSelector\n     * @param elementSelectors\n     */\n    AttributeSelector.prototype.groupSelectorValidator = function (groupSelector, elementSelectors) {\n        var groupEl = document.querySelectorAll(groupSelector);\n        var elementCount = elementSelectors.length;\n        var elementSelectorsString = elementSelectors.join(', ');\n        var elementsWithinGroup = 0;\n        groupEl.forEach(function (el) {\n            var items = el.querySelectorAll(elementSelectorsString);\n            if (items.length >= 0) {\n                elementsWithinGroup = items.length;\n            }\n        });\n        // Would work for cases where selections are made within a single list item\n        if (elementsWithinGroup >= elementCount) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    /**\n     * Cleans selector string from incorrect string\n     *\n     * @param selector\n     */\n    AttributeSelector.prototype.cleanupGroupingSelector = function (selector) {\n        var cleanedSelector = selector;\n        var lastCleanedCss = null;\n        while (lastCleanedCss !== cleanedSelector) {\n            lastCleanedCss = cleanedSelector;\n            cleanedSelector = cleanedSelector\n                // removes empty class attributes\n                // [class~=\"\"]\n                .replace(/\\[class\\~\\=\\\"\\\"\\]/gm, '')\n                // removes ' > ' from end of string\n                .replace(/(\\s*\\>+\\s*)$/gm, '')\n                // removes empty attribute selections \n                // > [class~=\"xso\"] > \n                .replace(/(\\>\\s*\\[\\S*\\]\\s*\\>\\s*)/gm, '')\n                // removes dangling attributes at the end of string\n                //  > div[class~=\"\"\n                .replace(/(\\s*\\>\\s*\\S*\\[\\S*\\s*(?<!\\]))$/gm, '');\n        }\n        return cleanedSelector;\n    };\n    return AttributeSelector;\n}());\nexports.AttributeSelector = AttributeSelector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDA0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3JlY29yZGVyL1NlbGVjdG9ycy9BdHRyaWJ1dGVTZWxlY3Rvci50cz9kOWRjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRpZmZfbWF0Y2hfcGF0Y2hfdHlwZXNjcmlwdF8xID0gcmVxdWlyZShcImRpZmYtbWF0Y2gtcGF0Y2gtdHlwZXNjcmlwdFwiKTtcbi8qKlxuICogR2VuZXJhdGVzIGEgc2VsZWN0b3IgZm9yIHRoZSBoaWVyYXJjaHkgb2YgdGhlIHRhcmdldCBlbGVtZW50IGZyb20gRE9NXG4gKi9cbnZhciBBdHRyaWJ1dGVTZWxlY3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBdHRyaWJ1dGVTZWxlY3RvcigpIHtcbiAgICB9XG4gICAgQXR0cmlidXRlU2VsZWN0b3IucHJvdG90eXBlLmdldFNlbGVjdG9yID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHZhciBoaWVyYXJjaHkgPSBbXTtcbiAgICAgICAgdmFyIHBhcmVudEVsID0gZWw7XG4gICAgICAgIHdoaWxlIChwYXJlbnRFbCAmJiBwYXJlbnRFbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdodG1sJykge1xuICAgICAgICAgICAgdmFyIGF0dHIgPSAocGFyZW50RWwudGFnTmFtZSkgPyBwYXJlbnRFbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgOiAnJztcbiAgICAgICAgICAgIHZhciBtYXAgPSAocGFyZW50RWwuYXR0cmlidXRlcykgPyBwYXJlbnRFbC5hdHRyaWJ1dGVzIDogW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG1hcF8xID0gbWFwOyBfaSA8IG1hcF8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBtcCA9IG1hcF8xW19pXTtcbiAgICAgICAgICAgICAgICBpZiAoIS9jbGlja3xzdHlsZXxcXC18aHJlZnxzcmN8b25cXHcrL2cudGVzdChtcC5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobXAubmFtZSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBtcC52YWx1ZS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBjbGFzc2VzXzEgPSBjbGFzc2VzOyBfYSA8IGNsYXNzZXNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc0NsYXNzID0gY2xhc3Nlc18xW19hXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYW4gcmVtb3ZlIHRoZSBzZWxlY3RvcmdhZGdldF8gbWF0Y2hlciBmcm9tIHJlZ2V4IHdoZW4gd2UgYXJlIGRvbmUgd2l0aCB0aGUgZnJvbnQtZW5kIHBhcnQgb2YgdGhlIHNlbGVjdG9yIHRvb2xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc0NsYXNzICE9PSAnJyAmJiAhL1xcOnxcXDpcXC9cXC98W1xcKFxcKVxcJFxce1xcfV18YXhpb20tbWF0Y2hlZHxheGlvbS1zdWdnZXN0ZWQtZ3JvdXB8YXhpb20tbGlua3xheGlvbS1kb3dubG9hZHxheGlvbS1zZWwtXFxTK3xzZWxlY3RvcmdhZGdldF9cXHcrL2cudGVzdChzQ2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIgKz0gJ1tjbGFzc349XCInICsgc0NsYXNzICsgJ1wiXSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEvdmFsdWV8ZGF0YXxcXFt8XFxdL2dpLnRlc3QobXAubmFtZSkgJiYgbXAudmFsdWUgIT09ICcnICYmICEvXFw6fFxcOlxcL1xcLy9naS50ZXN0KG1wLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIgKz0gJ1snICsgbXAubmFtZSArICc9XCInICsgbXAudmFsdWUucmVwbGFjZSgvXFxcIi9nLCAnXFxcXFwiJykgKyAnXCJdJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhpZXJhcmNoeS51bnNoaWZ0KChhdHRyID09PSAnJykgPyBwYXJlbnRFbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgOiBhdHRyKTtcbiAgICAgICAgICAgIHBhcmVudEVsID0gcGFyZW50RWwucGFyZW50RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2VmdWwgc2FuaXR5IHRlc3QgLSBjb21tZW50ZWQgb3V0IGJlY2F1c2UgaXQgc2hvdWxkbid0IHJ1biBpbiBwcm9kdWN0aW9uXG4gICAgICAgIC8qZm9yIChsZXQgaCBvZiBoaWVyYXJjaHkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChoKVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJmYWlsZWQgcXVlcnlTZWxlY3RvcjogXCIsIGgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0qL1xuICAgICAgICByZXR1cm4gaGllcmFyY2h5LmpvaW4oJyA+ICcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgZ3JvdXAgc2VsZWN0b3Igb3V0IG9mIGEgbGlzdCBvZiBhdHRyaWJ1dGUgc2VsZWN0b3JcbiAgICAgKlxuICAgICAqL1xuICAgIEF0dHJpYnV0ZVNlbGVjdG9yLnByb3RvdHlwZS5ncm91cEF0dHJpYnV0ZVNlbGVjdG9ycyA9IGZ1bmN0aW9uIChzZWxlY3RvcnMpIHtcbiAgICAgICAgdmFyIGNvbW1vbkFuY2VzdG9yID0gc2VsZWN0b3JzWzBdO1xuICAgICAgICBpZiAoc2VsZWN0b3JzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBkbXAgPSBuZXcgZGlmZl9tYXRjaF9wYXRjaF90eXBlc2NyaXB0XzEuRGlmZk1hdGNoUGF0Y2goKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBEaWZmID0gW107XG4gICAgICAgICAgICAgICAgdGVtcERpZmYgPSBkbXAuZGlmZl9tYWluKGNvbW1vbkFuY2VzdG9yLCBzZWxlY3RvcnNbaV0pO1xuICAgICAgICAgICAgICAgIGNvbW1vbkFuY2VzdG9yID0gJyc7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCB0ZW1wRGlmZl8xID0gdGVtcERpZmY7IF9pIDwgdGVtcERpZmZfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpZmYgPSB0ZW1wRGlmZl8xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpZmZbMF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1vbkFuY2VzdG9yICs9IGRpZmZbMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1vbkFuY2VzdG9yICE9PSAnJyAmJiBkaWZmWzBdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY2xlYW5lZEdyb3VwID0gdGhpcy5jbGVhbnVwR3JvdXBpbmdTZWxlY3Rvcihjb21tb25BbmNlc3Rvcik7XG4gICAgICAgIHdoaWxlICh0aGlzLmdyb3VwU2VsZWN0b3JWYWxpZGF0b3IoY2xlYW5lZEdyb3VwLCBzZWxlY3RvcnMpICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyB0cmltcyBhd2F5IHRoZSBsYXN0IGVsZW1lbnQgZnJvbSB0aGUgc2VsZWN0b3JcbiAgICAgICAgICAgIGNsZWFuZWRHcm91cCA9IGNsZWFuZWRHcm91cC5yZXBsYWNlKC8oXFxzPlxccykoXFxTKlxcW1xcUypcXF18XFxTKSQvZ20sICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xlYW5lZEdyb3VwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHdoZXRoZXIgdGhlIGdyb3VwIHNlbGVjdG9yIHNlbGVjdHMgdGFyZ2V0dGVkIGVsZW1lbnRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZ3JvdXBTZWxlY3RvclxuICAgICAqIEBwYXJhbSBlbGVtZW50U2VsZWN0b3JzXG4gICAgICovXG4gICAgQXR0cmlidXRlU2VsZWN0b3IucHJvdG90eXBlLmdyb3VwU2VsZWN0b3JWYWxpZGF0b3IgPSBmdW5jdGlvbiAoZ3JvdXBTZWxlY3RvciwgZWxlbWVudFNlbGVjdG9ycykge1xuICAgICAgICB2YXIgZ3JvdXBFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZ3JvdXBTZWxlY3Rvcik7XG4gICAgICAgIHZhciBlbGVtZW50Q291bnQgPSBlbGVtZW50U2VsZWN0b3JzLmxlbmd0aDtcbiAgICAgICAgdmFyIGVsZW1lbnRTZWxlY3RvcnNTdHJpbmcgPSBlbGVtZW50U2VsZWN0b3JzLmpvaW4oJywgJyk7XG4gICAgICAgIHZhciBlbGVtZW50c1dpdGhpbkdyb3VwID0gMDtcbiAgICAgICAgZ3JvdXBFbC5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gZWwucXVlcnlTZWxlY3RvckFsbChlbGVtZW50U2VsZWN0b3JzU3RyaW5nKTtcbiAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPj0gMCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzV2l0aGluR3JvdXAgPSBpdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXb3VsZCB3b3JrIGZvciBjYXNlcyB3aGVyZSBzZWxlY3Rpb25zIGFyZSBtYWRlIHdpdGhpbiBhIHNpbmdsZSBsaXN0IGl0ZW1cbiAgICAgICAgaWYgKGVsZW1lbnRzV2l0aGluR3JvdXAgPj0gZWxlbWVudENvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xlYW5zIHNlbGVjdG9yIHN0cmluZyBmcm9tIGluY29ycmVjdCBzdHJpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZWxlY3RvclxuICAgICAqL1xuICAgIEF0dHJpYnV0ZVNlbGVjdG9yLnByb3RvdHlwZS5jbGVhbnVwR3JvdXBpbmdTZWxlY3RvciA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICB2YXIgY2xlYW5lZFNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHZhciBsYXN0Q2xlYW5lZENzcyA9IG51bGw7XG4gICAgICAgIHdoaWxlIChsYXN0Q2xlYW5lZENzcyAhPT0gY2xlYW5lZFNlbGVjdG9yKSB7XG4gICAgICAgICAgICBsYXN0Q2xlYW5lZENzcyA9IGNsZWFuZWRTZWxlY3RvcjtcbiAgICAgICAgICAgIGNsZWFuZWRTZWxlY3RvciA9IGNsZWFuZWRTZWxlY3RvclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZXMgZW1wdHkgY2xhc3MgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIC8vIFtjbGFzc349XCJcIl1cbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxbY2xhc3NcXH5cXD1cXFwiXFxcIlxcXS9nbSwgJycpXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlcyAnID4gJyBmcm9tIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvKFxccypcXD4rXFxzKikkL2dtLCAnJylcbiAgICAgICAgICAgICAgICAvLyByZW1vdmVzIGVtcHR5IGF0dHJpYnV0ZSBzZWxlY3Rpb25zIFxuICAgICAgICAgICAgICAgIC8vID4gW2NsYXNzfj1cInhzb1wiXSA+IFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXFw+XFxzKlxcW1xcUypcXF1cXHMqXFw+XFxzKikvZ20sICcnKVxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZXMgZGFuZ2xpbmcgYXR0cmlidXRlcyBhdCB0aGUgZW5kIG9mIHN0cmluZ1xuICAgICAgICAgICAgICAgIC8vICA+IGRpdltjbGFzc349XCJcIlxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXFxzKlxcPlxccypcXFMqXFxbXFxTKlxccyooPzwhXFxdKSkkL2dtLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsZWFuZWRTZWxlY3RvcjtcbiAgICB9O1xuICAgIHJldHVybiBBdHRyaWJ1dGVTZWxlY3Rvcjtcbn0oKSk7XG5leHBvcnRzLkF0dHJpYnV0ZVNlbGVjdG9yID0gQXR0cmlidXRlU2VsZWN0b3I7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///404\n")},405:function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ScrapeHelper = /** @class */ (function () {\n    function ScrapeHelper() {\n        // This generates and stores the grouping selector when a preview is being built. Used later to visually highlight the grouping.\n        this.groupSelector = \"\";\n    }\n    ScrapeHelper.prototype.getPreview = function (doc, selectors, resultTypes) {\n        if (selectors && selectors.length > 0 && selectors[0] !== \"No valid path found.\" && /[^\\[\\]\"']/g.test(JSON.stringify(selectors))) {\n            var traces = this.mapTraces(doc, selectors, resultTypes);\n            if (Array.isArray(traces)) {\n                return traces;\n            }\n            else {\n                return [];\n            }\n        }\n        else {\n            return [[]];\n        }\n    };\n    ScrapeHelper.prototype.getDataV0210 = function (el, resultType) {\n        var data = '';\n        switch (resultType) { //TODO: review all result types\n            case 'outerHTML':\n                data = el.outerHTML;\n                break;\n            case 'innerHTML':\n                data = el.innerHTML;\n                if (!data) {\n                    data = el.outerHTML;\n                }\n                break;\n            case 'textContent':\n                data = '';\n                var text = el['innerText'];\n                if (typeof (text !== 'text')) {\n                    text = String(text);\n                }\n                if (text) {\n                    data = text.trim();\n                }\n                if (data === '') {\n                    try {\n                        var el2 = el;\n                        data = el2.value.trim();\n                    }\n                    catch (e) {\n                        // Stop execution from finishing here if there's an error\n                    }\n                }\n                break;\n            case 'link': //TODO: expand to match custom link result type in scraper\n            case 'href':\n                var linkEl = el;\n                if (!el.hasAttribute('href')) {\n                    var children = el.querySelectorAll('[href]');\n                    if (children && children.length) {\n                        linkEl = children[0];\n                    }\n                }\n                var href = null;\n                if (linkEl.hasAttribute('href')) {\n                    href = linkEl['href'];\n                }\n                data = (href !== null) ? href : '';\n                break;\n            case 'image':\n                var imgEl = el;\n                if (!el.hasAttribute('src') && !el.hasAttribute('srcset')) {\n                    var children = Array.from(el.querySelectorAll('[src]')).concat(Array.from(el.querySelectorAll('[srcset]')));\n                    if (children && children.length) {\n                        // According to Barlow, the last item is \"almost always\" correct, but this isn't really possible to determine without some extra UI\n                        imgEl = children[children.length - 1];\n                    }\n                }\n                var src = null;\n                if (imgEl.hasAttribute('src')) {\n                    src = imgEl['src'];\n                }\n                else if (imgEl.hasAttribute('srcset')) {\n                    src = imgEl['srcset'];\n                }\n                data = (src !== null) ? src : '';\n                break;\n        }\n        return data;\n    };\n    ScrapeHelper.prototype.getData = function (el, resultType) {\n        var scrapeLink = (resultType === \"link\" || resultType === 'href');\n        resultType = (scrapeLink) ? \"outerHTML\" : resultType;\n        var result = el[resultType];\n        if (scrapeLink) {\n            var i = 1;\n            var res = '';\n            while (res == \"\" && i <= 5) {\n                result = el[resultType];\n                var href = el['href'];\n                var link = void 0;\n                if (href && href.match(/(([A-Za-z]+[:][/][/])|([/][^\"' ])).[^\"' ]+[^\"' ]+([^\"' ])/)) {\n                    link = href;\n                }\n                else {\n                    var resultMatched = result.match(/href=[\"'](([A-Za-z]+[:][/][/])|([/][^\"' ])).[^\"' ]+[^\"' ]+([^\"' ])/);\n                    if (resultMatched) {\n                        link = resultMatched[0].substring(6);\n                    }\n                    else {\n                        var linkMatched = result.match(/[\"'](([A-Za-z]+[:][/][/])|([/][^\"' ])).[^\"' ]+[/]+[^\"' ]+([^\"' ])/);\n                        if (linkMatched) {\n                            link = linkMatched[0].substring(1);\n                        }\n                        else {\n                            res = \"\";\n                        }\n                    }\n                }\n                if (link) {\n                    if (link[0] == '/') {\n                        var url = window.location.href;\n                        if (link[1] == '/') {\n                            link = url.match(/.[^/]+[/][/]/)[0] + link.substring(2);\n                        }\n                        else {\n                            link = url.match(/[A-Za-z]+[:][/].[^/]+[/]/)[0] + link.substring(1);\n                        }\n                    }\n                    res = (link) ? link : \"\";\n                }\n                // If we didn't get a link then instead look at the parent of the current element and try to get a link from that instead\n                if (res === \"\") {\n                    var parent = el.parentElement;\n                    if (parent && parent.innerHTML) {\n                        i++;\n                        el = parent;\n                    }\n                    else {\n                        break;\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n            result = res;\n        }\n        return result;\n    };\n    ScrapeHelper.prototype.countSiblingsLeft = function (el) {\n        var siblings = [];\n        var n = el;\n        var done = false;\n        while (!done) {\n            var sibling = n.previousElementSibling;\n            if (sibling) {\n                siblings.push(sibling);\n                n = sibling;\n            }\n            else {\n                done = true;\n            }\n        }\n        return siblings.length;\n    };\n    ScrapeHelper.prototype.getRootTree = function (el) {\n        var rootTree = [];\n        var node = el;\n        var done = false;\n        while (!done) {\n            var nthCount = this.countSiblingsLeft(node);\n            rootTree.unshift(nthCount);\n            var parent = node.parentElement;\n            if (parent) {\n                node = parent;\n            }\n            else {\n                done = true;\n            }\n        }\n        return rootTree;\n    };\n    ScrapeHelper.prototype.tracesEqual = function (a, b, depth) {\n        if (!a || !b) {\n            return false;\n        }\n        for (var i = 0; i < depth; i++) {\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    };\n    ScrapeHelper.prototype.attemptGroups = function (all_res, gDepth) {\n        var groups = [];\n        var grouped = [];\n        var lastRow = 0;\n        var rowToAddTo = null;\n        for (var _i = 0, all_res_1 = all_res; _i < all_res_1.length; _i++) {\n            var res = all_res_1[_i];\n            grouped.push([]);\n            for (var _a = 0, res_1 = res; _a < res_1.length; _a++) {\n                var item = res_1[_a];\n                var colsProcessed = 0;\n                // OK, so we need to check this item's trace against items not in this column to find a matching trace.\n                // If we find the matching row, insert our item there and stop. If we fall off the end, push the new row instead.\n                var traceMatchFound = false;\n                for (var g = 0; g < grouped.length - 1; g++) {\n                    var colProcessed = 0;\n                    for (var i = 0; i < grouped[g].length; i++) {\n                        if (grouped[g][i] && item.trace) {\n                            colProcessed = 1;\n                            traceMatchFound = this.tracesEqual(grouped[g][i].trace, item.trace, gDepth);\n                            if (traceMatchFound) {\n                                rowToAddTo = i;\n                                break;\n                            }\n                        }\n                    }\n                    colsProcessed += colProcessed;\n                    if (traceMatchFound)\n                        break;\n                }\n                if (colsProcessed === 1) {\n                    // If only one column has been processed, we basically want to ignore the grouping and just push the columns straight onto its row\n                    grouped[grouped.length - 1].push(item);\n                }\n                else if (grouped.length > 1 && lastRow === 1) {\n                    // We automatically assume this is a grouping match if there's more than one column but only one row\n                    grouped[grouped.length - 1][lastRow - 1] = item;\n                }\n                else if (!traceMatchFound) {\n                    // If a trace match was not found, increase the number of rows and place on a new row\n                    grouped[grouped.length - 1][lastRow] = item;\n                    lastRow++;\n                }\n                else {\n                    // A trace match has been found, so let's add to the correct row\n                    grouped[grouped.length - 1][rowToAddTo] = item;\n                    if (rowToAddTo > lastRow)\n                        lastRow = rowToAddTo;\n                }\n            }\n        }\n        for (var sg in grouped) {\n            for (var it in grouped[sg]) {\n                if (!groups[it]) {\n                    groups[it] = [];\n                }\n                groups[it][sg] = grouped[sg][it].data;\n            }\n        }\n        // Clean up empty items\n        for (var r = 0; r < groups.length; r++) {\n            for (var c = 0; c < groups[r].length; c++) {\n                if (!groups[r][c]) {\n                    groups[r][c] = '';\n                }\n            }\n        }\n        return groups;\n    };\n    ScrapeHelper.prototype.mapTraces = function (doc, selectors, resultTypes) {\n        if (resultTypes === void 0) { resultTypes = \"textContent\"; }\n        var gDepthMod = 0;\n        var tides = [];\n        var all_res = [];\n        // if we only have one result type provided then we should use that for all selectors\n        if (typeof resultTypes === 'string') {\n            var resultType = resultTypes.valueOf();\n            resultTypes = [];\n            for (var _i = 0, selectors_1 = selectors; _i < selectors_1.length; _i++) {\n                var s = selectors_1[_i];\n                resultTypes.push(resultType);\n            }\n        }\n        for (var s = 0; s < selectors.length; s++) {\n            var selector = selectors[s];\n            var resultType = resultTypes[s];\n            if (selector && selector.length > 0) {\n                try {\n                    if (selector === 'head' || !selector) {\n                        throw ('');\n                    }\n                    var els = Array.from(doc.body.querySelectorAll(selector));\n                    if (!els || els.length === 0) {\n                        // A missing element returns \"NO MATCHING ELEMENT\"; this is used later in comparing results from different iframes to choose the best outcome\n                        throw ('NO MATCHING ELEMENT');\n                    }\n                    if (els.length === 1) {\n                        gDepthMod -= 1;\n                    }\n                    var results = [];\n                    for (var _a = 0, els_1 = els; _a < els_1.length; _a++) {\n                        var el = els_1[_a];\n                        var e = els.indexOf(el);\n                        var data = this.getDataV0210(el, resultType);\n                        if (!data) {\n                            data = \"No data, change column type or re-select\";\n                        }\n                        var tag = 'axiom' + s + '-' + e;\n                        var trace = this.getRootTree(el);\n                        el.className = el.className.replace(\"axiom-matched\", '');\n                        results.push({ trace: trace, data: data, selector: selector, tag: tag, el: el });\n                    }\n                    var minTide = results[0].trace.length;\n                    var maxTide = 0;\n                    for (var r = 0; r < results.length; r++) {\n                        var trace = results[r].trace;\n                        var prev = results[results.length - 1].trace;\n                        if (r > 0) {\n                            prev = results[r - 1].trace;\n                        }\n                        var tide = 0;\n                        var done = false;\n                        while (!done && tide < trace.length) {\n                            var t_depth = trace[tide];\n                            var p_depth = prev[tide];\n                            if (t_depth !== p_depth) {\n                                done = true;\n                            }\n                            tide++;\n                        }\n                        if (tide < minTide) {\n                            minTide = tide;\n                        }\n                        if (tide > maxTide) {\n                            maxTide = tide;\n                        }\n                        results[r].trace.push(tide);\n                    }\n                    tides.push({ minTide: minTide, maxTide: maxTide });\n                    all_res.push(results);\n                }\n                catch (e) {\n                    tides.push({ minTide: 999, maxTide: 999 });\n                    all_res.push([{ trace: null, data: e, selector: selector, tag: null, el: null }]);\n                }\n            }\n        }\n        if (tides.length && all_res.length) {\n            tides.sort(function (a, b) {\n                return a.maxTide - b.maxTide;\n            });\n            var gDepth = tides[0].maxTide;\n            gDepth += gDepthMod;\n            this.generateGroupSelector(all_res, gDepth);\n            var grouped = this.attemptGroups(all_res, gDepth);\n            return grouped;\n        }\n        else {\n            return { 0: [] };\n        }\n    };\n    ScrapeHelper.prototype.generateGroupSelector = function (all_res, gDepth) {\n        this.groupSelector = \"\";\n        if (!all_res || !all_res[0] || !all_res[0][0] || !all_res[0][0].trace) {\n            return;\n        }\n        for (var i = 0; i < gDepth; i++) {\n            if (i > 0) {\n                this.groupSelector += \" > \";\n            }\n            this.groupSelector += \":-webkit-any(*):nth-child(\" + parseInt(all_res[0][0].trace[i] + 1) + \")\";\n        }\n    };\n    return ScrapeHelper;\n}());\nexports.ScrapeHelper = ScrapeHelper;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDA1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3JlY29yZGVyL3Rvb2wvU2NyYXBlSGVscGVyLnRzPzU1MmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgU2NyYXBlSGVscGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNjcmFwZUhlbHBlcigpIHtcbiAgICAgICAgLy8gVGhpcyBnZW5lcmF0ZXMgYW5kIHN0b3JlcyB0aGUgZ3JvdXBpbmcgc2VsZWN0b3Igd2hlbiBhIHByZXZpZXcgaXMgYmVpbmcgYnVpbHQuIFVzZWQgbGF0ZXIgdG8gdmlzdWFsbHkgaGlnaGxpZ2h0IHRoZSBncm91cGluZy5cbiAgICAgICAgdGhpcy5ncm91cFNlbGVjdG9yID0gXCJcIjtcbiAgICB9XG4gICAgU2NyYXBlSGVscGVyLnByb3RvdHlwZS5nZXRQcmV2aWV3ID0gZnVuY3Rpb24gKGRvYywgc2VsZWN0b3JzLCByZXN1bHRUeXBlcykge1xuICAgICAgICBpZiAoc2VsZWN0b3JzICYmIHNlbGVjdG9ycy5sZW5ndGggPiAwICYmIHNlbGVjdG9yc1swXSAhPT0gXCJObyB2YWxpZCBwYXRoIGZvdW5kLlwiICYmIC9bXlxcW1xcXVwiJ10vZy50ZXN0KEpTT04uc3RyaW5naWZ5KHNlbGVjdG9ycykpKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2VzID0gdGhpcy5tYXBUcmFjZXMoZG9jLCBzZWxlY3RvcnMsIHJlc3VsdFR5cGVzKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYWNlcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhY2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtbXV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNjcmFwZUhlbHBlci5wcm90b3R5cGUuZ2V0RGF0YVYwMjEwID0gZnVuY3Rpb24gKGVsLCByZXN1bHRUeXBlKSB7XG4gICAgICAgIHZhciBkYXRhID0gJyc7XG4gICAgICAgIHN3aXRjaCAocmVzdWx0VHlwZSkgeyAvL1RPRE86IHJldmlldyBhbGwgcmVzdWx0IHR5cGVzXG4gICAgICAgICAgICBjYXNlICdvdXRlckhUTUwnOlxuICAgICAgICAgICAgICAgIGRhdGEgPSBlbC5vdXRlckhUTUw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbm5lckhUTUwnOlxuICAgICAgICAgICAgICAgIGRhdGEgPSBlbC5pbm5lckhUTUw7XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBlbC5vdXRlckhUTUw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndGV4dENvbnRlbnQnOlxuICAgICAgICAgICAgICAgIGRhdGEgPSAnJztcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IGVsWydpbm5lclRleHQnXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh0ZXh0ICE9PSAndGV4dCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSBTdHJpbmcodGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSB0ZXh0LnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWwyID0gZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZWwyLnZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RvcCBleGVjdXRpb24gZnJvbSBmaW5pc2hpbmcgaGVyZSBpZiB0aGVyZSdzIGFuIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsaW5rJzogLy9UT0RPOiBleHBhbmQgdG8gbWF0Y2ggY3VzdG9tIGxpbmsgcmVzdWx0IHR5cGUgaW4gc2NyYXBlclxuICAgICAgICAgICAgY2FzZSAnaHJlZic6XG4gICAgICAgICAgICAgICAgdmFyIGxpbmtFbCA9IGVsO1xuICAgICAgICAgICAgICAgIGlmICghZWwuaGFzQXR0cmlidXRlKCdocmVmJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gZWwucXVlcnlTZWxlY3RvckFsbCgnW2hyZWZdJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtFbCA9IGNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBocmVmID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAobGlua0VsLmhhc0F0dHJpYnV0ZSgnaHJlZicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhyZWYgPSBsaW5rRWxbJ2hyZWYnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YSA9IChocmVmICE9PSBudWxsKSA/IGhyZWYgOiAnJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgICAgICAgICAgICB2YXIgaW1nRWwgPSBlbDtcbiAgICAgICAgICAgICAgICBpZiAoIWVsLmhhc0F0dHJpYnV0ZSgnc3JjJykgJiYgIWVsLmhhc0F0dHJpYnV0ZSgnc3Jjc2V0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gQXJyYXkuZnJvbShlbC5xdWVyeVNlbGVjdG9yQWxsKCdbc3JjXScpKS5jb25jYXQoQXJyYXkuZnJvbShlbC5xdWVyeVNlbGVjdG9yQWxsKCdbc3Jjc2V0XScpKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFjY29yZGluZyB0byBCYXJsb3csIHRoZSBsYXN0IGl0ZW0gaXMgXCJhbG1vc3QgYWx3YXlzXCIgY29ycmVjdCwgYnV0IHRoaXMgaXNuJ3QgcmVhbGx5IHBvc3NpYmxlIHRvIGRldGVybWluZSB3aXRob3V0IHNvbWUgZXh0cmEgVUlcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZ0VsID0gY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHNyYyA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGltZ0VsLmhhc0F0dHJpYnV0ZSgnc3JjJykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gaW1nRWxbJ3NyYyddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpbWdFbC5oYXNBdHRyaWJ1dGUoJ3NyY3NldCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IGltZ0VsWydzcmNzZXQnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YSA9IChzcmMgIT09IG51bGwpID8gc3JjIDogJyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcbiAgICBTY3JhcGVIZWxwZXIucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoZWwsIHJlc3VsdFR5cGUpIHtcbiAgICAgICAgdmFyIHNjcmFwZUxpbmsgPSAocmVzdWx0VHlwZSA9PT0gXCJsaW5rXCIgfHwgcmVzdWx0VHlwZSA9PT0gJ2hyZWYnKTtcbiAgICAgICAgcmVzdWx0VHlwZSA9IChzY3JhcGVMaW5rKSA/IFwib3V0ZXJIVE1MXCIgOiByZXN1bHRUeXBlO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZWxbcmVzdWx0VHlwZV07XG4gICAgICAgIGlmIChzY3JhcGVMaW5rKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDE7XG4gICAgICAgICAgICB2YXIgcmVzID0gJyc7XG4gICAgICAgICAgICB3aGlsZSAocmVzID09IFwiXCIgJiYgaSA8PSA1KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZWxbcmVzdWx0VHlwZV07XG4gICAgICAgICAgICAgICAgdmFyIGhyZWYgPSBlbFsnaHJlZiddO1xuICAgICAgICAgICAgICAgIHZhciBsaW5rID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmIChocmVmICYmIGhyZWYubWF0Y2goLygoW0EtWmEtel0rWzpdWy9dWy9dKXwoWy9dW15cIicgXSkpLlteXCInIF0rW15cIicgXSsoW15cIicgXSkvKSkge1xuICAgICAgICAgICAgICAgICAgICBsaW5rID0gaHJlZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRNYXRjaGVkID0gcmVzdWx0Lm1hdGNoKC9ocmVmPVtcIiddKChbQS1aYS16XStbOl1bL11bL10pfChbL11bXlwiJyBdKSkuW15cIicgXStbXlwiJyBdKyhbXlwiJyBdKS8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0TWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluayA9IHJlc3VsdE1hdGNoZWRbMF0uc3Vic3RyaW5nKDYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmtNYXRjaGVkID0gcmVzdWx0Lm1hdGNoKC9bXCInXSgoW0EtWmEtel0rWzpdWy9dWy9dKXwoWy9dW15cIicgXSkpLlteXCInIF0rWy9dK1teXCInIF0rKFteXCInIF0pLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGlua01hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rID0gbGlua01hdGNoZWRbMF0uc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlua1swXSA9PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5rWzFdID09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsgPSB1cmwubWF0Y2goLy5bXi9dK1svXVsvXS8pWzBdICsgbGluay5zdWJzdHJpbmcoMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rID0gdXJsLm1hdGNoKC9bQS1aYS16XStbOl1bL10uW14vXStbL10vKVswXSArIGxpbmsuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IChsaW5rKSA/IGxpbmsgOiBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBkaWRuJ3QgZ2V0IGEgbGluayB0aGVuIGluc3RlYWQgbG9vayBhdCB0aGUgcGFyZW50IG9mIHRoZSBjdXJyZW50IGVsZW1lbnQgYW5kIHRyeSB0byBnZXQgYSBsaW5rIGZyb20gdGhhdCBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgaWYgKHJlcyA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuaW5uZXJIVE1MKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbCA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSByZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFNjcmFwZUhlbHBlci5wcm90b3R5cGUuY291bnRTaWJsaW5nc0xlZnQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIHNpYmxpbmdzID0gW107XG4gICAgICAgIHZhciBuID0gZWw7XG4gICAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICAgIHdoaWxlICghZG9uZSkge1xuICAgICAgICAgICAgdmFyIHNpYmxpbmcgPSBuLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAoc2libGluZykge1xuICAgICAgICAgICAgICAgIHNpYmxpbmdzLnB1c2goc2libGluZyk7XG4gICAgICAgICAgICAgICAgbiA9IHNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2libGluZ3MubGVuZ3RoO1xuICAgIH07XG4gICAgU2NyYXBlSGVscGVyLnByb3RvdHlwZS5nZXRSb290VHJlZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgcm9vdFRyZWUgPSBbXTtcbiAgICAgICAgdmFyIG5vZGUgPSBlbDtcbiAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgICB2YXIgbnRoQ291bnQgPSB0aGlzLmNvdW50U2libGluZ3NMZWZ0KG5vZGUpO1xuICAgICAgICAgICAgcm9vdFRyZWUudW5zaGlmdChudGhDb3VudCk7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9vdFRyZWU7XG4gICAgfTtcbiAgICBTY3JhcGVIZWxwZXIucHJvdG90eXBlLnRyYWNlc0VxdWFsID0gZnVuY3Rpb24gKGEsIGIsIGRlcHRoKSB7XG4gICAgICAgIGlmICghYSB8fCAhYikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwdGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBTY3JhcGVIZWxwZXIucHJvdG90eXBlLmF0dGVtcHRHcm91cHMgPSBmdW5jdGlvbiAoYWxsX3JlcywgZ0RlcHRoKSB7XG4gICAgICAgIHZhciBncm91cHMgPSBbXTtcbiAgICAgICAgdmFyIGdyb3VwZWQgPSBbXTtcbiAgICAgICAgdmFyIGxhc3RSb3cgPSAwO1xuICAgICAgICB2YXIgcm93VG9BZGRUbyA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgYWxsX3Jlc18xID0gYWxsX3JlczsgX2kgPCBhbGxfcmVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gYWxsX3Jlc18xW19pXTtcbiAgICAgICAgICAgIGdyb3VwZWQucHVzaChbXSk7XG4gICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIHJlc18xID0gcmVzOyBfYSA8IHJlc18xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gcmVzXzFbX2FdO1xuICAgICAgICAgICAgICAgIHZhciBjb2xzUHJvY2Vzc2VkID0gMDtcbiAgICAgICAgICAgICAgICAvLyBPSywgc28gd2UgbmVlZCB0byBjaGVjayB0aGlzIGl0ZW0ncyB0cmFjZSBhZ2FpbnN0IGl0ZW1zIG5vdCBpbiB0aGlzIGNvbHVtbiB0byBmaW5kIGEgbWF0Y2hpbmcgdHJhY2UuXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZmluZCB0aGUgbWF0Y2hpbmcgcm93LCBpbnNlcnQgb3VyIGl0ZW0gdGhlcmUgYW5kIHN0b3AuIElmIHdlIGZhbGwgb2ZmIHRoZSBlbmQsIHB1c2ggdGhlIG5ldyByb3cgaW5zdGVhZC5cbiAgICAgICAgICAgICAgICB2YXIgdHJhY2VNYXRjaEZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZyA9IDA7IGcgPCBncm91cGVkLmxlbmd0aCAtIDE7IGcrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sUHJvY2Vzc2VkID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cGVkW2ddLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXBlZFtnXVtpXSAmJiBpdGVtLnRyYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sUHJvY2Vzc2VkID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjZU1hdGNoRm91bmQgPSB0aGlzLnRyYWNlc0VxdWFsKGdyb3VwZWRbZ11baV0udHJhY2UsIGl0ZW0udHJhY2UsIGdEZXB0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNlTWF0Y2hGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dUb0FkZFRvID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbHNQcm9jZXNzZWQgKz0gY29sUHJvY2Vzc2VkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2VNYXRjaEZvdW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb2xzUHJvY2Vzc2VkID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG9ubHkgb25lIGNvbHVtbiBoYXMgYmVlbiBwcm9jZXNzZWQsIHdlIGJhc2ljYWxseSB3YW50IHRvIGlnbm9yZSB0aGUgZ3JvdXBpbmcgYW5kIGp1c3QgcHVzaCB0aGUgY29sdW1ucyBzdHJhaWdodCBvbnRvIGl0cyByb3dcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBlZFtncm91cGVkLmxlbmd0aCAtIDFdLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGdyb3VwZWQubGVuZ3RoID4gMSAmJiBsYXN0Um93ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGF1dG9tYXRpY2FsbHkgYXNzdW1lIHRoaXMgaXMgYSBncm91cGluZyBtYXRjaCBpZiB0aGVyZSdzIG1vcmUgdGhhbiBvbmUgY29sdW1uIGJ1dCBvbmx5IG9uZSByb3dcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBlZFtncm91cGVkLmxlbmd0aCAtIDFdW2xhc3RSb3cgLSAxXSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0cmFjZU1hdGNoRm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSB0cmFjZSBtYXRjaCB3YXMgbm90IGZvdW5kLCBpbmNyZWFzZSB0aGUgbnVtYmVyIG9mIHJvd3MgYW5kIHBsYWNlIG9uIGEgbmV3IHJvd1xuICAgICAgICAgICAgICAgICAgICBncm91cGVkW2dyb3VwZWQubGVuZ3RoIC0gMV1bbGFzdFJvd10gPSBpdGVtO1xuICAgICAgICAgICAgICAgICAgICBsYXN0Um93Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIHRyYWNlIG1hdGNoIGhhcyBiZWVuIGZvdW5kLCBzbyBsZXQncyBhZGQgdG8gdGhlIGNvcnJlY3Qgcm93XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwZWRbZ3JvdXBlZC5sZW5ndGggLSAxXVtyb3dUb0FkZFRvXSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3dUb0FkZFRvID4gbGFzdFJvdylcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RSb3cgPSByb3dUb0FkZFRvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBzZyBpbiBncm91cGVkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpdCBpbiBncm91cGVkW3NnXSkge1xuICAgICAgICAgICAgICAgIGlmICghZ3JvdXBzW2l0XSkge1xuICAgICAgICAgICAgICAgICAgICBncm91cHNbaXRdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdyb3Vwc1tpdF1bc2ddID0gZ3JvdXBlZFtzZ11baXRdLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYW4gdXAgZW1wdHkgaXRlbXNcbiAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBncm91cHMubGVuZ3RoOyByKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgZ3JvdXBzW3JdLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFncm91cHNbcl1bY10pIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBzW3JdW2NdID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncm91cHM7XG4gICAgfTtcbiAgICBTY3JhcGVIZWxwZXIucHJvdG90eXBlLm1hcFRyYWNlcyA9IGZ1bmN0aW9uIChkb2MsIHNlbGVjdG9ycywgcmVzdWx0VHlwZXMpIHtcbiAgICAgICAgaWYgKHJlc3VsdFR5cGVzID09PSB2b2lkIDApIHsgcmVzdWx0VHlwZXMgPSBcInRleHRDb250ZW50XCI7IH1cbiAgICAgICAgdmFyIGdEZXB0aE1vZCA9IDA7XG4gICAgICAgIHZhciB0aWRlcyA9IFtdO1xuICAgICAgICB2YXIgYWxsX3JlcyA9IFtdO1xuICAgICAgICAvLyBpZiB3ZSBvbmx5IGhhdmUgb25lIHJlc3VsdCB0eXBlIHByb3ZpZGVkIHRoZW4gd2Ugc2hvdWxkIHVzZSB0aGF0IGZvciBhbGwgc2VsZWN0b3JzXG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0VHlwZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0VHlwZSA9IHJlc3VsdFR5cGVzLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIHJlc3VsdFR5cGVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNlbGVjdG9yc18xID0gc2VsZWN0b3JzOyBfaSA8IHNlbGVjdG9yc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBzID0gc2VsZWN0b3JzXzFbX2ldO1xuICAgICAgICAgICAgICAgIHJlc3VsdFR5cGVzLnB1c2gocmVzdWx0VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBzZWxlY3RvcnMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IHNlbGVjdG9yc1tzXTtcbiAgICAgICAgICAgIHZhciByZXN1bHRUeXBlID0gcmVzdWx0VHlwZXNbc107XG4gICAgICAgICAgICBpZiAoc2VsZWN0b3IgJiYgc2VsZWN0b3IubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvciA9PT0gJ2hlYWQnIHx8ICFzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxzID0gQXJyYXkuZnJvbShkb2MuYm9keS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZWxzIHx8IGVscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgbWlzc2luZyBlbGVtZW50IHJldHVybnMgXCJOTyBNQVRDSElORyBFTEVNRU5UXCI7IHRoaXMgaXMgdXNlZCBsYXRlciBpbiBjb21wYXJpbmcgcmVzdWx0cyBmcm9tIGRpZmZlcmVudCBpZnJhbWVzIHRvIGNob29zZSB0aGUgYmVzdCBvdXRjb21lXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAoJ05PIE1BVENISU5HIEVMRU1FTlQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ0RlcHRoTW9kIC09IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBlbHNfMSA9IGVsczsgX2EgPCBlbHNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IGVsc18xW19hXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gZWxzLmluZGV4T2YoZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldERhdGFWMDIxMChlbCwgcmVzdWx0VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gXCJObyBkYXRhLCBjaGFuZ2UgY29sdW1uIHR5cGUgb3IgcmUtc2VsZWN0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gJ2F4aW9tJyArIHMgKyAnLScgKyBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNlID0gdGhpcy5nZXRSb290VHJlZShlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5jbGFzc05hbWUgPSBlbC5jbGFzc05hbWUucmVwbGFjZShcImF4aW9tLW1hdGNoZWRcIiwgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHsgdHJhY2U6IHRyYWNlLCBkYXRhOiBkYXRhLCBzZWxlY3Rvcjogc2VsZWN0b3IsIHRhZzogdGFnLCBlbDogZWwgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pblRpZGUgPSByZXN1bHRzWzBdLnRyYWNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heFRpZGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHJlc3VsdHMubGVuZ3RoOyByKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmFjZSA9IHJlc3VsdHNbcl0udHJhY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldiA9IHJlc3VsdHNbcmVzdWx0cy5sZW5ndGggLSAxXS50cmFjZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSByZXN1bHRzW3IgLSAxXS50cmFjZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aWRlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIWRvbmUgJiYgdGlkZSA8IHRyYWNlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0X2RlcHRoID0gdHJhY2VbdGlkZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBfZGVwdGggPSBwcmV2W3RpZGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0X2RlcHRoICE9PSBwX2RlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWRlKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGlkZSA8IG1pblRpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5UaWRlID0gdGlkZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aWRlID4gbWF4VGlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFRpZGUgPSB0aWRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tyXS50cmFjZS5wdXNoKHRpZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRpZGVzLnB1c2goeyBtaW5UaWRlOiBtaW5UaWRlLCBtYXhUaWRlOiBtYXhUaWRlIH0pO1xuICAgICAgICAgICAgICAgICAgICBhbGxfcmVzLnB1c2gocmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpZGVzLnB1c2goeyBtaW5UaWRlOiA5OTksIG1heFRpZGU6IDk5OSB9KTtcbiAgICAgICAgICAgICAgICAgICAgYWxsX3Jlcy5wdXNoKFt7IHRyYWNlOiBudWxsLCBkYXRhOiBlLCBzZWxlY3Rvcjogc2VsZWN0b3IsIHRhZzogbnVsbCwgZWw6IG51bGwgfV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGlkZXMubGVuZ3RoICYmIGFsbF9yZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aWRlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEubWF4VGlkZSAtIGIubWF4VGlkZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGdEZXB0aCA9IHRpZGVzWzBdLm1heFRpZGU7XG4gICAgICAgICAgICBnRGVwdGggKz0gZ0RlcHRoTW9kO1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUdyb3VwU2VsZWN0b3IoYWxsX3JlcywgZ0RlcHRoKTtcbiAgICAgICAgICAgIHZhciBncm91cGVkID0gdGhpcy5hdHRlbXB0R3JvdXBzKGFsbF9yZXMsIGdEZXB0aCk7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXBlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IDA6IFtdIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNjcmFwZUhlbHBlci5wcm90b3R5cGUuZ2VuZXJhdGVHcm91cFNlbGVjdG9yID0gZnVuY3Rpb24gKGFsbF9yZXMsIGdEZXB0aCkge1xuICAgICAgICB0aGlzLmdyb3VwU2VsZWN0b3IgPSBcIlwiO1xuICAgICAgICBpZiAoIWFsbF9yZXMgfHwgIWFsbF9yZXNbMF0gfHwgIWFsbF9yZXNbMF1bMF0gfHwgIWFsbF9yZXNbMF1bMF0udHJhY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdEZXB0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwU2VsZWN0b3IgKz0gXCIgPiBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBTZWxlY3RvciArPSBcIjotd2Via2l0LWFueSgqKTpudGgtY2hpbGQoXCIgKyBwYXJzZUludChhbGxfcmVzWzBdWzBdLnRyYWNlW2ldICsgMSkgKyBcIilcIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNjcmFwZUhlbHBlcjtcbn0oKSk7XG5leHBvcnRzLlNjcmFwZUhlbHBlciA9IFNjcmFwZUhlbHBlcjtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///405\n")},808:function(module,exports,__webpack_require__){"use strict";eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AttributeSelector_1 = __webpack_require__(404);\nvar HierachyActions_1 = __webpack_require__(809);\nvar SelectorFacade_1 = __webpack_require__(810);\nvar BorderHighlight_1 = __webpack_require__(818);\nvar ScrapeHelper_1 = __webpack_require__(405);\nvar AxiomApiHelper_1 = __webpack_require__(13);\n/**\n * SelectionActions\n */\nvar SelectionActions = /** @class */ (function () {\n    function SelectionActions(context) {\n        this.selectorData = context;\n    }\n    SelectionActions.prototype.add_column = function (request) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                this.selectorData.addSelector();\n                this.selectorData.editSelector(this.selectorData.selectors.length - 1);\n                return [2 /*return*/];\n            });\n        });\n    };\n    SelectionActions.prototype.remove_column = function (request) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                this.selectorData.removeSelector(request.index);\n                return [2 /*return*/];\n            });\n        });\n    };\n    SelectionActions.prototype.select_column = function (request) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                this.selectorData.editSelector(request.index);\n                return [2 /*return*/];\n            });\n        });\n    };\n    SelectionActions.prototype.set_result_type = function (request) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                this.selectorData.setResultType(request.sel_index, request.resultType);\n                return [2 /*return*/];\n            });\n        });\n    };\n    SelectionActions.prototype.reset_column = function (request) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                this.selectorData.resetSelector(request.index);\n                this.selectorData.editSelector(request.index);\n                return [2 /*return*/];\n            });\n        });\n    };\n    SelectionActions.prototype.addElementToSelection = function (request) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/];\n            });\n        });\n    };\n    SelectionActions.prototype.removeElementFromSelection = function (request) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/];\n            });\n        });\n    };\n    SelectionActions.prototype.edit_selector = function (request) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                this.selectorData.updateSelector(request.index, request.selector, request.target);\n                return [2 /*return*/];\n            });\n        });\n    };\n    return SelectionActions;\n}());\n/**\n * SelectorData\n */\nvar SelectorData = /** @class */ (function () {\n    function SelectorData() {\n        this.refreshRequired = false;\n        this.selectors = null;\n        this.activeSelectorIndex = 0;\n        this.actions = new SelectionActions(this);\n    }\n    /**\n     * Executes the requested action and then automatically handles any recalculations and issuing of updates\n     *\n     * @param request {action, ...params}\n     */\n    SelectorData.prototype.actionRequest = function (request) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.actions[request.action](request)];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    SelectorData.prototype.addSelector = function () {\n        this.selectors.push({\n            selector: 'head',\n            selectedElements: [],\n            rejectedElements: [],\n            resultType: this.defaultResultType\n        });\n        this.refreshRequired = true;\n    };\n    SelectorData.prototype.removeSelector = function (index) {\n        this.selectors.splice(index, 1);\n        if (this.selectors.length === 0) {\n            this.addSelector();\n        }\n        else {\n            var removedLastColumn = (index === this.selectors.length);\n            var removedWhileSelected = (index === this.activeSelectorIndex);\n            var selectedColumnShiftedLeft = (index <= this.activeSelectorIndex);\n            if ((removedLastColumn && removedWhileSelected) || selectedColumnShiftedLeft) {\n                this.editSelector(this.activeSelectorIndex - 1);\n            }\n        }\n        if (this.activeSelectorIndex === -1 && this.selectors.length > 0) {\n            this.activeSelectorIndex = 0;\n        }\n        this.refreshRequired = true;\n    };\n    SelectorData.prototype.editSelector = function (index) {\n        if (index < this.selectors.length) { // check index exists\n            this.activeSelectorIndex = index;\n        }\n        else if (this.activeSelectorIndex >= this.selectors.length) {\n            // if current selection is not valid then set to last column\n            this.activeSelectorIndex = this.selectors.length - 1;\n        }\n        this.refreshRequired = true;\n    };\n    SelectorData.prototype.updateSelector = function (index, selector, target) {\n        if (!this.selectors[index]) {\n            // Only happens if it's a brand new scrape, so this should be safe\n            this.addSelector();\n        }\n        this.selectors[index] = selector[index];\n        var singleSelector = new SelectorFacade_1.SelectorFacade();\n        if (target === \"hierarchy\") {\n            var el = document.querySelector(selector[index].selector.hierarchy);\n            if (!el) {\n                this.selectors[index].selector.innerText = \"\",\n                    this.selectors[index].selector.targetElement = undefined;\n                return;\n            }\n            var newSelectors = singleSelector.getSelector(el);\n            this.selectors[index].selector.innerText = newSelectors.innerText,\n                this.selectors[index].selector.targetElement = newSelectors.targetElement;\n        }\n        else if (target === \"innerText\") {\n            var el = document.evaluate(\"//*[text()='\" + selector[index].selector.innerText + \"']\", document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;\n            if (!el) {\n                this.selectors[index].selector.hierarchy = \"\";\n                this.selectors[index].targetElement = undefined;\n                return;\n            }\n            var newSelectors = singleSelector.getSelector(el);\n            this.selectors[index].selector.hierarchy = newSelectors.hierarchy;\n            this.selectors[index].selector.targetElement = newSelectors.targetElement;\n        }\n        this.refreshRequired = true;\n    };\n    SelectorData.prototype.setResultType = function (index, resultType) {\n        if (!this.selectors[index]) {\n            this.addSelector();\n        }\n        this.selectors[index].resultType = resultType;\n        this.refreshRequired = true;\n    };\n    SelectorData.prototype.resetSelector = function (index) {\n        this.selectors[index] = {\n            selector: 'head',\n            selections: [],\n            selectedElements: [],\n            rejectedElements: [],\n            resultType: this.defaultResultType,\n            groupSelector: 'body'\n        };\n        this.refreshRequired = true;\n    };\n    return SelectorData;\n}());\n/**\n * @author Nasik aka Kisan <nasik.shafeek@abstraction.co>\n * @author Simon Delany <simon.delany@axiom.ai>\n *\n * Injected into content page and will be kicked into action when the tool is in use\n *\n */\nvar InjectedSelectorTool = /** @class */ (function () {\n    function InjectedSelectorTool() {\n        var _this = this;\n        this.iframeHighlightBorders = [];\n        this.lastSelectorId = 0;\n        this.activeSelector = [];\n        this.activeSelectorIndex = -1;\n        this.selectingClass = 'axiom-sel-selected-';\n        this.suggestingClass = 'axiom-sel-suggested-';\n        this.rejectingClass = 'axiom-sel-rejected-';\n        this.resultType = 'textContent';\n        this.resultTypes = ['textContent'];\n        this.iframeSupportEnabled = false;\n        this.SelectorAlgorithm = new AttributeSelector_1.AttributeSelector();\n        this.hierarchyActions = new HierachyActions_1.HierarchyActions();\n        this.matching = [];\n        this.matchingData = [];\n        this.highlightBorder = new BorderHighlight_1.BorderHighlight(document, false, false);\n        this.singleSelector = new SelectorFacade_1.SelectorFacade();\n        this.scrapeHelper = new ScrapeHelper_1.ScrapeHelper();\n        this.selectorData = new SelectorData();\n        chrome.runtime.onMessage.addListener(function (request, sender, sendResponse) { return __awaiter(_this, void 0, void 0, function () {\n            var _a, suggestions;\n            var _this = this;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = request.action;\n                        switch (_a) {\n                            case 'selector_tool_start': return [3 /*break*/, 1];\n                            case 'selector_tool_confirm': return [3 /*break*/, 2];\n                            case \"selector_tool_reset\": return [3 /*break*/, 3];\n                            case \"selector_tool_cancel\": return [3 /*break*/, 4];\n                            case \"set_result_type\": return [3 /*break*/, 5];\n                            case 'select_column': return [3 /*break*/, 5];\n                            case 'remove_column': return [3 /*break*/, 5];\n                            case 'add_column': return [3 /*break*/, 5];\n                            case 'reset_column': return [3 /*break*/, 5];\n                            case 'edit_selector': return [3 /*break*/, 5];\n                            case \"hide_bubble\": return [3 /*break*/, 7];\n                            case \"generate_suggestions\": return [3 /*break*/, 8];\n                            case \"set_iframe_support\": return [3 /*break*/, 9];\n                        }\n                        return [3 /*break*/, 10];\n                    case 1:\n                        this.scrapeHelper.groupSelector = \"\";\n                        this.selectionMode = (request.selectionType === 'smart' || request.selectionType === 'multi') ? 'multiple' : 'single';\n                        if (request.resultType) {\n                            if (Array.isArray(request.resultType)) {\n                                this.resultTypes = request.resultType;\n                                this.resultType = this.resultTypes[this.selectorData.activeSelectorIndex];\n                            }\n                            else {\n                                this.resultType = request.resultType;\n                                this.resultTypes = [request.resultType];\n                            }\n                        }\n                        else {\n                            this.resultType = 'outerHTML';\n                        }\n                        // We have to set a default resultType e.g. for widgets like scrapeLink to have the link result type as default\n                        this.selectorData.defaultResultType = this.resultType; // this sets a default result type for this selection. any time you add a column it will default this this resultType.\n                        this.highlightBorder.updateResultType(this.resultType);\n                        this.highlightBorder.updateWindex(request.windex);\n                        this.injectV0200();\n                        if (!request.selectors) {\n                            return [2 /*return*/];\n                        }\n                        if (this.selectionMode === \"multiple\") {\n                            this.selectorData.selectors = request.selectors;\n                            this.selectionMode = 'multiple';\n                            this.updateSelections(this.selectorData.selectors[this.selectorData.activeSelectorIndex].resultType, this.selectorData.activeSelectorIndex, document);\n                            AxiomApiHelper_1.AxiomApiHelper.applyToIframes(function (index, content) {\n                                _this.updateSelections(_this.selectorData.selectors[_this.selectorData.activeSelectorIndex].resultType, _this.selectorData.activeSelectorIndex, content[0]);\n                            });\n                            this.sendStateUpdate();\n                        }\n                        else if (this.selectionMode === 'single') {\n                            this.selectorData.selectors = request.selectors;\n                            this.resetHighlights(document);\n                            AxiomApiHelper_1.AxiomApiHelper.applyToIframes(function (index, content) {\n                                _this.resetHighlights(content[0]);\n                            });\n                        }\n                        return [3 /*break*/, 10];\n                    case 2:\n                        this.closingAction(request.widget_type);\n                        sendResponse(this.selectorData.selectors);\n                        this.ejectV0200();\n                        return [3 /*break*/, 10];\n                    case 3:\n                        this.ejectV0200();\n                        this.selectionMode = (request.selectionType === 'smart' || request.selectionType === 'multi') ? 'multiple' : 'single';\n                        this.injectV0200();\n                        return [3 /*break*/, 10];\n                    case 4:\n                        this.ejectV0200();\n                        return [3 /*break*/, 10];\n                    case 5:\n                        this.removeAllHighlights(document);\n                        AxiomApiHelper_1.AxiomApiHelper.applyToIframes(function (index, doc) {\n                            _this.removeAllHighlights(doc);\n                        });\n                        return [4 /*yield*/, this.selectorData.actionRequest(request)];\n                    case 6:\n                        _b.sent();\n                        if (this.selectionMode === 'multiple') {\n                            if (this.selectorData.refreshRequired && this.selectorData.selectors[this.selectorData.activeSelectorIndex]) {\n                                this.updateSelections(this.selectorData.selectors[this.selectorData.activeSelectorIndex].resultType, this.selectorData.activeSelectorIndex, document);\n                                AxiomApiHelper_1.AxiomApiHelper.applyToIframes(function (index, content) {\n                                    _this.updateSelections(_this.selectorData.selectors[_this.selectorData.activeSelectorIndex].resultType, _this.selectorData.activeSelectorIndex, content[0]);\n                                });\n                                this.sendStateUpdate();\n                            }\n                        }\n                        else if (this.selectionMode === 'single') {\n                            this.resetHighlights(document);\n                            AxiomApiHelper_1.AxiomApiHelper.applyToIframes(function (index, content) {\n                                _this.resetHighlights(content[0]);\n                            });\n                            this.sendStateUpdate();\n                        }\n                        return [3 /*break*/, 10];\n                    case 7:\n                        chrome.runtime.sendMessage({ action: 'cancel_preview' });\n                        this.ejectV0200();\n                        return [3 /*break*/, 10];\n                    case 8:\n                        suggestions = this.generateSuggestions(request.selector);\n                        sendResponse({ suggestions: suggestions });\n                        return [3 /*break*/, 10];\n                    case 9:\n                        this.iframeSupportEnabled = request.value;\n                        this.iframeHighlightBorders.forEach(function (item) {\n                            item.setIframeSupportEnabled(request.value);\n                        });\n                        return [3 /*break*/, 10];\n                    case 10: return [2 /*return*/];\n                }\n            });\n        }); });\n    }\n    InjectedSelectorTool.prototype.generateSuggestions = function (selector) {\n        if (!selector || selector === \"head\") {\n            return [];\n        }\n        var results;\n        try {\n            results = document.querySelectorAll(selector);\n        }\n        catch (e) {\n            return [];\n        }\n        var sharedAttributes = [];\n        var combinedSelector = this.hierarchyActions.getCombined(document, Array.from(results), [], 'selector');\n        sharedAttributes.push(combinedSelector);\n        for (var i in results) {\n            var el = results[i];\n            if (sharedAttributes.length === 1) {\n                if (el.attributes) {\n                    for (var _i = 0, _a = el.attributes; _i < _a.length; _i++) {\n                        var attr = _a[_i];\n                        if (attr.name !== \"class\" && attr.value) {\n                            var as = this.createAttributeSelector(attr);\n                            if (this.testGeneratedSelector(as, results.length)) {\n                                sharedAttributes.push(as);\n                            }\n                        }\n                    }\n                }\n                if (el.classList) {\n                    for (var _b = 0, _c = el.classList; _b < _c.length; _b++) {\n                        var c = _c[_b];\n                        if (c.indexOf('axiom') === -1) {\n                            if (this.testGeneratedSelector(\".\" + c, results.length)) {\n                                sharedAttributes.push(\".\" + c);\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                // This segment basically removes things in the case that the first result happened to have a length match, but it actually doesn't\n                // include one of the originally selected results (instead it includes something else).\n                if (el.attributes) {\n                    for (var _d = 0, _e = el.attributes; _d < _e.length; _d++) {\n                        var attr = _e[_d];\n                        var as = this.createAttributeSelector(attr);\n                        var found = \"\";\n                        for (var sai in sharedAttributes) {\n                            if (sharedAttributes[sai] === as) {\n                                found = sai;\n                                break;\n                            }\n                        }\n                        if (!found) {\n                            sharedAttributes[found] = null;\n                        }\n                    }\n                }\n                if (el.classList) {\n                    for (var _f = 0, _g = el.classList; _f < _g.length; _f++) {\n                        var c = _g[_f];\n                        var found = \"\";\n                        for (var _h = 0, sharedAttributes_1 = sharedAttributes; _h < sharedAttributes_1.length; _h++) {\n                            var sai = sharedAttributes_1[_h];\n                            if (sharedAttributes[sai] === \".\" + c) {\n                                found = sai;\n                            }\n                        }\n                        if (!found) {\n                            sharedAttributes[found] = null;\n                        }\n                    }\n                }\n            }\n        }\n        sharedAttributes = sharedAttributes.filter(function (el) {\n            return el != null;\n        });\n        return sharedAttributes;\n    };\n    InjectedSelectorTool.prototype.createAttributeSelector = function (attr) {\n        return '[' + attr.name + \"='\" + attr.value + \"']\";\n    };\n    InjectedSelectorTool.prototype.testGeneratedSelector = function (selector, targetLength) {\n        if (!selector) {\n            return false;\n        }\n        var r = document.querySelectorAll(selector);\n        return r.length === targetLength;\n    };\n    /**\n     * Start Using the tool\n     */\n    InjectedSelectorTool.prototype.injectV0200 = function () {\n        var _this = this;\n        this.inuse = true;\n        this.selectorData.selectors = [];\n        this.selectorData.activeSelectorIndex = 0;\n        this.highlightBorder.updateactiveSelectorIndex(0);\n        this.highlightBorder.inject();\n        if (this.selectionMode === 'single') {\n            jQuery(document).on('mousedown.axiom-selection', function (e) {\n                _this.singleElementClickHandler(e);\n            });\n            AxiomApiHelper_1.AxiomApiHelper.applyToIframes(function (index, content) {\n                jQuery(content[0]).on('mousedown.axiom-selection', function (e) {\n                    _this.singleElementClickHandler(e);\n                });\n            });\n        }\n        else {\n            // Adding require things to the parent window\n            jQuery(document).on('mousedown.axiom-selection', function (e) {\n                _this.elementClickHandler(e);\n            });\n            AxiomApiHelper_1.AxiomApiHelper.applyToIframes(function (index, content) {\n                jQuery(content[0]).on('mousedown.axiom-selection', _this.elementClickHandler.bind(_this));\n            });\n        }\n        if (this.resultType === 'link') {\n            jQuery('a').addClass('axiom-link');\n        }\n        else if (this.resultType === 'axiom-download') {\n            jQuery('a').addClass('axiom-download');\n        }\n        /**\n         * Linking the css file for highlighting and stuff\n         */\n        jQuery('body').addClass('axiom-sel-in-action');\n        // Adding the required things to each same origin iframe\n        AxiomApiHelper_1.AxiomApiHelper.applyToIframes(function (index, content) {\n            if (content.length) {\n                _this.iframeHighlightBorders[index] = new BorderHighlight_1.BorderHighlight(content[0], true, _this.iframeSupportEnabled);\n                _this.iframeHighlightBorders[index].inject();\n                var body = content.find('body');\n                var stylesheet = chrome.runtime.getURL(\"axiomselector.css\");\n                body.append('<link rel=\"stylesheet\" type=\"text/css\" href=\"' + stylesheet + '\">');\n                body.addClass('axiom-sel-in-action');\n                if (_this.resultType === 'link') {\n                    content.find('a').addClass('axiom-link');\n                }\n                else if (_this.resultType === 'axiom-download') {\n                    content.find('a').addClass('axiom-download');\n                }\n            }\n        });\n    };\n    /**\n     * Inject into specific classes where traditional injection doesn't work\n     *\n     * @param mode string | 'single', 'multiple'\n     */\n    InjectedSelectorTool.prototype.injectIntoSpecificClasses = function (mode) {\n        var algos = {\n            'single': this.singleElementClickHandler.bind(this),\n            'multiple': this.elementClickHandler.bind(this)\n        };\n        jQuery('.c9-menu-btn').on('mousedown.axiom-selection', algos[mode]);\n    };\n    InjectedSelectorTool.prototype.ejectFromSpecificClasses = function () {\n        jQuery('.c9-menu-btn').off('mousedown.axiom-selector');\n    };\n    InjectedSelectorTool.prototype.updateSelections = function (activeResultType, activeSelectorIndex, doc) {\n        this.highlightBorder.updateResultType(activeResultType);\n        this.highlightBorder.updateactiveSelectorIndex(activeSelectorIndex);\n        this.updateActiveResultType();\n        this.findMatchesV0190(doc); // TODO: split into the following\n        this.setHighlights(doc);\n    };\n    InjectedSelectorTool.prototype.updateActiveResultType = function () {\n        this.resultType = this.selectorData.selectors[this.selectorData.activeSelectorIndex].resultType;\n        // remove old result type dependant classes\n        jQuery('a').removeClass('axiom-link');\n        jQuery('a').removeClass('axiom-download');\n        // add current result type dependant classes\n        if (this.resultType === 'link') {\n            jQuery('a').addClass('axiom-link');\n        }\n        else if (this.resultType === 'axiom-download') {\n            jQuery('a').addClass('axiom-download');\n        }\n    };\n    InjectedSelectorTool.prototype.sendStateUpdate = function () {\n        var msg = {\n            action: \"update_state\",\n            preview_data: this.matchingData,\n            selectors: this.selectorData.selectors,\n            activeSelectorIndex: this.selectorData.activeSelectorIndex,\n            groupSelector: this.scrapeHelper.groupSelector\n        };\n        chrome.runtime.sendMessage(msg);\n    };\n    /**\n     * Disables the usage of the tool\n     */\n    InjectedSelectorTool.prototype.ejectV0200 = function () {\n        var _this = this;\n        jQuery(document).off('mousedown.axiom-selection');\n        jQuery('body').removeClass('axiom-sel-in-action');\n        this.removeAllHighlights(document);\n        var groupStyle = document.getElementById('axiom-group-style');\n        if (groupStyle) {\n            document.head.removeChild(groupStyle);\n        }\n        if (this.highlightBorder) {\n            this.highlightBorder.eject();\n        }\n        jQuery('a').removeClass('axiom-link');\n        AxiomApiHelper_1.AxiomApiHelper.applyToIframes(function (index, content) {\n            jQuery(content[0]).off('mousedown.axiom-selection');\n            _this.removeAllHighlights(content[0]);\n            var body = content.find('body');\n            jQuery(body).removeClass('axiom-sel-in-action');\n            if (_this.iframeHighlightBorders[index]) {\n                _this.iframeHighlightBorders[index].eject();\n            }\n            var groupStyle = content[0].getElementById('axiom-group-style');\n            if (groupStyle) {\n                content[0].head.removeChild(groupStyle);\n            }\n            content.find('a').removeClass('axiom-link');\n        });\n        this.inuse = false;\n        this.selectorData.selectors = [];\n        this.matching = [];\n        this.matchingData = [];\n    };\n    /**\n     * Disables the usage of the tool\n     */\n    InjectedSelectorTool.prototype.ejectV0190 = function (doc) {\n        this.ejectFromSpecificClasses();\n        jQuery(document).off('mousedown.axiom-selection');\n        jQuery('body').removeClass('axiom-sel-in-action');\n        this.removeAllHighlights(doc);\n        this.inuse = false;\n        this.selectorData.selectors = [];\n        this.matching = [];\n        this.matchingData = [];\n        var groupStyle = document.getElementById('axiom-group-style');\n        if (groupStyle) {\n            document.head.removeChild(groupStyle);\n        }\n        if (this.highlightBorder) {\n            this.highlightBorder.eject();\n        }\n        jQuery('a').removeClass('axiom-link');\n        jQuery('a').removeClass('axiom-download');\n    };\n    /**\n     *\n     */\n    InjectedSelectorTool.prototype.resume = function (doc) {\n        this.inuse = true;\n        jQuery('body').addClass('axiom-sel-in-action');\n        this.highlightBorder.setupBorder();\n        // remove all selection as this is a brand new selection\n        this.resetHighlights(doc);\n    };\n    /**\n     * Remove all highlights\n     */\n    InjectedSelectorTool.prototype.resetHighlights = function (doc) {\n        this.removeAllHighlights(doc);\n        this.setHighlights(doc);\n    };\n    InjectedSelectorTool.prototype.setHighlights = function (doc) {\n        var _this = this;\n        if (this.selectorData.selectors.length && this.selectionMode === 'multiple') {\n            var selectors = this.selectorData.selectors.map(function (selectorObj) {\n                if (!selectorObj.isToken && typeof selectorObj.selector === 'string' && selectorObj.selector !== 'head' && /\\S/.test(selectorObj.selector)) {\n                    return selectorObj.selector;\n                }\n                if (selectorObj.selector.hierarchy) {\n                    return selectorObj.selector.hierarchy;\n                }\n            }).filter(function (s) { return !!s; });\n            var combinedSelector = selectors.join(', ');\n            var matches = [];\n            if (typeof combinedSelector === 'string' && /\\S/.test(combinedSelector)) {\n                matches = Array.from(doc.querySelectorAll(combinedSelector));\n            }\n            var _loop_1 = function (s) {\n                if (s === this_1.selectorData.activeSelectorIndex) {\n                    for (var _i = 0, _a = this_1.selectorData.selectors[this_1.selectorData.activeSelectorIndex].selectedElements; _i < _a.length; _i++) {\n                        var el = _a[_i];\n                        if (el.classList)\n                            el.classList.add(this_1.selectingClass + this_1.selectorData.activeSelectorIndex);\n                    }\n                    for (var _b = 0, _c = this_1.selectorData.selectors[this_1.selectorData.activeSelectorIndex].rejectedElements; _b < _c.length; _b++) {\n                        var el = _c[_b];\n                        if (el.classList)\n                            el.classList.add(this_1.rejectingClass + this_1.selectorData.activeSelectorIndex);\n                    }\n                }\n                if (selectors[s] && /\\S/g.test(selectors[s])) {\n                    var matchingEls = Array.from(doc.querySelectorAll(selectors[s])); // TODO: get combined selector from selectedEls\n                    matchingEls.forEach(function (el) {\n                        if (!/axiom-sel-selected-\\S*|axiom-sel-rejected-\\S*/g.test(el.className)) {\n                            el.classList.add(_this.suggestingClass + s);\n                        }\n                    });\n                }\n            };\n            var this_1 = this;\n            for (var s = 0; s < selectors.length; s++) {\n                _loop_1(s);\n            }\n            for (var _i = 0, matches_1 = matches; _i < matches_1.length; _i++) {\n                var el = matches_1[_i];\n                jQuery(el).addClass('axiom-matched');\n                this.removeSelectedChildren(el);\n            }\n        }\n        else if (this.selectionMode === 'single') {\n            var sel = this.selectorData.selectors[0].selector;\n            var el = void 0;\n            if (sel.hierarchy) {\n                el = document.querySelector(this.selectorData.selectors[0].selector.hierarchy);\n            }\n            else if (sel.innerText) {\n                var xpath = \"//*[text()='\" + sel.innerText + \"']\";\n                el = document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;\n            }\n            jQuery(el).addClass('axiom-matched');\n            jQuery(el).addClass('axiom-sel-selected-0');\n        }\n        var groupStyle = doc.getElementById('axiom-group-style');\n        if (!groupStyle) {\n            groupStyle = doc.createElement('style');\n            groupStyle.id = 'axiom-group-style';\n            doc.head.appendChild(groupStyle);\n        }\n        if (this.scrapeHelper.groupSelector !== undefined && this.scrapeHelper.groupSelector !== '' && this.scrapeHelper.groupSelector !== 'body') {\n            groupStyle.innerHTML = this.scrapeHelper.groupSelector + \" {\\n                border-style: dotted !important;\\n                border-width: 3px !important;\\n                border-color: #FFC107 !important;\\n                padding: 5px !important;\\n                border-radius: 10px !important;\\n            }\";\n        }\n        else {\n            groupStyle.innerHTML = '';\n        }\n        var otherSelectors = \"\\n        [class*=\\\"\" + this.selectingClass + \"\\\"].axiom-matched  {\\n            background: rgba(0, 153, 255, 0.7) !important\\n            background-image: none !important;\\n        }\\n        [class*=\\\"\" + this.suggestingClass + \"\\\"].axiom-matched  {\\n            background: rgba(0, 153, 255, 0.3) !important;\\n            background-image: none !important;\\n        }\\n        \\n        [class*=\\\"\" + this.selectingClass + \"\\\"]:not(.axiom-matched)  {\\n            background: rgba(153, 153, 153, 0.7) !important\\n            background-image: none !important;\\n        }\\n        [class*=\\\"\" + this.suggestingClass + \"\\\"]:not(.axiom-matched)  {\\n            background: rgba(153, 153, 153, 0.3) !important;\\n            background-image: none !important;\\n        }\";\n        var activeSelector = \"\\n        [class~=\\\"\" + (this.selectingClass + this.selectorData.activeSelectorIndex) + \"\\\"].axiom-matched  {\\n            background-color: #FFC107 !important;\\n            background-image: none !important;\\n        }\\n        [class~=\\\"\" + (this.suggestingClass + this.selectorData.activeSelectorIndex) + \"\\\"].axiom-matched  {\\n            background-color: #ffd98c !important; \\n            background-image: none !important;\\n        }\\n        \\n        [class~=\\\"\" + (this.selectingClass + this.selectorData.activeSelectorIndex) + \"\\\"]:not(.axiom-matched)  {\\n            background-color: rgba(193,193,193, 0.7) !important;\\n            background-image: none !important;\\n        }\\n        [class~=\\\"\" + (this.suggestingClass + this.selectorData.activeSelectorIndex) + \"\\\"]:not(.axiom-matched)  {\\n            background-color: rgba(193,193,193, 0.3) !important; \\n            background-image: none !important;\\n        }\";\n        groupStyle.innerHTML += otherSelectors;\n        groupStyle.innerHTML += activeSelector;\n    };\n    InjectedSelectorTool.prototype.getSelector = function (element) {\n        return this.SelectorAlgorithm.getSelector(element);\n    };\n    /**\n     * Sets \"'axiom-sel-selected-' + number\" for the selection that has been clicked\n     *\n     */\n    InjectedSelectorTool.prototype.setClassForSelected = function (el) {\n        el.classList.add(this.selectingClass + this.selectorData.activeSelectorIndex);\n        return;\n    };\n    /**\n     * Removes \"'axiom-sel-selected-' + number\" for the selection that has been clicked\n     *\n     */\n    InjectedSelectorTool.prototype.removeClassForSelected = function (el) {\n        el.classList.remove(this.selectingClass + this.selectorData.activeSelectorIndex);\n        return;\n    };\n    InjectedSelectorTool.prototype.removeClassForRejected = function (el) {\n        el.classList.remove(this.rejectingClass + this.selectorData.activeSelectorIndex);\n        return;\n    };\n    /**\n     * Sets \"'axiom-sel-suggested-' + number\" for active selector's candidate selections\n     *\n     */\n    InjectedSelectorTool.prototype.setClassForSuggested = function () {\n        var cls = this.suggestingClass + this.selectorData.activeSelectorIndex;\n        this.matching.forEach(function (el) {\n            if (!/axiom-sel-selected-\\S*|axiom-sel-rejected-\\S*/g.test(el.className)) {\n                el.classList.add(cls);\n            }\n        });\n        return;\n    };\n    /**\n     * Removes all classes which are injected for the highlighting purposes\n     */\n    InjectedSelectorTool.prototype.removeAllHighlights = function (doc) {\n        if (!this.selectorData.selectors || this.selectorData.selectors.length === 0) {\n            return;\n        }\n        for (var s = 0; s < this.selectorData.selectors.length; s++) {\n            jQuery(doc).find('*').removeClass(\"axiom-sel-selected-\" + s);\n            jQuery(doc).find('*').removeClass(\"axiom-sel-suggested-\" + s);\n            jQuery(doc).find('*').removeClass(\"axiom-sel-rejected-\" + s);\n            jQuery(doc).find('*').removeClass(\"axiom-matched\");\n        }\n    };\n    /**\n     * Highlights the the current selectors\n     */\n    InjectedSelectorTool.prototype.highlightSelection = function () {\n        var _this = this;\n        if (this.selectionMode === 'multiple') {\n            var sel = document.querySelectorAll(this.selectingClass + this.selectorData.activeSelectorIndex);\n            var sug = document.querySelectorAll(this.suggestingClass + this.selectorData.activeSelectorIndex);\n            var reg = document.querySelectorAll(this.rejectingClass + this.selectorData.activeSelectorIndex);\n            sel.forEach(function (el) {\n                el.classList.add(_this.selectingClass + _this.selectorData.activeSelectorIndex);\n            });\n            sug.forEach(function (el) {\n                el.classList.add(_this.suggestingClass + _this.selectorData.activeSelectorIndex);\n            });\n            reg.forEach(function (el) {\n                el.classList.add(_this.rejectingClass + _this.selectorData.activeSelectorIndex);\n            });\n        }\n        else {\n            var sel = document.querySelectorAll(this.selectingClass + this.selectorData.activeSelectorIndex);\n            sel.forEach(function (el) {\n                el.classList.add(_this.selectingClass + _this.selectorData.activeSelectorIndex);\n                el.classList.add('axiom-matched');\n            });\n        }\n    };\n    InjectedSelectorTool.prototype.findMatchesV0190 = function (doc) {\n        if (this.selectionMode === 'multiple') {\n            var newData = [];\n            this.matching = []; // TODO: Check what this is actually doing. It's never checked anywhere I can see, just set.\n            var selectors = this.selectorData.selectors.filter(function (s) {\n                return typeof s.selector === 'string';\n            }).map(function (s) {\n                if (s.isToken) {\n                    return \"head\";\n                }\n                else {\n                    return s.selector;\n                }\n            });\n            if (selectors.length) {\n                if (this.resultTypes[0] === 'axiom-download' && selectors) {\n                    try {\n                        newData = Array.from(doc.querySelectorAll(selectors[0])).map(function (el) { return [el.outerHTML]; });\n                    }\n                    catch (e) {\n                        // no action required\n                    }\n                }\n                else {\n                    newData = this.scrapeHelper.getPreview(doc, selectors, this.selectorData.selectors.map(function (s) { return s.resultType; }));\n                }\n            }\n            newData = AxiomApiHelper_1.AxiomApiHelper.transpose(newData);\n            if (newData.length > 0) {\n                for (var n in newData) {\n                    var skip = false;\n                    if (newData[n] && newData[n].length > 0) {\n                        for (var _i = 0, _a = newData[n]; _i < _a.length; _i++) {\n                            var d = _a[_i];\n                            if (d === \"NO MATCHING ELEMENT\") {\n                                skip = true;\n                                break;\n                            }\n                        }\n                    }\n                    if (!skip) {\n                        this.matchingData[n] = newData[n];\n                    }\n                }\n            }\n            // Fix any holes in the data\n            if (selectors.length > 1) {\n                // First, determine the max number of columns\n                var maxCols = 0;\n                for (var i = 0; i < this.matchingData.length; i++) {\n                    if (this.matchingData[i] && maxCols < this.matchingData[i].length) {\n                        maxCols = this.matchingData[i].length;\n                    }\n                }\n                // Then fill in the gaps!\n                for (var i = 0; i < selectors.length; i++) {\n                    var thisLen = this.matchingData[i] ? this.matchingData[i].length : 0;\n                    if (thisLen < maxCols) {\n                        for (var j = thisLen; j < maxCols; j++) {\n                            if (!this.matchingData[i]) {\n                                this.matchingData[i] = [];\n                            }\n                            this.matchingData[i].push('');\n                        }\n                    }\n                }\n            }\n            // Trim matching data to maximum selector length\n            if (this.matchingData.length > selectors.length) {\n                this.matchingData = this.matchingData.slice(0, selectors.length);\n            }\n            // For any tokens, just add the token name into the matching data.\n            for (var s = 0; s < this.selectorData.selectors.length; s++) {\n                var sel = this.selectorData.selectors[s];\n                if (sel.isToken) {\n                    this.matchingData[s][0] = sel.selector;\n                }\n            }\n        }\n    };\n    InjectedSelectorTool.prototype.blockClicksOn = function (doc) {\n        // Block the entire screen to prevent anything else from being clicked. Amazing this works really!\n        var block = jQuery('<div>').css('position', 'fixed').css('z-index', '9999999').\n            css('width', '10000px').css('height', '10000px').\n            css('top', 0).css('left', 0).css('background-color', '');\n        doc.body.appendChild(block.get(0));\n        setTimeout(function () {\n            block.remove();\n        }, 300);\n        return false;\n    };\n    /**\n     * When the selection is performed some widgets may require to perform any UI operation. Those are done here\n     *\n     * @param widgetType The type of widget to determine what to do\n     */\n    InjectedSelectorTool.prototype.closingAction = function (widgetType) {\n        return __awaiter(this, void 0, void 0, function () {\n            var selectedElements, elem_1, regex, buttonLabel, axiomWorkspace;\n            return __generator(this, function (_a) {\n                if (!this.selectorData.selectors[this.selectorData.activeSelectorIndex]) {\n                    return [2 /*return*/];\n                }\n                if (this.selectionMode === \"single\" && widgetType && widgetType === 'WidgetDriverClick') {\n                    selectedElements = this.selectorData.selectors[0].selector.hierarchy;\n                    elem_1 = jQuery(selectedElements);\n                    if (!elem_1[0]) {\n                        return [2 /*return*/];\n                    }\n                    regex = new RegExp(/\\w*(create|send|submit)\\w*/gi);\n                    buttonLabel = elem_1.text() || elem_1.val();\n                    if (!regex.test(buttonLabel)) {\n                        axiomWorkspace = document.getElementById('axiom-bot-draw-1976253492');\n                        axiomWorkspace.classList.add(\"axiom-static\");\n                        $.confirm({\n                            title: 'Selection Made',\n                            content: 'Do you want to click this element now?',\n                            boxWidth: '448px',\n                            useBootstrap: false,\n                            // Custom width\n                            // https://craftpip.github.io/jquery-confirm/#custom-width\n                            buttons: {\n                                confirm: function () {\n                                    if (elem_1[0].tagName.toLowerCase() == 'svg') {\n                                        elem_1 = elem_1.parent();\n                                    }\n                                    elem_1[0].click();\n                                },\n                                cancel: function () {\n                                    return;\n                                }\n                            }\n                        });\n                    }\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    /**\n     * Click Handler for single element selections when the selector tool is in action\n     *\n     * @param e\n     */\n    InjectedSelectorTool.prototype.singleElementClickHandler = function (e) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, singleSelection;\n            var _this = this;\n            return __generator(this, function (_a) {\n                x = e.target;\n                if (!x.classList.contains('axiom-selector-ignore')) {\n                    if (this.resultType === 'link') {\n                        while (x.parentElement && !/\\S/.test(this.scrapeHelper.getData(x, this.resultType))) {\n                            x = x.parentElement;\n                        }\n                    }\n                }\n                this.blockClicksOn(document);\n                AxiomApiHelper_1.AxiomApiHelper.applyToIframes(function (index, content) {\n                    _this.blockClicksOn(content[0]);\n                });\n                if (this.selectorData.selectors[this.selectorData.activeSelectorIndex] === undefined) {\n                    this.selectorData.selectors[this.selectorData.activeSelectorIndex] = {\n                        selector: '',\n                        selections: [],\n                        selectedElements: [],\n                        rejectedElements: [],\n                    };\n                }\n                singleSelection = this.singleSelector.getSelector(x);\n                this.selectorData.selectors[this.selectorData.activeSelectorIndex].selector = singleSelection;\n                this.removeAllHighlights(document);\n                AxiomApiHelper_1.AxiomApiHelper.applyToIframes(function (index, content) {\n                    _this.removeAllHighlights(content[0]);\n                });\n                this.sendStateUpdate();\n                if (!this.selectorData.selectors[this.selectorData.activeSelectorIndex].selectedElements) {\n                    this.selectorData.selectors[this.selectorData.activeSelectorIndex].selectedElements = [];\n                }\n                this.selectorData.selectors[this.selectorData.activeSelectorIndex].selectedElements.push(x);\n                this.setHighlights(document);\n                AxiomApiHelper_1.AxiomApiHelper.applyToIframes(function (index, content) {\n                    _this.setHighlights(content[0]);\n                });\n                // Reset the token flag - if you select something, it's no longer selected by a token\n                this.selectorData.selectors[this.selectorData.activeSelectorIndex].isToken = undefined;\n                try {\n                    this.sendStateUpdate();\n                }\n                catch (e) {\n                    console.warn('Unable to send back message to the chrome extension on single element selection');\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    /**\n     * Go down the tree and remove any children of this element that have previously been selected but are no longer\n     * matched by anything - orphaned selectors essentially, which appear as grey blocks that cannot be clicked on inside\n     * a valid, working selector\n     * @param e An element to find the children of and remove any selectors\n     */\n    InjectedSelectorTool.prototype.removeSelectedChildren = function (e) {\n        var children = e.children;\n        for (var i = 0; i < children.length; i++) {\n            var child = children[i];\n            child.classList.remove(this.selectingClass + this.selectorData.activeSelectorIndex);\n            this.removeSelectedChildren(child);\n        }\n    };\n    /**\n     * Hanldes click when the selector tool is in action\n     *\n     * @param e\n     */\n    InjectedSelectorTool.prototype.elementClickHandler = function (e) {\n        return __awaiter(this, void 0, void 0, function () {\n            var x, suggestedElements, combinedSelector_1;\n            var _this = this;\n            return __generator(this, function (_a) {\n                x = e.target;\n                if (this.resultType === 'link') {\n                    while (x.parentElement && !/\\S/.test(this.scrapeHelper.getDataV0210(x, this.resultType))) {\n                        x = x.parentElement;\n                    }\n                }\n                this.blockClicksOn(document);\n                AxiomApiHelper_1.AxiomApiHelper.applyToIframes(function (index, content) {\n                    _this.blockClicksOn(content[0]);\n                });\n                if (this.selectorData.selectors[this.selectorData.activeSelectorIndex] === undefined) {\n                    this.selectorData.selectors[this.selectorData.activeSelectorIndex] = {\n                        selector: '',\n                        selections: [],\n                        selectedElements: [],\n                        rejectedElements: [],\n                        resultType: this.selectorData.defaultResultType,\n                    };\n                }\n                else {\n                    this.selectorData.selectors[this.selectorData.activeSelectorIndex].isToken = false;\n                }\n                if (!/axiom-tool/g.test(x.className)) {\n                    suggestedElements = [];\n                    try {\n                        if (this.selectionMode = 'multiple') {\n                            suggestedElements = Array.from(document.querySelectorAll(this.selectorData.selectors[this.selectorData.activeSelectorIndex].selector));\n                        }\n                    }\n                    catch (e) {\n                        suggestedElements = [];\n                    }\n                    if (suggestedElements.includes(x)) {\n                        // if element is manually selected by user\n                        if (this.selectorData.selectors[this.selectorData.activeSelectorIndex].selectedElements.includes(x)) {\n                            // unselect element\n                            x.classList.remove(this.selectingClass + this.selectorData.activeSelectorIndex);\n                            this.selectorData.selectors[this.selectorData.activeSelectorIndex].selectedElements = this.selectorData.selectors[this.selectorData.activeSelectorIndex].selectedElements.filter(function (el) {\n                                return el !== x;\n                            });\n                            // if we have deselected all elements then we should automatically deselect all rejected elements:\n                            if (this.selectorData.selectors[this.selectorData.activeSelectorIndex].selectedElements.length === 0) {\n                                this.selectorData.selectors[this.selectorData.activeSelectorIndex].rejectedElements = [];\n                            }\n                        }\n                        else { // element is only suggested by the selection\n                            // exclude the element\n                            if (!this.selectorData.selectors[this.selectorData.activeSelectorIndex].rejectedElements.includes(x)) {\n                                x.classList.add(this.rejectingClass + this.selectorData.activeSelectorIndex);\n                                this.selectorData.selectors[this.selectorData.activeSelectorIndex].rejectedElements.push(x);\n                            }\n                            else {\n                                x.classList.remove(this.rejectingClass + this.selectorData.activeSelectorIndex);\n                                this.selectorData.selectors[this.selectorData.activeSelectorIndex].rejectedElements = this.selectorData.selectors[this.selectorData.activeSelectorIndex].rejectedElements.filter(function (el) {\n                                    return el !== x;\n                                });\n                            }\n                        }\n                    }\n                    else { // element is not currently included in the selection\n                        if (this.selectorData.selectors[this.selectorData.activeSelectorIndex].rejectedElements.includes(x)) {\n                            // element has previously been manually excluded: remove from rejected list\n                            x.classList.remove(this.rejectingClass + this.selectorData.activeSelectorIndex);\n                            this.selectorData.selectors[this.selectorData.activeSelectorIndex].rejectedElements = this.selectorData.selectors[this.selectorData.activeSelectorIndex].rejectedElements.filter(function (el) {\n                                return el !== x;\n                            });\n                            // If this hasn't been tagged as matched, immediately re-select it; this can happen in the case where you unselect a non-selected\n                            // element, and this removes everything. The main way that happens is when editing selectors.\n                            if (!x.classList.contains(\"axiom-matched\")) {\n                                x.classList.add(this.selectingClass + this.selectorData.activeSelectorIndex);\n                                this.selectorData.selectors[this.selectorData.activeSelectorIndex].selectedElements.push(x);\n                            }\n                        }\n                        else { // element is not rejected or suggested\n                            // select element\n                            x.classList.add(this.selectingClass + this.selectorData.activeSelectorIndex);\n                            this.selectorData.selectors[this.selectorData.activeSelectorIndex].selectedElements.push(x);\n                        }\n                    }\n                    combinedSelector_1 = this.hierarchyActions.getCombined(document, this.selectorData.selectors[this.selectorData.activeSelectorIndex].selectedElements, this.selectorData.selectors[this.selectorData.activeSelectorIndex].rejectedElements, 'selector');\n                    if (document.querySelectorAll(combinedSelector_1).length > 0) {\n                        this.selectorData.selectors[this.selectorData.activeSelectorIndex].selector = combinedSelector_1;\n                    }\n                    else {\n                        AxiomApiHelper_1.AxiomApiHelper.applyToIframes(function (index, content) {\n                            combinedSelector_1 = _this.hierarchyActions.getCombined(content[0], _this.selectorData.selectors[_this.selectorData.activeSelectorIndex].selectedElements, _this.selectorData.selectors[_this.selectorData.activeSelectorIndex].rejectedElements, 'selector');\n                            if (content[0].querySelectorAll(combinedSelector_1).length > 0) {\n                                _this.selectorData.selectors[_this.selectorData.activeSelectorIndex].selector = combinedSelector_1;\n                            }\n                        });\n                    }\n                    this.findMatchesV0190(document);\n                    this.resetHighlights(document);\n                    AxiomApiHelper_1.AxiomApiHelper.applyToIframes(function (index, doc) {\n                        _this.findMatchesV0190(doc[0]);\n                        _this.resetHighlights(doc[0]);\n                    });\n                    // Reset the token flag - if you select something, it's no longer selected by a token\n                    this.selectorData.selectors[this.selectorData.activeSelectorIndex].isToken = undefined;\n                    this.sendStateUpdate();\n                }\n                return [2 /*return*/, false];\n            });\n        });\n    };\n    return InjectedSelectorTool;\n}());\nexports.InjectedSelectorTool = InjectedSelectorTool;\nwindow['axiom_selector'] = new InjectedSelectorTool();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODA4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3JlY29yZGVyL3Rvb2wvSW5qZWN0ZWRTZWxlY3RvclRvb2wudHM/NzJhNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQXR0cmlidXRlU2VsZWN0b3JfMSA9IHJlcXVpcmUoXCIuLi9TZWxlY3RvcnMvQXR0cmlidXRlU2VsZWN0b3JcIik7XG52YXIgSGllcmFjaHlBY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vU2VsZWN0b3JzL0hpZXJhY2h5QWN0aW9uc1wiKTtcbnZhciBTZWxlY3RvckZhY2FkZV8xID0gcmVxdWlyZShcIi4uL1NlbGVjdG9ycy9TZWxlY3RvckZhY2FkZVwiKTtcbnZhciBCb3JkZXJIaWdobGlnaHRfMSA9IHJlcXVpcmUoXCIuL0JvcmRlckhpZ2hsaWdodFwiKTtcbnZhciBTY3JhcGVIZWxwZXJfMSA9IHJlcXVpcmUoXCIuL1NjcmFwZUhlbHBlclwiKTtcbnZhciBBeGlvbUFwaUhlbHBlcl8xID0gcmVxdWlyZShcIi4uLy4uL2xpYi9heGlvbWFwaS9BeGlvbUFwaUhlbHBlclwiKTtcbi8qKlxuICogU2VsZWN0aW9uQWN0aW9uc1xuICovXG52YXIgU2VsZWN0aW9uQWN0aW9ucyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZWxlY3Rpb25BY3Rpb25zKGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RvckRhdGEgPSBjb250ZXh0O1xuICAgIH1cbiAgICBTZWxlY3Rpb25BY3Rpb25zLnByb3RvdHlwZS5hZGRfY29sdW1uID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3JEYXRhLmFkZFNlbGVjdG9yKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvckRhdGEuZWRpdFNlbGVjdG9yKHRoaXMuc2VsZWN0b3JEYXRhLnNlbGVjdG9ycy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTZWxlY3Rpb25BY3Rpb25zLnByb3RvdHlwZS5yZW1vdmVfY29sdW1uID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3JEYXRhLnJlbW92ZVNlbGVjdG9yKHJlcXVlc3QuaW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbkFjdGlvbnMucHJvdG90eXBlLnNlbGVjdF9jb2x1bW4gPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvckRhdGEuZWRpdFNlbGVjdG9yKHJlcXVlc3QuaW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbkFjdGlvbnMucHJvdG90eXBlLnNldF9yZXN1bHRfdHlwZSA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yRGF0YS5zZXRSZXN1bHRUeXBlKHJlcXVlc3Quc2VsX2luZGV4LCByZXF1ZXN0LnJlc3VsdFR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNlbGVjdGlvbkFjdGlvbnMucHJvdG90eXBlLnJlc2V0X2NvbHVtbiA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yRGF0YS5yZXNldFNlbGVjdG9yKHJlcXVlc3QuaW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3JEYXRhLmVkaXRTZWxlY3RvcihyZXF1ZXN0LmluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTZWxlY3Rpb25BY3Rpb25zLnByb3RvdHlwZS5hZGRFbGVtZW50VG9TZWxlY3Rpb24gPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2VsZWN0aW9uQWN0aW9ucy5wcm90b3R5cGUucmVtb3ZlRWxlbWVudEZyb21TZWxlY3Rpb24gPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2VsZWN0aW9uQWN0aW9ucy5wcm90b3R5cGUuZWRpdF9zZWxlY3RvciA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yRGF0YS51cGRhdGVTZWxlY3RvcihyZXF1ZXN0LmluZGV4LCByZXF1ZXN0LnNlbGVjdG9yLCByZXF1ZXN0LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFNlbGVjdGlvbkFjdGlvbnM7XG59KCkpO1xuLyoqXG4gKiBTZWxlY3RvckRhdGFcbiAqL1xudmFyIFNlbGVjdG9yRGF0YSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZWxlY3RvckRhdGEoKSB7XG4gICAgICAgIHRoaXMucmVmcmVzaFJlcXVpcmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2VsZWN0b3JzID0gbnVsbDtcbiAgICAgICAgdGhpcy5hY3RpdmVTZWxlY3RvckluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5hY3Rpb25zID0gbmV3IFNlbGVjdGlvbkFjdGlvbnModGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSByZXF1ZXN0ZWQgYWN0aW9uIGFuZCB0aGVuIGF1dG9tYXRpY2FsbHkgaGFuZGxlcyBhbnkgcmVjYWxjdWxhdGlvbnMgYW5kIGlzc3Vpbmcgb2YgdXBkYXRlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHJlcXVlc3Qge2FjdGlvbiwgLi4ucGFyYW1zfVxuICAgICAqL1xuICAgIFNlbGVjdG9yRGF0YS5wcm90b3R5cGUuYWN0aW9uUmVxdWVzdCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5hY3Rpb25zW3JlcXVlc3QuYWN0aW9uXShyZXF1ZXN0KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTZWxlY3RvckRhdGEucHJvdG90eXBlLmFkZFNlbGVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNlbGVjdG9ycy5wdXNoKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnaGVhZCcsXG4gICAgICAgICAgICBzZWxlY3RlZEVsZW1lbnRzOiBbXSxcbiAgICAgICAgICAgIHJlamVjdGVkRWxlbWVudHM6IFtdLFxuICAgICAgICAgICAgcmVzdWx0VHlwZTogdGhpcy5kZWZhdWx0UmVzdWx0VHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWZyZXNoUmVxdWlyZWQgPSB0cnVlO1xuICAgIH07XG4gICAgU2VsZWN0b3JEYXRhLnByb3RvdHlwZS5yZW1vdmVTZWxlY3RvciA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB0aGlzLnNlbGVjdG9ycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFNlbGVjdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVtb3ZlZExhc3RDb2x1bW4gPSAoaW5kZXggPT09IHRoaXMuc2VsZWN0b3JzLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgcmVtb3ZlZFdoaWxlU2VsZWN0ZWQgPSAoaW5kZXggPT09IHRoaXMuYWN0aXZlU2VsZWN0b3JJbmRleCk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRDb2x1bW5TaGlmdGVkTGVmdCA9IChpbmRleCA8PSB0aGlzLmFjdGl2ZVNlbGVjdG9ySW5kZXgpO1xuICAgICAgICAgICAgaWYgKChyZW1vdmVkTGFzdENvbHVtbiAmJiByZW1vdmVkV2hpbGVTZWxlY3RlZCkgfHwgc2VsZWN0ZWRDb2x1bW5TaGlmdGVkTGVmdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdFNlbGVjdG9yKHRoaXMuYWN0aXZlU2VsZWN0b3JJbmRleCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZVNlbGVjdG9ySW5kZXggPT09IC0xICYmIHRoaXMuc2VsZWN0b3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlU2VsZWN0b3JJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWZyZXNoUmVxdWlyZWQgPSB0cnVlO1xuICAgIH07XG4gICAgU2VsZWN0b3JEYXRhLnByb3RvdHlwZS5lZGl0U2VsZWN0b3IgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgdGhpcy5zZWxlY3RvcnMubGVuZ3RoKSB7IC8vIGNoZWNrIGluZGV4IGV4aXN0c1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVTZWxlY3RvckluZGV4ID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hY3RpdmVTZWxlY3RvckluZGV4ID49IHRoaXMuc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gaWYgY3VycmVudCBzZWxlY3Rpb24gaXMgbm90IHZhbGlkIHRoZW4gc2V0IHRvIGxhc3QgY29sdW1uXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVNlbGVjdG9ySW5kZXggPSB0aGlzLnNlbGVjdG9ycy5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVmcmVzaFJlcXVpcmVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNlbGVjdG9yRGF0YS5wcm90b3R5cGUudXBkYXRlU2VsZWN0b3IgPSBmdW5jdGlvbiAoaW5kZXgsIHNlbGVjdG9yLCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdG9yc1tpbmRleF0pIHtcbiAgICAgICAgICAgIC8vIE9ubHkgaGFwcGVucyBpZiBpdCdzIGEgYnJhbmQgbmV3IHNjcmFwZSwgc28gdGhpcyBzaG91bGQgYmUgc2FmZVxuICAgICAgICAgICAgdGhpcy5hZGRTZWxlY3RvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0b3JzW2luZGV4XSA9IHNlbGVjdG9yW2luZGV4XTtcbiAgICAgICAgdmFyIHNpbmdsZVNlbGVjdG9yID0gbmV3IFNlbGVjdG9yRmFjYWRlXzEuU2VsZWN0b3JGYWNhZGUoKTtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gXCJoaWVyYXJjaHlcIikge1xuICAgICAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcltpbmRleF0uc2VsZWN0b3IuaGllcmFyY2h5KTtcbiAgICAgICAgICAgIGlmICghZWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yc1tpbmRleF0uc2VsZWN0b3IuaW5uZXJUZXh0ID0gXCJcIixcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvcnNbaW5kZXhdLnNlbGVjdG9yLnRhcmdldEVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5ld1NlbGVjdG9ycyA9IHNpbmdsZVNlbGVjdG9yLmdldFNlbGVjdG9yKGVsKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3JzW2luZGV4XS5zZWxlY3Rvci5pbm5lclRleHQgPSBuZXdTZWxlY3RvcnMuaW5uZXJUZXh0LFxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3JzW2luZGV4XS5zZWxlY3Rvci50YXJnZXRFbGVtZW50ID0gbmV3U2VsZWN0b3JzLnRhcmdldEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGFyZ2V0ID09PSBcImlubmVyVGV4dFwiKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5ldmFsdWF0ZShcIi8vKlt0ZXh0KCk9J1wiICsgc2VsZWN0b3JbaW5kZXhdLnNlbGVjdG9yLmlubmVyVGV4dCArIFwiJ11cIiwgZG9jdW1lbnQsIG51bGwsIFhQYXRoUmVzdWx0LkZJUlNUX09SREVSRURfTk9ERV9UWVBFLCBudWxsKS5zaW5nbGVOb2RlVmFsdWU7XG4gICAgICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvcnNbaW5kZXhdLnNlbGVjdG9yLmhpZXJhcmNoeSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvcnNbaW5kZXhdLnRhcmdldEVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5ld1NlbGVjdG9ycyA9IHNpbmdsZVNlbGVjdG9yLmdldFNlbGVjdG9yKGVsKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3JzW2luZGV4XS5zZWxlY3Rvci5oaWVyYXJjaHkgPSBuZXdTZWxlY3RvcnMuaGllcmFyY2h5O1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RvcnNbaW5kZXhdLnNlbGVjdG9yLnRhcmdldEVsZW1lbnQgPSBuZXdTZWxlY3RvcnMudGFyZ2V0RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZnJlc2hSZXF1aXJlZCA9IHRydWU7XG4gICAgfTtcbiAgICBTZWxlY3RvckRhdGEucHJvdG90eXBlLnNldFJlc3VsdFR5cGUgPSBmdW5jdGlvbiAoaW5kZXgsIHJlc3VsdFR5cGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdG9yc1tpbmRleF0pIHtcbiAgICAgICAgICAgIHRoaXMuYWRkU2VsZWN0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdG9yc1tpbmRleF0ucmVzdWx0VHlwZSA9IHJlc3VsdFR5cGU7XG4gICAgICAgIHRoaXMucmVmcmVzaFJlcXVpcmVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNlbGVjdG9yRGF0YS5wcm90b3R5cGUucmVzZXRTZWxlY3RvciA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB0aGlzLnNlbGVjdG9yc1tpbmRleF0gPSB7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ2hlYWQnLFxuICAgICAgICAgICAgc2VsZWN0aW9uczogW10sXG4gICAgICAgICAgICBzZWxlY3RlZEVsZW1lbnRzOiBbXSxcbiAgICAgICAgICAgIHJlamVjdGVkRWxlbWVudHM6IFtdLFxuICAgICAgICAgICAgcmVzdWx0VHlwZTogdGhpcy5kZWZhdWx0UmVzdWx0VHlwZSxcbiAgICAgICAgICAgIGdyb3VwU2VsZWN0b3I6ICdib2R5J1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlZnJlc2hSZXF1aXJlZCA9IHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gU2VsZWN0b3JEYXRhO1xufSgpKTtcbi8qKlxuICogQGF1dGhvciBOYXNpayBha2EgS2lzYW4gPG5hc2lrLnNoYWZlZWtAYWJzdHJhY3Rpb24uY28+XG4gKiBAYXV0aG9yIFNpbW9uIERlbGFueSA8c2ltb24uZGVsYW55QGF4aW9tLmFpPlxuICpcbiAqIEluamVjdGVkIGludG8gY29udGVudCBwYWdlIGFuZCB3aWxsIGJlIGtpY2tlZCBpbnRvIGFjdGlvbiB3aGVuIHRoZSB0b29sIGlzIGluIHVzZVxuICpcbiAqL1xudmFyIEluamVjdGVkU2VsZWN0b3JUb29sID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEluamVjdGVkU2VsZWN0b3JUb29sKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmlmcmFtZUhpZ2hsaWdodEJvcmRlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0b3JJZCA9IDA7XG4gICAgICAgIHRoaXMuYWN0aXZlU2VsZWN0b3IgPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmVTZWxlY3RvckluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuc2VsZWN0aW5nQ2xhc3MgPSAnYXhpb20tc2VsLXNlbGVjdGVkLSc7XG4gICAgICAgIHRoaXMuc3VnZ2VzdGluZ0NsYXNzID0gJ2F4aW9tLXNlbC1zdWdnZXN0ZWQtJztcbiAgICAgICAgdGhpcy5yZWplY3RpbmdDbGFzcyA9ICdheGlvbS1zZWwtcmVqZWN0ZWQtJztcbiAgICAgICAgdGhpcy5yZXN1bHRUeXBlID0gJ3RleHRDb250ZW50JztcbiAgICAgICAgdGhpcy5yZXN1bHRUeXBlcyA9IFsndGV4dENvbnRlbnQnXTtcbiAgICAgICAgdGhpcy5pZnJhbWVTdXBwb3J0RW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLlNlbGVjdG9yQWxnb3JpdGhtID0gbmV3IEF0dHJpYnV0ZVNlbGVjdG9yXzEuQXR0cmlidXRlU2VsZWN0b3IoKTtcbiAgICAgICAgdGhpcy5oaWVyYXJjaHlBY3Rpb25zID0gbmV3IEhpZXJhY2h5QWN0aW9uc18xLkhpZXJhcmNoeUFjdGlvbnMoKTtcbiAgICAgICAgdGhpcy5tYXRjaGluZyA9IFtdO1xuICAgICAgICB0aGlzLm1hdGNoaW5nRGF0YSA9IFtdO1xuICAgICAgICB0aGlzLmhpZ2hsaWdodEJvcmRlciA9IG5ldyBCb3JkZXJIaWdobGlnaHRfMS5Cb3JkZXJIaWdobGlnaHQoZG9jdW1lbnQsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuc2luZ2xlU2VsZWN0b3IgPSBuZXcgU2VsZWN0b3JGYWNhZGVfMS5TZWxlY3RvckZhY2FkZSgpO1xuICAgICAgICB0aGlzLnNjcmFwZUhlbHBlciA9IG5ldyBTY3JhcGVIZWxwZXJfMS5TY3JhcGVIZWxwZXIoKTtcbiAgICAgICAgdGhpcy5zZWxlY3RvckRhdGEgPSBuZXcgU2VsZWN0b3JEYXRhKCk7XG4gICAgICAgIGNocm9tZS5ydW50aW1lLm9uTWVzc2FnZS5hZGRMaXN0ZW5lcihmdW5jdGlvbiAocmVxdWVzdCwgc2VuZGVyLCBzZW5kUmVzcG9uc2UpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgc3VnZ2VzdGlvbnM7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSByZXF1ZXN0LmFjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzZWxlY3Rvcl90b29sX3N0YXJ0JzogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2VsZWN0b3JfdG9vbF9jb25maXJtJzogcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNlbGVjdG9yX3Rvb2xfcmVzZXRcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNlbGVjdG9yX3Rvb2xfY2FuY2VsXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzZXRfcmVzdWx0X3R5cGVcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2VsZWN0X2NvbHVtbic6IHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlbW92ZV9jb2x1bW4nOiByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdhZGRfY29sdW1uJzogcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVzZXRfY29sdW1uJzogcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZWRpdF9zZWxlY3Rvcic6IHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJoaWRlX2J1YmJsZVwiOiByZXR1cm4gWzMgLypicmVhayovLCA3XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2VuZXJhdGVfc3VnZ2VzdGlvbnNcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNldF9pZnJhbWVfc3VwcG9ydFwiOiByZXR1cm4gWzMgLypicmVhayovLCA5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JhcGVIZWxwZXIuZ3JvdXBTZWxlY3RvciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGUgPSAocmVxdWVzdC5zZWxlY3Rpb25UeXBlID09PSAnc21hcnQnIHx8IHJlcXVlc3Quc2VsZWN0aW9uVHlwZSA9PT0gJ211bHRpJykgPyAnbXVsdGlwbGUnIDogJ3NpbmdsZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5yZXN1bHRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVxdWVzdC5yZXN1bHRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdFR5cGVzID0gcmVxdWVzdC5yZXN1bHRUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdFR5cGUgPSB0aGlzLnJlc3VsdFR5cGVzW3RoaXMuc2VsZWN0b3JEYXRhLmFjdGl2ZVNlbGVjdG9ySW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRUeXBlID0gcmVxdWVzdC5yZXN1bHRUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdFR5cGVzID0gW3JlcXVlc3QucmVzdWx0VHlwZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRUeXBlID0gJ291dGVySFRNTCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIHRvIHNldCBhIGRlZmF1bHQgcmVzdWx0VHlwZSBlLmcuIGZvciB3aWRnZXRzIGxpa2Ugc2NyYXBlTGluayB0byBoYXZlIHRoZSBsaW5rIHJlc3VsdCB0eXBlIGFzIGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3JEYXRhLmRlZmF1bHRSZXN1bHRUeXBlID0gdGhpcy5yZXN1bHRUeXBlOyAvLyB0aGlzIHNldHMgYSBkZWZhdWx0IHJlc3VsdCB0eXBlIGZvciB0aGlzIHNlbGVjdGlvbi4gYW55IHRpbWUgeW91IGFkZCBhIGNvbHVtbiBpdCB3aWxsIGRlZmF1bHQgdGhpcyB0aGlzIHJlc3VsdFR5cGUuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodEJvcmRlci51cGRhdGVSZXN1bHRUeXBlKHRoaXMucmVzdWx0VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodEJvcmRlci51cGRhdGVXaW5kZXgocmVxdWVzdC53aW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmplY3RWMDIwMCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXF1ZXN0LnNlbGVjdG9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09IFwibXVsdGlwbGVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3JEYXRhLnNlbGVjdG9ycyA9IHJlcXVlc3Quc2VsZWN0b3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZSA9ICdtdWx0aXBsZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTZWxlY3Rpb25zKHRoaXMuc2VsZWN0b3JEYXRhLnNlbGVjdG9yc1t0aGlzLnNlbGVjdG9yRGF0YS5hY3RpdmVTZWxlY3RvckluZGV4XS5yZXN1bHRUeXBlLCB0aGlzLnNlbGVjdG9yRGF0YS5hY3RpdmVTZWxlY3RvckluZGV4LCBkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQXhpb21BcGlIZWxwZXJfMS5BeGlvbUFwaUhlbHBlci5hcHBseVRvSWZyYW1lcyhmdW5jdGlvbiAoaW5kZXgsIGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlU2VsZWN0aW9ucyhfdGhpcy5zZWxlY3RvckRhdGEuc2VsZWN0b3JzW190aGlzLnNlbGVjdG9yRGF0YS5hY3RpdmVTZWxlY3RvckluZGV4XS5yZXN1bHRUeXBlLCBfdGhpcy5zZWxlY3RvckRhdGEuYWN0aXZlU2VsZWN0b3JJbmRleCwgY29udGVudFswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kU3RhdGVVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yRGF0YS5zZWxlY3RvcnMgPSByZXF1ZXN0LnNlbGVjdG9ycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0SGlnaGxpZ2h0cyhkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQXhpb21BcGlIZWxwZXJfMS5BeGlvbUFwaUhlbHBlci5hcHBseVRvSWZyYW1lcyhmdW5jdGlvbiAoaW5kZXgsIGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVzZXRIaWdobGlnaHRzKGNvbnRlbnRbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NpbmdBY3Rpb24ocmVxdWVzdC53aWRnZXRfdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kUmVzcG9uc2UodGhpcy5zZWxlY3RvckRhdGEuc2VsZWN0b3JzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWplY3RWMDIwMCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVqZWN0VjAyMDAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZSA9IChyZXF1ZXN0LnNlbGVjdGlvblR5cGUgPT09ICdzbWFydCcgfHwgcmVxdWVzdC5zZWxlY3Rpb25UeXBlID09PSAnbXVsdGknKSA/ICdtdWx0aXBsZScgOiAnc2luZ2xlJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5qZWN0VjAyMDAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lamVjdFYwMjAwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsSGlnaGxpZ2h0cyhkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBBeGlvbUFwaUhlbHBlcl8xLkF4aW9tQXBpSGVscGVyLmFwcGx5VG9JZnJhbWVzKGZ1bmN0aW9uIChpbmRleCwgZG9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVtb3ZlQWxsSGlnaGxpZ2h0cyhkb2MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnNlbGVjdG9yRGF0YS5hY3Rpb25SZXF1ZXN0KHJlcXVlc3QpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ211bHRpcGxlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdG9yRGF0YS5yZWZyZXNoUmVxdWlyZWQgJiYgdGhpcy5zZWxlY3RvckRhdGEuc2VsZWN0b3JzW3RoaXMuc2VsZWN0b3JEYXRhLmFjdGl2ZVNlbGVjdG9ySW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsZWN0aW9ucyh0aGlzLnNlbGVjdG9yRGF0YS5zZWxlY3RvcnNbdGhpcy5zZWxlY3RvckRhdGEuYWN0aXZlU2VsZWN0b3JJbmRleF0ucmVzdWx0VHlwZSwgdGhpcy5zZWxlY3RvckRhdGEuYWN0aXZlU2VsZWN0b3JJbmRleCwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBeGlvbUFwaUhlbHBlcl8xLkF4aW9tQXBpSGVscGVyLmFwcGx5VG9JZnJhbWVzKGZ1bmN0aW9uIChpbmRleCwgY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlU2VsZWN0aW9ucyhfdGhpcy5zZWxlY3RvckRhdGEuc2VsZWN0b3JzW190aGlzLnNlbGVjdG9yRGF0YS5hY3RpdmVTZWxlY3RvckluZGV4XS5yZXN1bHRUeXBlLCBfdGhpcy5zZWxlY3RvckRhdGEuYWN0aXZlU2VsZWN0b3JJbmRleCwgY29udGVudFswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRTdGF0ZVVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0SGlnaGxpZ2h0cyhkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQXhpb21BcGlIZWxwZXJfMS5BeGlvbUFwaUhlbHBlci5hcHBseVRvSWZyYW1lcyhmdW5jdGlvbiAoaW5kZXgsIGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVzZXRIaWdobGlnaHRzKGNvbnRlbnRbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZFN0YXRlVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tZS5ydW50aW1lLnNlbmRNZXNzYWdlKHsgYWN0aW9uOiAnY2FuY2VsX3ByZXZpZXcnIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lamVjdFYwMjAwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Z2dlc3Rpb25zID0gdGhpcy5nZW5lcmF0ZVN1Z2dlc3Rpb25zKHJlcXVlc3Quc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKHsgc3VnZ2VzdGlvbnM6IHN1Z2dlc3Rpb25zIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlmcmFtZVN1cHBvcnRFbmFibGVkID0gcmVxdWVzdC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaWZyYW1lSGlnaGxpZ2h0Qm9yZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXRJZnJhbWVTdXBwb3J0RW5hYmxlZChyZXF1ZXN0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pOyB9KTtcbiAgICB9XG4gICAgSW5qZWN0ZWRTZWxlY3RvclRvb2wucHJvdG90eXBlLmdlbmVyYXRlU3VnZ2VzdGlvbnMgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKCFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gXCJoZWFkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0cztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaGFyZWRBdHRyaWJ1dGVzID0gW107XG4gICAgICAgIHZhciBjb21iaW5lZFNlbGVjdG9yID0gdGhpcy5oaWVyYXJjaHlBY3Rpb25zLmdldENvbWJpbmVkKGRvY3VtZW50LCBBcnJheS5mcm9tKHJlc3VsdHMpLCBbXSwgJ3NlbGVjdG9yJyk7XG4gICAgICAgIHNoYXJlZEF0dHJpYnV0ZXMucHVzaChjb21iaW5lZFNlbGVjdG9yKTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiByZXN1bHRzKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSByZXN1bHRzW2ldO1xuICAgICAgICAgICAgaWYgKHNoYXJlZEF0dHJpYnV0ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGVsLmF0dHJpYnV0ZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRyLm5hbWUgIT09IFwiY2xhc3NcIiAmJiBhdHRyLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFzID0gdGhpcy5jcmVhdGVBdHRyaWJ1dGVTZWxlY3RvcihhdHRyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50ZXN0R2VuZXJhdGVkU2VsZWN0b3IoYXMsIHJlc3VsdHMubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZWRBdHRyaWJ1dGVzLnB1c2goYXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBlbC5jbGFzc0xpc3Q7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IF9jW19iXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjLmluZGV4T2YoJ2F4aW9tJykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudGVzdEdlbmVyYXRlZFNlbGVjdG9yKFwiLlwiICsgYywgcmVzdWx0cy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlZEF0dHJpYnV0ZXMucHVzaChcIi5cIiArIGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2VnbWVudCBiYXNpY2FsbHkgcmVtb3ZlcyB0aGluZ3MgaW4gdGhlIGNhc2UgdGhhdCB0aGUgZmlyc3QgcmVzdWx0IGhhcHBlbmVkIHRvIGhhdmUgYSBsZW5ndGggbWF0Y2gsIGJ1dCBpdCBhY3R1YWxseSBkb2Vzbid0XG4gICAgICAgICAgICAgICAgLy8gaW5jbHVkZSBvbmUgb2YgdGhlIG9yaWdpbmFsbHkgc2VsZWN0ZWQgcmVzdWx0cyAoaW5zdGVhZCBpdCBpbmNsdWRlcyBzb21ldGhpbmcgZWxzZSkuXG4gICAgICAgICAgICAgICAgaWYgKGVsLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSAwLCBfZSA9IGVsLmF0dHJpYnV0ZXM7IF9kIDwgX2UubGVuZ3RoOyBfZCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IF9lW19kXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcyA9IHRoaXMuY3JlYXRlQXR0cmlidXRlU2VsZWN0b3IoYXR0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgc2FpIGluIHNoYXJlZEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcmVkQXR0cmlidXRlc1tzYWldID09PSBhcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHNhaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlZEF0dHJpYnV0ZXNbZm91bmRdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9mID0gMCwgX2cgPSBlbC5jbGFzc0xpc3Q7IF9mIDwgX2cubGVuZ3RoOyBfZisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IF9nW19mXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb3VuZCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaCA9IDAsIHNoYXJlZEF0dHJpYnV0ZXNfMSA9IHNoYXJlZEF0dHJpYnV0ZXM7IF9oIDwgc2hhcmVkQXR0cmlidXRlc18xLmxlbmd0aDsgX2grKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzYWkgPSBzaGFyZWRBdHRyaWJ1dGVzXzFbX2hdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaGFyZWRBdHRyaWJ1dGVzW3NhaV0gPT09IFwiLlwiICsgYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHNhaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVkQXR0cmlidXRlc1tmb3VuZF0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNoYXJlZEF0dHJpYnV0ZXMgPSBzaGFyZWRBdHRyaWJ1dGVzLmZpbHRlcihmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBlbCAhPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNoYXJlZEF0dHJpYnV0ZXM7XG4gICAgfTtcbiAgICBJbmplY3RlZFNlbGVjdG9yVG9vbC5wcm90b3R5cGUuY3JlYXRlQXR0cmlidXRlU2VsZWN0b3IgPSBmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICByZXR1cm4gJ1snICsgYXR0ci5uYW1lICsgXCI9J1wiICsgYXR0ci52YWx1ZSArIFwiJ11cIjtcbiAgICB9O1xuICAgIEluamVjdGVkU2VsZWN0b3JUb29sLnByb3RvdHlwZS50ZXN0R2VuZXJhdGVkU2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHRhcmdldExlbmd0aCkge1xuICAgICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgICAgcmV0dXJuIHIubGVuZ3RoID09PSB0YXJnZXRMZW5ndGg7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdGFydCBVc2luZyB0aGUgdG9vbFxuICAgICAqL1xuICAgIEluamVjdGVkU2VsZWN0b3JUb29sLnByb3RvdHlwZS5pbmplY3RWMDIwMCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5pbnVzZSA9IHRydWU7XG4gICAgICAgIHRoaXMuc2VsZWN0b3JEYXRhLnNlbGVjdG9ycyA9IFtdO1xuICAgICAgICB0aGlzLnNlbGVjdG9yRGF0YS5hY3RpdmVTZWxlY3RvckluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5oaWdobGlnaHRCb3JkZXIudXBkYXRlYWN0aXZlU2VsZWN0b3JJbmRleCgwKTtcbiAgICAgICAgdGhpcy5oaWdobGlnaHRCb3JkZXIuaW5qZWN0KCk7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICBqUXVlcnkoZG9jdW1lbnQpLm9uKCdtb3VzZWRvd24uYXhpb20tc2VsZWN0aW9uJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zaW5nbGVFbGVtZW50Q2xpY2tIYW5kbGVyKGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBBeGlvbUFwaUhlbHBlcl8xLkF4aW9tQXBpSGVscGVyLmFwcGx5VG9JZnJhbWVzKGZ1bmN0aW9uIChpbmRleCwgY29udGVudCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeShjb250ZW50WzBdKS5vbignbW91c2Vkb3duLmF4aW9tLXNlbGVjdGlvbicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNpbmdsZUVsZW1lbnRDbGlja0hhbmRsZXIoZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFkZGluZyByZXF1aXJlIHRoaW5ncyB0byB0aGUgcGFyZW50IHdpbmRvd1xuICAgICAgICAgICAgalF1ZXJ5KGRvY3VtZW50KS5vbignbW91c2Vkb3duLmF4aW9tLXNlbGVjdGlvbicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZWxlbWVudENsaWNrSGFuZGxlcihlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgQXhpb21BcGlIZWxwZXJfMS5BeGlvbUFwaUhlbHBlci5hcHBseVRvSWZyYW1lcyhmdW5jdGlvbiAoaW5kZXgsIGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkoY29udGVudFswXSkub24oJ21vdXNlZG93bi5heGlvbS1zZWxlY3Rpb24nLCBfdGhpcy5lbGVtZW50Q2xpY2tIYW5kbGVyLmJpbmQoX3RoaXMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlc3VsdFR5cGUgPT09ICdsaW5rJykge1xuICAgICAgICAgICAgalF1ZXJ5KCdhJykuYWRkQ2xhc3MoJ2F4aW9tLWxpbmsnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnJlc3VsdFR5cGUgPT09ICdheGlvbS1kb3dubG9hZCcpIHtcbiAgICAgICAgICAgIGpRdWVyeSgnYScpLmFkZENsYXNzKCdheGlvbS1kb3dubG9hZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaW5raW5nIHRoZSBjc3MgZmlsZSBmb3IgaGlnaGxpZ2h0aW5nIGFuZCBzdHVmZlxuICAgICAgICAgKi9cbiAgICAgICAgalF1ZXJ5KCdib2R5JykuYWRkQ2xhc3MoJ2F4aW9tLXNlbC1pbi1hY3Rpb24nKTtcbiAgICAgICAgLy8gQWRkaW5nIHRoZSByZXF1aXJlZCB0aGluZ3MgdG8gZWFjaCBzYW1lIG9yaWdpbiBpZnJhbWVcbiAgICAgICAgQXhpb21BcGlIZWxwZXJfMS5BeGlvbUFwaUhlbHBlci5hcHBseVRvSWZyYW1lcyhmdW5jdGlvbiAoaW5kZXgsIGNvbnRlbnQpIHtcbiAgICAgICAgICAgIGlmIChjb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmlmcmFtZUhpZ2hsaWdodEJvcmRlcnNbaW5kZXhdID0gbmV3IEJvcmRlckhpZ2hsaWdodF8xLkJvcmRlckhpZ2hsaWdodChjb250ZW50WzBdLCB0cnVlLCBfdGhpcy5pZnJhbWVTdXBwb3J0RW5hYmxlZCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuaWZyYW1lSGlnaGxpZ2h0Qm9yZGVyc1tpbmRleF0uaW5qZWN0KCk7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBjb250ZW50LmZpbmQoJ2JvZHknKTtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVzaGVldCA9IGNocm9tZS5ydW50aW1lLmdldFVSTChcImF4aW9tc2VsZWN0b3IuY3NzXCIpO1xuICAgICAgICAgICAgICAgIGJvZHkuYXBwZW5kKCc8bGluayByZWw9XCJzdHlsZXNoZWV0XCIgdHlwZT1cInRleHQvY3NzXCIgaHJlZj1cIicgKyBzdHlsZXNoZWV0ICsgJ1wiPicpO1xuICAgICAgICAgICAgICAgIGJvZHkuYWRkQ2xhc3MoJ2F4aW9tLXNlbC1pbi1hY3Rpb24nKTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVzdWx0VHlwZSA9PT0gJ2xpbmsnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQuZmluZCgnYScpLmFkZENsYXNzKCdheGlvbS1saW5rJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLnJlc3VsdFR5cGUgPT09ICdheGlvbS1kb3dubG9hZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudC5maW5kKCdhJykuYWRkQ2xhc3MoJ2F4aW9tLWRvd25sb2FkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluamVjdCBpbnRvIHNwZWNpZmljIGNsYXNzZXMgd2hlcmUgdHJhZGl0aW9uYWwgaW5qZWN0aW9uIGRvZXNuJ3Qgd29ya1xuICAgICAqXG4gICAgICogQHBhcmFtIG1vZGUgc3RyaW5nIHwgJ3NpbmdsZScsICdtdWx0aXBsZSdcbiAgICAgKi9cbiAgICBJbmplY3RlZFNlbGVjdG9yVG9vbC5wcm90b3R5cGUuaW5qZWN0SW50b1NwZWNpZmljQ2xhc3NlcyA9IGZ1bmN0aW9uIChtb2RlKSB7XG4gICAgICAgIHZhciBhbGdvcyA9IHtcbiAgICAgICAgICAgICdzaW5nbGUnOiB0aGlzLnNpbmdsZUVsZW1lbnRDbGlja0hhbmRsZXIuYmluZCh0aGlzKSxcbiAgICAgICAgICAgICdtdWx0aXBsZSc6IHRoaXMuZWxlbWVudENsaWNrSGFuZGxlci5iaW5kKHRoaXMpXG4gICAgICAgIH07XG4gICAgICAgIGpRdWVyeSgnLmM5LW1lbnUtYnRuJykub24oJ21vdXNlZG93bi5heGlvbS1zZWxlY3Rpb24nLCBhbGdvc1ttb2RlXSk7XG4gICAgfTtcbiAgICBJbmplY3RlZFNlbGVjdG9yVG9vbC5wcm90b3R5cGUuZWplY3RGcm9tU3BlY2lmaWNDbGFzc2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBqUXVlcnkoJy5jOS1tZW51LWJ0bicpLm9mZignbW91c2Vkb3duLmF4aW9tLXNlbGVjdG9yJyk7XG4gICAgfTtcbiAgICBJbmplY3RlZFNlbGVjdG9yVG9vbC5wcm90b3R5cGUudXBkYXRlU2VsZWN0aW9ucyA9IGZ1bmN0aW9uIChhY3RpdmVSZXN1bHRUeXBlLCBhY3RpdmVTZWxlY3RvckluZGV4LCBkb2MpIHtcbiAgICAgICAgdGhpcy5oaWdobGlnaHRCb3JkZXIudXBkYXRlUmVzdWx0VHlwZShhY3RpdmVSZXN1bHRUeXBlKTtcbiAgICAgICAgdGhpcy5oaWdobGlnaHRCb3JkZXIudXBkYXRlYWN0aXZlU2VsZWN0b3JJbmRleChhY3RpdmVTZWxlY3RvckluZGV4KTtcbiAgICAgICAgdGhpcy51cGRhdGVBY3RpdmVSZXN1bHRUeXBlKCk7XG4gICAgICAgIHRoaXMuZmluZE1hdGNoZXNWMDE5MChkb2MpOyAvLyBUT0RPOiBzcGxpdCBpbnRvIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgdGhpcy5zZXRIaWdobGlnaHRzKGRvYyk7XG4gICAgfTtcbiAgICBJbmplY3RlZFNlbGVjdG9yVG9vbC5wcm90b3R5cGUudXBkYXRlQWN0aXZlUmVzdWx0VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZXN1bHRUeXBlID0gdGhpcy5zZWxlY3RvckRhdGEuc2VsZWN0b3JzW3RoaXMuc2VsZWN0b3JEYXRhLmFjdGl2ZVNlbGVjdG9ySW5kZXhdLnJlc3VsdFR5cGU7XG4gICAgICAgIC8vIHJlbW92ZSBvbGQgcmVzdWx0IHR5cGUgZGVwZW5kYW50IGNsYXNzZXNcbiAgICAgICAgalF1ZXJ5KCdhJykucmVtb3ZlQ2xhc3MoJ2F4aW9tLWxpbmsnKTtcbiAgICAgICAgalF1ZXJ5KCdhJykucmVtb3ZlQ2xhc3MoJ2F4aW9tLWRvd25sb2FkJyk7XG4gICAgICAgIC8vIGFkZCBjdXJyZW50IHJlc3VsdCB0eXBlIGRlcGVuZGFudCBjbGFzc2VzXG4gICAgICAgIGlmICh0aGlzLnJlc3VsdFR5cGUgPT09ICdsaW5rJykge1xuICAgICAgICAgICAgalF1ZXJ5KCdhJykuYWRkQ2xhc3MoJ2F4aW9tLWxpbmsnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnJlc3VsdFR5cGUgPT09ICdheGlvbS1kb3dubG9hZCcpIHtcbiAgICAgICAgICAgIGpRdWVyeSgnYScpLmFkZENsYXNzKCdheGlvbS1kb3dubG9hZCcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmplY3RlZFNlbGVjdG9yVG9vbC5wcm90b3R5cGUuc2VuZFN0YXRlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbXNnID0ge1xuICAgICAgICAgICAgYWN0aW9uOiBcInVwZGF0ZV9zdGF0ZVwiLFxuICAgICAgICAgICAgcHJldmlld19kYXRhOiB0aGlzLm1hdGNoaW5nRGF0YSxcbiAgICAgICAgICAgIHNlbGVjdG9yczogdGhpcy5zZWxlY3RvckRhdGEuc2VsZWN0b3JzLFxuICAgICAgICAgICAgYWN0aXZlU2VsZWN0b3JJbmRleDogdGhpcy5zZWxlY3RvckRhdGEuYWN0aXZlU2VsZWN0b3JJbmRleCxcbiAgICAgICAgICAgIGdyb3VwU2VsZWN0b3I6IHRoaXMuc2NyYXBlSGVscGVyLmdyb3VwU2VsZWN0b3JcbiAgICAgICAgfTtcbiAgICAgICAgY2hyb21lLnJ1bnRpbWUuc2VuZE1lc3NhZ2UobXNnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERpc2FibGVzIHRoZSB1c2FnZSBvZiB0aGUgdG9vbFxuICAgICAqL1xuICAgIEluamVjdGVkU2VsZWN0b3JUb29sLnByb3RvdHlwZS5lamVjdFYwMjAwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBqUXVlcnkoZG9jdW1lbnQpLm9mZignbW91c2Vkb3duLmF4aW9tLXNlbGVjdGlvbicpO1xuICAgICAgICBqUXVlcnkoJ2JvZHknKS5yZW1vdmVDbGFzcygnYXhpb20tc2VsLWluLWFjdGlvbicpO1xuICAgICAgICB0aGlzLnJlbW92ZUFsbEhpZ2hsaWdodHMoZG9jdW1lbnQpO1xuICAgICAgICB2YXIgZ3JvdXBTdHlsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdheGlvbS1ncm91cC1zdHlsZScpO1xuICAgICAgICBpZiAoZ3JvdXBTdHlsZSkge1xuICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZChncm91cFN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRCb3JkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0Qm9yZGVyLmVqZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgalF1ZXJ5KCdhJykucmVtb3ZlQ2xhc3MoJ2F4aW9tLWxpbmsnKTtcbiAgICAgICAgQXhpb21BcGlIZWxwZXJfMS5BeGlvbUFwaUhlbHBlci5hcHBseVRvSWZyYW1lcyhmdW5jdGlvbiAoaW5kZXgsIGNvbnRlbnQpIHtcbiAgICAgICAgICAgIGpRdWVyeShjb250ZW50WzBdKS5vZmYoJ21vdXNlZG93bi5heGlvbS1zZWxlY3Rpb24nKTtcbiAgICAgICAgICAgIF90aGlzLnJlbW92ZUFsbEhpZ2hsaWdodHMoY29udGVudFswXSk7XG4gICAgICAgICAgICB2YXIgYm9keSA9IGNvbnRlbnQuZmluZCgnYm9keScpO1xuICAgICAgICAgICAgalF1ZXJ5KGJvZHkpLnJlbW92ZUNsYXNzKCdheGlvbS1zZWwtaW4tYWN0aW9uJyk7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaWZyYW1lSGlnaGxpZ2h0Qm9yZGVyc1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5pZnJhbWVIaWdobGlnaHRCb3JkZXJzW2luZGV4XS5lamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGdyb3VwU3R5bGUgPSBjb250ZW50WzBdLmdldEVsZW1lbnRCeUlkKCdheGlvbS1ncm91cC1zdHlsZScpO1xuICAgICAgICAgICAgaWYgKGdyb3VwU3R5bGUpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50WzBdLmhlYWQucmVtb3ZlQ2hpbGQoZ3JvdXBTdHlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZW50LmZpbmQoJ2EnKS5yZW1vdmVDbGFzcygnYXhpb20tbGluaycpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pbnVzZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlbGVjdG9yRGF0YS5zZWxlY3RvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5tYXRjaGluZyA9IFtdO1xuICAgICAgICB0aGlzLm1hdGNoaW5nRGF0YSA9IFtdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgdGhlIHVzYWdlIG9mIHRoZSB0b29sXG4gICAgICovXG4gICAgSW5qZWN0ZWRTZWxlY3RvclRvb2wucHJvdG90eXBlLmVqZWN0VjAxOTAgPSBmdW5jdGlvbiAoZG9jKSB7XG4gICAgICAgIHRoaXMuZWplY3RGcm9tU3BlY2lmaWNDbGFzc2VzKCk7XG4gICAgICAgIGpRdWVyeShkb2N1bWVudCkub2ZmKCdtb3VzZWRvd24uYXhpb20tc2VsZWN0aW9uJyk7XG4gICAgICAgIGpRdWVyeSgnYm9keScpLnJlbW92ZUNsYXNzKCdheGlvbS1zZWwtaW4tYWN0aW9uJyk7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsSGlnaGxpZ2h0cyhkb2MpO1xuICAgICAgICB0aGlzLmludXNlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2VsZWN0b3JEYXRhLnNlbGVjdG9ycyA9IFtdO1xuICAgICAgICB0aGlzLm1hdGNoaW5nID0gW107XG4gICAgICAgIHRoaXMubWF0Y2hpbmdEYXRhID0gW107XG4gICAgICAgIHZhciBncm91cFN0eWxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2F4aW9tLWdyb3VwLXN0eWxlJyk7XG4gICAgICAgIGlmIChncm91cFN0eWxlKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5oZWFkLnJlbW92ZUNoaWxkKGdyb3VwU3R5bGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodEJvcmRlcikge1xuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRCb3JkZXIuZWplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBqUXVlcnkoJ2EnKS5yZW1vdmVDbGFzcygnYXhpb20tbGluaycpO1xuICAgICAgICBqUXVlcnkoJ2EnKS5yZW1vdmVDbGFzcygnYXhpb20tZG93bmxvYWQnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgSW5qZWN0ZWRTZWxlY3RvclRvb2wucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uIChkb2MpIHtcbiAgICAgICAgdGhpcy5pbnVzZSA9IHRydWU7XG4gICAgICAgIGpRdWVyeSgnYm9keScpLmFkZENsYXNzKCdheGlvbS1zZWwtaW4tYWN0aW9uJyk7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0Qm9yZGVyLnNldHVwQm9yZGVyKCk7XG4gICAgICAgIC8vIHJlbW92ZSBhbGwgc2VsZWN0aW9uIGFzIHRoaXMgaXMgYSBicmFuZCBuZXcgc2VsZWN0aW9uXG4gICAgICAgIHRoaXMucmVzZXRIaWdobGlnaHRzKGRvYyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGhpZ2hsaWdodHNcbiAgICAgKi9cbiAgICBJbmplY3RlZFNlbGVjdG9yVG9vbC5wcm90b3R5cGUucmVzZXRIaWdobGlnaHRzID0gZnVuY3Rpb24gKGRvYykge1xuICAgICAgICB0aGlzLnJlbW92ZUFsbEhpZ2hsaWdodHMoZG9jKTtcbiAgICAgICAgdGhpcy5zZXRIaWdobGlnaHRzKGRvYyk7XG4gICAgfTtcbiAgICBJbmplY3RlZFNlbGVjdG9yVG9vbC5wcm90b3R5cGUuc2V0SGlnaGxpZ2h0cyA9IGZ1bmN0aW9uIChkb2MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0b3JEYXRhLnNlbGVjdG9ycy5sZW5ndGggJiYgdGhpcy5zZWxlY3Rpb25Nb2RlID09PSAnbXVsdGlwbGUnKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0b3JzID0gdGhpcy5zZWxlY3RvckRhdGEuc2VsZWN0b3JzLm1hcChmdW5jdGlvbiAoc2VsZWN0b3JPYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdG9yT2JqLmlzVG9rZW4gJiYgdHlwZW9mIHNlbGVjdG9yT2JqLnNlbGVjdG9yID09PSAnc3RyaW5nJyAmJiBzZWxlY3Rvck9iai5zZWxlY3RvciAhPT0gJ2hlYWQnICYmIC9cXFMvLnRlc3Qoc2VsZWN0b3JPYmouc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3Rvck9iai5zZWxlY3RvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yT2JqLnNlbGVjdG9yLmhpZXJhcmNoeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0b3JPYmouc2VsZWN0b3IuaGllcmFyY2h5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAocykgeyByZXR1cm4gISFzOyB9KTtcbiAgICAgICAgICAgIHZhciBjb21iaW5lZFNlbGVjdG9yID0gc2VsZWN0b3JzLmpvaW4oJywgJyk7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb21iaW5lZFNlbGVjdG9yID09PSAnc3RyaW5nJyAmJiAvXFxTLy50ZXN0KGNvbWJpbmVkU2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlcyA9IEFycmF5LmZyb20oZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoY29tYmluZWRTZWxlY3RvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgICAgIGlmIChzID09PSB0aGlzXzEuc2VsZWN0b3JEYXRhLmFjdGl2ZVNlbGVjdG9ySW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXNfMS5zZWxlY3RvckRhdGEuc2VsZWN0b3JzW3RoaXNfMS5zZWxlY3RvckRhdGEuYWN0aXZlU2VsZWN0b3JJbmRleF0uc2VsZWN0ZWRFbGVtZW50czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbC5jbGFzc0xpc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCh0aGlzXzEuc2VsZWN0aW5nQ2xhc3MgKyB0aGlzXzEuc2VsZWN0b3JEYXRhLmFjdGl2ZVNlbGVjdG9ySW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSB0aGlzXzEuc2VsZWN0b3JEYXRhLnNlbGVjdG9yc1t0aGlzXzEuc2VsZWN0b3JEYXRhLmFjdGl2ZVNlbGVjdG9ySW5kZXhdLnJlamVjdGVkRWxlbWVudHM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSBfY1tfYl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWwuY2xhc3NMaXN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQodGhpc18xLnJlamVjdGluZ0NsYXNzICsgdGhpc18xLnNlbGVjdG9yRGF0YS5hY3RpdmVTZWxlY3RvckluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3JzW3NdICYmIC9cXFMvZy50ZXN0KHNlbGVjdG9yc1tzXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoaW5nRWxzID0gQXJyYXkuZnJvbShkb2MucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcnNbc10pKTsgLy8gVE9ETzogZ2V0IGNvbWJpbmVkIHNlbGVjdG9yIGZyb20gc2VsZWN0ZWRFbHNcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmdFbHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghL2F4aW9tLXNlbC1zZWxlY3RlZC1cXFMqfGF4aW9tLXNlbC1yZWplY3RlZC1cXFMqL2cudGVzdChlbC5jbGFzc05hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChfdGhpcy5zdWdnZXN0aW5nQ2xhc3MgKyBzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xuICAgICAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBzZWxlY3RvcnMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgICAgICBfbG9vcF8xKHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBtYXRjaGVzXzEgPSBtYXRjaGVzOyBfaSA8IG1hdGNoZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBtYXRjaGVzXzFbX2ldO1xuICAgICAgICAgICAgICAgIGpRdWVyeShlbCkuYWRkQ2xhc3MoJ2F4aW9tLW1hdGNoZWQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVNlbGVjdGVkQ2hpbGRyZW4oZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICAgIHZhciBzZWwgPSB0aGlzLnNlbGVjdG9yRGF0YS5zZWxlY3RvcnNbMF0uc2VsZWN0b3I7XG4gICAgICAgICAgICB2YXIgZWwgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoc2VsLmhpZXJhcmNoeSkge1xuICAgICAgICAgICAgICAgIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLnNlbGVjdG9yRGF0YS5zZWxlY3RvcnNbMF0uc2VsZWN0b3IuaGllcmFyY2h5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbC5pbm5lclRleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgeHBhdGggPSBcIi8vKlt0ZXh0KCk9J1wiICsgc2VsLmlubmVyVGV4dCArIFwiJ11cIjtcbiAgICAgICAgICAgICAgICBlbCA9IGRvY3VtZW50LmV2YWx1YXRlKHhwYXRoLCBkb2N1bWVudCwgbnVsbCwgWFBhdGhSZXN1bHQuRklSU1RfT1JERVJFRF9OT0RFX1RZUEUsIG51bGwpLnNpbmdsZU5vZGVWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGpRdWVyeShlbCkuYWRkQ2xhc3MoJ2F4aW9tLW1hdGNoZWQnKTtcbiAgICAgICAgICAgIGpRdWVyeShlbCkuYWRkQ2xhc3MoJ2F4aW9tLXNlbC1zZWxlY3RlZC0wJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdyb3VwU3R5bGUgPSBkb2MuZ2V0RWxlbWVudEJ5SWQoJ2F4aW9tLWdyb3VwLXN0eWxlJyk7XG4gICAgICAgIGlmICghZ3JvdXBTdHlsZSkge1xuICAgICAgICAgICAgZ3JvdXBTdHlsZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICAgICAgZ3JvdXBTdHlsZS5pZCA9ICdheGlvbS1ncm91cC1zdHlsZSc7XG4gICAgICAgICAgICBkb2MuaGVhZC5hcHBlbmRDaGlsZChncm91cFN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zY3JhcGVIZWxwZXIuZ3JvdXBTZWxlY3RvciAhPT0gdW5kZWZpbmVkICYmIHRoaXMuc2NyYXBlSGVscGVyLmdyb3VwU2VsZWN0b3IgIT09ICcnICYmIHRoaXMuc2NyYXBlSGVscGVyLmdyb3VwU2VsZWN0b3IgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgZ3JvdXBTdHlsZS5pbm5lckhUTUwgPSB0aGlzLnNjcmFwZUhlbHBlci5ncm91cFNlbGVjdG9yICsgXCIge1xcbiAgICAgICAgICAgICAgICBib3JkZXItc3R5bGU6IGRvdHRlZCAhaW1wb3J0YW50O1xcbiAgICAgICAgICAgICAgICBib3JkZXItd2lkdGg6IDNweCAhaW1wb3J0YW50O1xcbiAgICAgICAgICAgICAgICBib3JkZXItY29sb3I6ICNGRkMxMDcgIWltcG9ydGFudDtcXG4gICAgICAgICAgICAgICAgcGFkZGluZzogNXB4ICFpbXBvcnRhbnQ7XFxuICAgICAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDEwcHggIWltcG9ydGFudDtcXG4gICAgICAgICAgICB9XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBncm91cFN0eWxlLmlubmVySFRNTCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdGhlclNlbGVjdG9ycyA9IFwiXFxuICAgICAgICBbY2xhc3MqPVxcXCJcIiArIHRoaXMuc2VsZWN0aW5nQ2xhc3MgKyBcIlxcXCJdLmF4aW9tLW1hdGNoZWQgIHtcXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDE1MywgMjU1LCAwLjcpICFpbXBvcnRhbnRcXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWltYWdlOiBub25lICFpbXBvcnRhbnQ7XFxuICAgICAgICB9XFxuICAgICAgICBbY2xhc3MqPVxcXCJcIiArIHRoaXMuc3VnZ2VzdGluZ0NsYXNzICsgXCJcXFwiXS5heGlvbS1tYXRjaGVkICB7XFxuICAgICAgICAgICAgYmFja2dyb3VuZDogcmdiYSgwLCAxNTMsIDI1NSwgMC4zKSAhaW1wb3J0YW50O1xcbiAgICAgICAgICAgIGJhY2tncm91bmQtaW1hZ2U6IG5vbmUgIWltcG9ydGFudDtcXG4gICAgICAgIH1cXG4gICAgICAgIFxcbiAgICAgICAgW2NsYXNzKj1cXFwiXCIgKyB0aGlzLnNlbGVjdGluZ0NsYXNzICsgXCJcXFwiXTpub3QoLmF4aW9tLW1hdGNoZWQpICB7XFxuICAgICAgICAgICAgYmFja2dyb3VuZDogcmdiYSgxNTMsIDE1MywgMTUzLCAwLjcpICFpbXBvcnRhbnRcXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWltYWdlOiBub25lICFpbXBvcnRhbnQ7XFxuICAgICAgICB9XFxuICAgICAgICBbY2xhc3MqPVxcXCJcIiArIHRoaXMuc3VnZ2VzdGluZ0NsYXNzICsgXCJcXFwiXTpub3QoLmF4aW9tLW1hdGNoZWQpICB7XFxuICAgICAgICAgICAgYmFja2dyb3VuZDogcmdiYSgxNTMsIDE1MywgMTUzLCAwLjMpICFpbXBvcnRhbnQ7XFxuICAgICAgICAgICAgYmFja2dyb3VuZC1pbWFnZTogbm9uZSAhaW1wb3J0YW50O1xcbiAgICAgICAgfVwiO1xuICAgICAgICB2YXIgYWN0aXZlU2VsZWN0b3IgPSBcIlxcbiAgICAgICAgW2NsYXNzfj1cXFwiXCIgKyAodGhpcy5zZWxlY3RpbmdDbGFzcyArIHRoaXMuc2VsZWN0b3JEYXRhLmFjdGl2ZVNlbGVjdG9ySW5kZXgpICsgXCJcXFwiXS5heGlvbS1tYXRjaGVkICB7XFxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0ZGQzEwNyAhaW1wb3J0YW50O1xcbiAgICAgICAgICAgIGJhY2tncm91bmQtaW1hZ2U6IG5vbmUgIWltcG9ydGFudDtcXG4gICAgICAgIH1cXG4gICAgICAgIFtjbGFzc349XFxcIlwiICsgKHRoaXMuc3VnZ2VzdGluZ0NsYXNzICsgdGhpcy5zZWxlY3RvckRhdGEuYWN0aXZlU2VsZWN0b3JJbmRleCkgKyBcIlxcXCJdLmF4aW9tLW1hdGNoZWQgIHtcXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZkOThjICFpbXBvcnRhbnQ7IFxcbiAgICAgICAgICAgIGJhY2tncm91bmQtaW1hZ2U6IG5vbmUgIWltcG9ydGFudDtcXG4gICAgICAgIH1cXG4gICAgICAgIFxcbiAgICAgICAgW2NsYXNzfj1cXFwiXCIgKyAodGhpcy5zZWxlY3RpbmdDbGFzcyArIHRoaXMuc2VsZWN0b3JEYXRhLmFjdGl2ZVNlbGVjdG9ySW5kZXgpICsgXCJcXFwiXTpub3QoLmF4aW9tLW1hdGNoZWQpICB7XFxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxOTMsMTkzLDE5MywgMC43KSAhaW1wb3J0YW50O1xcbiAgICAgICAgICAgIGJhY2tncm91bmQtaW1hZ2U6IG5vbmUgIWltcG9ydGFudDtcXG4gICAgICAgIH1cXG4gICAgICAgIFtjbGFzc349XFxcIlwiICsgKHRoaXMuc3VnZ2VzdGluZ0NsYXNzICsgdGhpcy5zZWxlY3RvckRhdGEuYWN0aXZlU2VsZWN0b3JJbmRleCkgKyBcIlxcXCJdOm5vdCguYXhpb20tbWF0Y2hlZCkgIHtcXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE5MywxOTMsMTkzLCAwLjMpICFpbXBvcnRhbnQ7IFxcbiAgICAgICAgICAgIGJhY2tncm91bmQtaW1hZ2U6IG5vbmUgIWltcG9ydGFudDtcXG4gICAgICAgIH1cIjtcbiAgICAgICAgZ3JvdXBTdHlsZS5pbm5lckhUTUwgKz0gb3RoZXJTZWxlY3RvcnM7XG4gICAgICAgIGdyb3VwU3R5bGUuaW5uZXJIVE1MICs9IGFjdGl2ZVNlbGVjdG9yO1xuICAgIH07XG4gICAgSW5qZWN0ZWRTZWxlY3RvclRvb2wucHJvdG90eXBlLmdldFNlbGVjdG9yID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuU2VsZWN0b3JBbGdvcml0aG0uZ2V0U2VsZWN0b3IoZWxlbWVudCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIFwiJ2F4aW9tLXNlbC1zZWxlY3RlZC0nICsgbnVtYmVyXCIgZm9yIHRoZSBzZWxlY3Rpb24gdGhhdCBoYXMgYmVlbiBjbGlja2VkXG4gICAgICpcbiAgICAgKi9cbiAgICBJbmplY3RlZFNlbGVjdG9yVG9vbC5wcm90b3R5cGUuc2V0Q2xhc3NGb3JTZWxlY3RlZCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKHRoaXMuc2VsZWN0aW5nQ2xhc3MgKyB0aGlzLnNlbGVjdG9yRGF0YS5hY3RpdmVTZWxlY3RvckluZGV4KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBcIidheGlvbS1zZWwtc2VsZWN0ZWQtJyArIG51bWJlclwiIGZvciB0aGUgc2VsZWN0aW9uIHRoYXQgaGFzIGJlZW4gY2xpY2tlZFxuICAgICAqXG4gICAgICovXG4gICAgSW5qZWN0ZWRTZWxlY3RvclRvb2wucHJvdG90eXBlLnJlbW92ZUNsYXNzRm9yU2VsZWN0ZWQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLnNlbGVjdGluZ0NsYXNzICsgdGhpcy5zZWxlY3RvckRhdGEuYWN0aXZlU2VsZWN0b3JJbmRleCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuICAgIEluamVjdGVkU2VsZWN0b3JUb29sLnByb3RvdHlwZS5yZW1vdmVDbGFzc0ZvclJlamVjdGVkID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5yZWplY3RpbmdDbGFzcyArIHRoaXMuc2VsZWN0b3JEYXRhLmFjdGl2ZVNlbGVjdG9ySW5kZXgpO1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIFwiJ2F4aW9tLXNlbC1zdWdnZXN0ZWQtJyArIG51bWJlclwiIGZvciBhY3RpdmUgc2VsZWN0b3IncyBjYW5kaWRhdGUgc2VsZWN0aW9uc1xuICAgICAqXG4gICAgICovXG4gICAgSW5qZWN0ZWRTZWxlY3RvclRvb2wucHJvdG90eXBlLnNldENsYXNzRm9yU3VnZ2VzdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2xzID0gdGhpcy5zdWdnZXN0aW5nQ2xhc3MgKyB0aGlzLnNlbGVjdG9yRGF0YS5hY3RpdmVTZWxlY3RvckluZGV4O1xuICAgICAgICB0aGlzLm1hdGNoaW5nLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBpZiAoIS9heGlvbS1zZWwtc2VsZWN0ZWQtXFxTKnxheGlvbS1zZWwtcmVqZWN0ZWQtXFxTKi9nLnRlc3QoZWwuY2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGNsYXNzZXMgd2hpY2ggYXJlIGluamVjdGVkIGZvciB0aGUgaGlnaGxpZ2h0aW5nIHB1cnBvc2VzXG4gICAgICovXG4gICAgSW5qZWN0ZWRTZWxlY3RvclRvb2wucHJvdG90eXBlLnJlbW92ZUFsbEhpZ2hsaWdodHMgPSBmdW5jdGlvbiAoZG9jKSB7XG4gICAgICAgIGlmICghdGhpcy5zZWxlY3RvckRhdGEuc2VsZWN0b3JzIHx8IHRoaXMuc2VsZWN0b3JEYXRhLnNlbGVjdG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHRoaXMuc2VsZWN0b3JEYXRhLnNlbGVjdG9ycy5sZW5ndGg7IHMrKykge1xuICAgICAgICAgICAgalF1ZXJ5KGRvYykuZmluZCgnKicpLnJlbW92ZUNsYXNzKFwiYXhpb20tc2VsLXNlbGVjdGVkLVwiICsgcyk7XG4gICAgICAgICAgICBqUXVlcnkoZG9jKS5maW5kKCcqJykucmVtb3ZlQ2xhc3MoXCJheGlvbS1zZWwtc3VnZ2VzdGVkLVwiICsgcyk7XG4gICAgICAgICAgICBqUXVlcnkoZG9jKS5maW5kKCcqJykucmVtb3ZlQ2xhc3MoXCJheGlvbS1zZWwtcmVqZWN0ZWQtXCIgKyBzKTtcbiAgICAgICAgICAgIGpRdWVyeShkb2MpLmZpbmQoJyonKS5yZW1vdmVDbGFzcyhcImF4aW9tLW1hdGNoZWRcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhpZ2hsaWdodHMgdGhlIHRoZSBjdXJyZW50IHNlbGVjdG9yc1xuICAgICAqL1xuICAgIEluamVjdGVkU2VsZWN0b3JUb29sLnByb3RvdHlwZS5oaWdobGlnaHRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICdtdWx0aXBsZScpIHtcbiAgICAgICAgICAgIHZhciBzZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMuc2VsZWN0aW5nQ2xhc3MgKyB0aGlzLnNlbGVjdG9yRGF0YS5hY3RpdmVTZWxlY3RvckluZGV4KTtcbiAgICAgICAgICAgIHZhciBzdWcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMuc3VnZ2VzdGluZ0NsYXNzICsgdGhpcy5zZWxlY3RvckRhdGEuYWN0aXZlU2VsZWN0b3JJbmRleCk7XG4gICAgICAgICAgICB2YXIgcmVnID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0aGlzLnJlamVjdGluZ0NsYXNzICsgdGhpcy5zZWxlY3RvckRhdGEuYWN0aXZlU2VsZWN0b3JJbmRleCk7XG4gICAgICAgICAgICBzZWwuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKF90aGlzLnNlbGVjdGluZ0NsYXNzICsgX3RoaXMuc2VsZWN0b3JEYXRhLmFjdGl2ZVNlbGVjdG9ySW5kZXgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdWcuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKF90aGlzLnN1Z2dlc3RpbmdDbGFzcyArIF90aGlzLnNlbGVjdG9yRGF0YS5hY3RpdmVTZWxlY3RvckluZGV4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVnLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChfdGhpcy5yZWplY3RpbmdDbGFzcyArIF90aGlzLnNlbGVjdG9yRGF0YS5hY3RpdmVTZWxlY3RvckluZGV4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5zZWxlY3RpbmdDbGFzcyArIHRoaXMuc2VsZWN0b3JEYXRhLmFjdGl2ZVNlbGVjdG9ySW5kZXgpO1xuICAgICAgICAgICAgc2VsLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChfdGhpcy5zZWxlY3RpbmdDbGFzcyArIF90aGlzLnNlbGVjdG9yRGF0YS5hY3RpdmVTZWxlY3RvckluZGV4KTtcbiAgICAgICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdheGlvbS1tYXRjaGVkJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5qZWN0ZWRTZWxlY3RvclRvb2wucHJvdG90eXBlLmZpbmRNYXRjaGVzVjAxOTAgPSBmdW5jdGlvbiAoZG9jKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICdtdWx0aXBsZScpIHtcbiAgICAgICAgICAgIHZhciBuZXdEYXRhID0gW107XG4gICAgICAgICAgICB0aGlzLm1hdGNoaW5nID0gW107IC8vIFRPRE86IENoZWNrIHdoYXQgdGhpcyBpcyBhY3R1YWxseSBkb2luZy4gSXQncyBuZXZlciBjaGVja2VkIGFueXdoZXJlIEkgY2FuIHNlZSwganVzdCBzZXQuXG4gICAgICAgICAgICB2YXIgc2VsZWN0b3JzID0gdGhpcy5zZWxlY3RvckRhdGEuc2VsZWN0b3JzLmZpbHRlcihmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygcy5zZWxlY3RvciA9PT0gJ3N0cmluZyc7XG4gICAgICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocy5pc1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImhlYWRcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzLnNlbGVjdG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHNlbGVjdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXN1bHRUeXBlc1swXSA9PT0gJ2F4aW9tLWRvd25sb2FkJyAmJiBzZWxlY3RvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RhdGEgPSBBcnJheS5mcm9tKGRvYy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yc1swXSkpLm1hcChmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIFtlbC5vdXRlckhUTUxdOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gYWN0aW9uIHJlcXVpcmVkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGEgPSB0aGlzLnNjcmFwZUhlbHBlci5nZXRQcmV2aWV3KGRvYywgc2VsZWN0b3JzLCB0aGlzLnNlbGVjdG9yRGF0YS5zZWxlY3RvcnMubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnJlc3VsdFR5cGU7IH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdEYXRhID0gQXhpb21BcGlIZWxwZXJfMS5BeGlvbUFwaUhlbHBlci50cmFuc3Bvc2UobmV3RGF0YSk7XG4gICAgICAgICAgICBpZiAobmV3RGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbiBpbiBuZXdEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBza2lwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdEYXRhW25dICYmIG5ld0RhdGFbbl0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IG5ld0RhdGFbbl07IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPT09IFwiTk8gTUFUQ0hJTkcgRUxFTUVOVFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFza2lwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoaW5nRGF0YVtuXSA9IG5ld0RhdGFbbl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaXggYW55IGhvbGVzIGluIHRoZSBkYXRhXG4gICAgICAgICAgICBpZiAoc2VsZWN0b3JzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBGaXJzdCwgZGV0ZXJtaW5lIHRoZSBtYXggbnVtYmVyIG9mIGNvbHVtbnNcbiAgICAgICAgICAgICAgICB2YXIgbWF4Q29scyA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1hdGNoaW5nRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaGluZ0RhdGFbaV0gJiYgbWF4Q29scyA8IHRoaXMubWF0Y2hpbmdEYXRhW2ldLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4Q29scyA9IHRoaXMubWF0Y2hpbmdEYXRhW2ldLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGVuIGZpbGwgaW4gdGhlIGdhcHMhXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoaXNMZW4gPSB0aGlzLm1hdGNoaW5nRGF0YVtpXSA/IHRoaXMubWF0Y2hpbmdEYXRhW2ldLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzTGVuIDwgbWF4Q29scykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IHRoaXNMZW47IGogPCBtYXhDb2xzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2hpbmdEYXRhW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hpbmdEYXRhW2ldID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hpbmdEYXRhW2ldLnB1c2goJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVHJpbSBtYXRjaGluZyBkYXRhIHRvIG1heGltdW0gc2VsZWN0b3IgbGVuZ3RoXG4gICAgICAgICAgICBpZiAodGhpcy5tYXRjaGluZ0RhdGEubGVuZ3RoID4gc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hpbmdEYXRhID0gdGhpcy5tYXRjaGluZ0RhdGEuc2xpY2UoMCwgc2VsZWN0b3JzLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGb3IgYW55IHRva2VucywganVzdCBhZGQgdGhlIHRva2VuIG5hbWUgaW50byB0aGUgbWF0Y2hpbmcgZGF0YS5cbiAgICAgICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgdGhpcy5zZWxlY3RvckRhdGEuc2VsZWN0b3JzLmxlbmd0aDsgcysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbCA9IHRoaXMuc2VsZWN0b3JEYXRhLnNlbGVjdG9yc1tzXTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsLmlzVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaGluZ0RhdGFbc11bMF0gPSBzZWwuc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmplY3RlZFNlbGVjdG9yVG9vbC5wcm90b3R5cGUuYmxvY2tDbGlja3NPbiA9IGZ1bmN0aW9uIChkb2MpIHtcbiAgICAgICAgLy8gQmxvY2sgdGhlIGVudGlyZSBzY3JlZW4gdG8gcHJldmVudCBhbnl0aGluZyBlbHNlIGZyb20gYmVpbmcgY2xpY2tlZC4gQW1hemluZyB0aGlzIHdvcmtzIHJlYWxseSFcbiAgICAgICAgdmFyIGJsb2NrID0galF1ZXJ5KCc8ZGl2PicpLmNzcygncG9zaXRpb24nLCAnZml4ZWQnKS5jc3MoJ3otaW5kZXgnLCAnOTk5OTk5OScpLlxuICAgICAgICAgICAgY3NzKCd3aWR0aCcsICcxMDAwMHB4JykuY3NzKCdoZWlnaHQnLCAnMTAwMDBweCcpLlxuICAgICAgICAgICAgY3NzKCd0b3AnLCAwKS5jc3MoJ2xlZnQnLCAwKS5jc3MoJ2JhY2tncm91bmQtY29sb3InLCAnJyk7XG4gICAgICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKGJsb2NrLmdldCgwKSk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYmxvY2sucmVtb3ZlKCk7XG4gICAgICAgIH0sIDMwMCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIHNlbGVjdGlvbiBpcyBwZXJmb3JtZWQgc29tZSB3aWRnZXRzIG1heSByZXF1aXJlIHRvIHBlcmZvcm0gYW55IFVJIG9wZXJhdGlvbi4gVGhvc2UgYXJlIGRvbmUgaGVyZVxuICAgICAqXG4gICAgICogQHBhcmFtIHdpZGdldFR5cGUgVGhlIHR5cGUgb2Ygd2lkZ2V0IHRvIGRldGVybWluZSB3aGF0IHRvIGRvXG4gICAgICovXG4gICAgSW5qZWN0ZWRTZWxlY3RvclRvb2wucHJvdG90eXBlLmNsb3NpbmdBY3Rpb24gPSBmdW5jdGlvbiAod2lkZ2V0VHlwZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRFbGVtZW50cywgZWxlbV8xLCByZWdleCwgYnV0dG9uTGFiZWwsIGF4aW9tV29ya3NwYWNlO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZWxlY3RvckRhdGEuc2VsZWN0b3JzW3RoaXMuc2VsZWN0b3JEYXRhLmFjdGl2ZVNlbGVjdG9ySW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gXCJzaW5nbGVcIiAmJiB3aWRnZXRUeXBlICYmIHdpZGdldFR5cGUgPT09ICdXaWRnZXREcml2ZXJDbGljaycpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRFbGVtZW50cyA9IHRoaXMuc2VsZWN0b3JEYXRhLnNlbGVjdG9yc1swXS5zZWxlY3Rvci5oaWVyYXJjaHk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1fMSA9IGpRdWVyeShzZWxlY3RlZEVsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbGVtXzFbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZWdleCA9IG5ldyBSZWdFeHAoL1xcdyooY3JlYXRlfHNlbmR8c3VibWl0KVxcdyovZ2kpO1xuICAgICAgICAgICAgICAgICAgICBidXR0b25MYWJlbCA9IGVsZW1fMS50ZXh0KCkgfHwgZWxlbV8xLnZhbCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlZ2V4LnRlc3QoYnV0dG9uTGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlvbVdvcmtzcGFjZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdheGlvbS1ib3QtZHJhdy0xOTc2MjUzNDkyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlvbVdvcmtzcGFjZS5jbGFzc0xpc3QuYWRkKFwiYXhpb20tc3RhdGljXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJC5jb25maXJtKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1NlbGVjdGlvbiBNYWRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnRG8geW91IHdhbnQgdG8gY2xpY2sgdGhpcyBlbGVtZW50IG5vdz8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJveFdpZHRoOiAnNDQ4cHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZUJvb3RzdHJhcDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3VzdG9tIHdpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9jcmFmdHBpcC5naXRodWIuaW8vanF1ZXJ5LWNvbmZpcm0vI2N1c3RvbS13aWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1fMVswXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gJ3N2ZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtXzEgPSBlbGVtXzEucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtXzFbMF0uY2xpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGljayBIYW5kbGVyIGZvciBzaW5nbGUgZWxlbWVudCBzZWxlY3Rpb25zIHdoZW4gdGhlIHNlbGVjdG9yIHRvb2wgaXMgaW4gYWN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZVxuICAgICAqL1xuICAgIEluamVjdGVkU2VsZWN0b3JUb29sLnByb3RvdHlwZS5zaW5nbGVFbGVtZW50Q2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHgsIHNpbmdsZVNlbGVjdGlvbjtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgeCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgICAgIGlmICgheC5jbGFzc0xpc3QuY29udGFpbnMoJ2F4aW9tLXNlbGVjdG9yLWlnbm9yZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc3VsdFR5cGUgPT09ICdsaW5rJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHgucGFyZW50RWxlbWVudCAmJiAhL1xcUy8udGVzdCh0aGlzLnNjcmFwZUhlbHBlci5nZXREYXRhKHgsIHRoaXMucmVzdWx0VHlwZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHgucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmJsb2NrQ2xpY2tzT24oZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgIEF4aW9tQXBpSGVscGVyXzEuQXhpb21BcGlIZWxwZXIuYXBwbHlUb0lmcmFtZXMoZnVuY3Rpb24gKGluZGV4LCBjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmJsb2NrQ2xpY2tzT24oY29udGVudFswXSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0b3JEYXRhLnNlbGVjdG9yc1t0aGlzLnNlbGVjdG9yRGF0YS5hY3RpdmVTZWxlY3RvckluZGV4XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3JEYXRhLnNlbGVjdG9yc1t0aGlzLnNlbGVjdG9yRGF0YS5hY3RpdmVTZWxlY3RvckluZGV4XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbnM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRFbGVtZW50czogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3RlZEVsZW1lbnRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2luZ2xlU2VsZWN0aW9uID0gdGhpcy5zaW5nbGVTZWxlY3Rvci5nZXRTZWxlY3Rvcih4KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yRGF0YS5zZWxlY3RvcnNbdGhpcy5zZWxlY3RvckRhdGEuYWN0aXZlU2VsZWN0b3JJbmRleF0uc2VsZWN0b3IgPSBzaW5nbGVTZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxIaWdobGlnaHRzKGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICBBeGlvbUFwaUhlbHBlcl8xLkF4aW9tQXBpSGVscGVyLmFwcGx5VG9JZnJhbWVzKGZ1bmN0aW9uIChpbmRleCwgY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW1vdmVBbGxIaWdobGlnaHRzKGNvbnRlbnRbMF0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFN0YXRlVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNlbGVjdG9yRGF0YS5zZWxlY3RvcnNbdGhpcy5zZWxlY3RvckRhdGEuYWN0aXZlU2VsZWN0b3JJbmRleF0uc2VsZWN0ZWRFbGVtZW50cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yRGF0YS5zZWxlY3RvcnNbdGhpcy5zZWxlY3RvckRhdGEuYWN0aXZlU2VsZWN0b3JJbmRleF0uc2VsZWN0ZWRFbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yRGF0YS5zZWxlY3RvcnNbdGhpcy5zZWxlY3RvckRhdGEuYWN0aXZlU2VsZWN0b3JJbmRleF0uc2VsZWN0ZWRFbGVtZW50cy5wdXNoKHgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SGlnaGxpZ2h0cyhkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgQXhpb21BcGlIZWxwZXJfMS5BeGlvbUFwaUhlbHBlci5hcHBseVRvSWZyYW1lcyhmdW5jdGlvbiAoaW5kZXgsIGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0SGlnaGxpZ2h0cyhjb250ZW50WzBdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgdG9rZW4gZmxhZyAtIGlmIHlvdSBzZWxlY3Qgc29tZXRoaW5nLCBpdCdzIG5vIGxvbmdlciBzZWxlY3RlZCBieSBhIHRva2VuXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvckRhdGEuc2VsZWN0b3JzW3RoaXMuc2VsZWN0b3JEYXRhLmFjdGl2ZVNlbGVjdG9ySW5kZXhdLmlzVG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kU3RhdGVVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdVbmFibGUgdG8gc2VuZCBiYWNrIG1lc3NhZ2UgdG8gdGhlIGNocm9tZSBleHRlbnNpb24gb24gc2luZ2xlIGVsZW1lbnQgc2VsZWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdvIGRvd24gdGhlIHRyZWUgYW5kIHJlbW92ZSBhbnkgY2hpbGRyZW4gb2YgdGhpcyBlbGVtZW50IHRoYXQgaGF2ZSBwcmV2aW91c2x5IGJlZW4gc2VsZWN0ZWQgYnV0IGFyZSBubyBsb25nZXJcbiAgICAgKiBtYXRjaGVkIGJ5IGFueXRoaW5nIC0gb3JwaGFuZWQgc2VsZWN0b3JzIGVzc2VudGlhbGx5LCB3aGljaCBhcHBlYXIgYXMgZ3JleSBibG9ja3MgdGhhdCBjYW5ub3QgYmUgY2xpY2tlZCBvbiBpbnNpZGVcbiAgICAgKiBhIHZhbGlkLCB3b3JraW5nIHNlbGVjdG9yXG4gICAgICogQHBhcmFtIGUgQW4gZWxlbWVudCB0byBmaW5kIHRoZSBjaGlsZHJlbiBvZiBhbmQgcmVtb3ZlIGFueSBzZWxlY3RvcnNcbiAgICAgKi9cbiAgICBJbmplY3RlZFNlbGVjdG9yVG9vbC5wcm90b3R5cGUucmVtb3ZlU2VsZWN0ZWRDaGlsZHJlbiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGUuY2hpbGRyZW47XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgY2hpbGQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLnNlbGVjdGluZ0NsYXNzICsgdGhpcy5zZWxlY3RvckRhdGEuYWN0aXZlU2VsZWN0b3JJbmRleCk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVNlbGVjdGVkQ2hpbGRyZW4oY2hpbGQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5sZGVzIGNsaWNrIHdoZW4gdGhlIHNlbGVjdG9yIHRvb2wgaXMgaW4gYWN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZVxuICAgICAqL1xuICAgIEluamVjdGVkU2VsZWN0b3JUb29sLnByb3RvdHlwZS5lbGVtZW50Q2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHgsIHN1Z2dlc3RlZEVsZW1lbnRzLCBjb21iaW5lZFNlbGVjdG9yXzE7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHggPSBlLnRhcmdldDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXN1bHRUeXBlID09PSAnbGluaycpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHgucGFyZW50RWxlbWVudCAmJiAhL1xcUy8udGVzdCh0aGlzLnNjcmFwZUhlbHBlci5nZXREYXRhVjAyMTAoeCwgdGhpcy5yZXN1bHRUeXBlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSB4LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja0NsaWNrc09uKGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICBBeGlvbUFwaUhlbHBlcl8xLkF4aW9tQXBpSGVscGVyLmFwcGx5VG9JZnJhbWVzKGZ1bmN0aW9uIChpbmRleCwgY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ibG9ja0NsaWNrc09uKGNvbnRlbnRbMF0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdG9yRGF0YS5zZWxlY3RvcnNbdGhpcy5zZWxlY3RvckRhdGEuYWN0aXZlU2VsZWN0b3JJbmRleF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yRGF0YS5zZWxlY3RvcnNbdGhpcy5zZWxlY3RvckRhdGEuYWN0aXZlU2VsZWN0b3JJbmRleF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25zOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkRWxlbWVudHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0ZWRFbGVtZW50czogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRUeXBlOiB0aGlzLnNlbGVjdG9yRGF0YS5kZWZhdWx0UmVzdWx0VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3JEYXRhLnNlbGVjdG9yc1t0aGlzLnNlbGVjdG9yRGF0YS5hY3RpdmVTZWxlY3RvckluZGV4XS5pc1Rva2VuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghL2F4aW9tLXRvb2wvZy50ZXN0KHguY2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0ZWRFbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9ICdtdWx0aXBsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWdnZXN0ZWRFbGVtZW50cyA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0aGlzLnNlbGVjdG9yRGF0YS5zZWxlY3RvcnNbdGhpcy5zZWxlY3RvckRhdGEuYWN0aXZlU2VsZWN0b3JJbmRleF0uc2VsZWN0b3IpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGVkRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3VnZ2VzdGVkRWxlbWVudHMuaW5jbHVkZXMoeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGVsZW1lbnQgaXMgbWFudWFsbHkgc2VsZWN0ZWQgYnkgdXNlclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0b3JEYXRhLnNlbGVjdG9yc1t0aGlzLnNlbGVjdG9yRGF0YS5hY3RpdmVTZWxlY3RvckluZGV4XS5zZWxlY3RlZEVsZW1lbnRzLmluY2x1ZGVzKHgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW5zZWxlY3QgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHguY2xhc3NMaXN0LnJlbW92ZSh0aGlzLnNlbGVjdGluZ0NsYXNzICsgdGhpcy5zZWxlY3RvckRhdGEuYWN0aXZlU2VsZWN0b3JJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvckRhdGEuc2VsZWN0b3JzW3RoaXMuc2VsZWN0b3JEYXRhLmFjdGl2ZVNlbGVjdG9ySW5kZXhdLnNlbGVjdGVkRWxlbWVudHMgPSB0aGlzLnNlbGVjdG9yRGF0YS5zZWxlY3RvcnNbdGhpcy5zZWxlY3RvckRhdGEuYWN0aXZlU2VsZWN0b3JJbmRleF0uc2VsZWN0ZWRFbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbCAhPT0geDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGRlc2VsZWN0ZWQgYWxsIGVsZW1lbnRzIHRoZW4gd2Ugc2hvdWxkIGF1dG9tYXRpY2FsbHkgZGVzZWxlY3QgYWxsIHJlamVjdGVkIGVsZW1lbnRzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdG9yRGF0YS5zZWxlY3RvcnNbdGhpcy5zZWxlY3RvckRhdGEuYWN0aXZlU2VsZWN0b3JJbmRleF0uc2VsZWN0ZWRFbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvckRhdGEuc2VsZWN0b3JzW3RoaXMuc2VsZWN0b3JEYXRhLmFjdGl2ZVNlbGVjdG9ySW5kZXhdLnJlamVjdGVkRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsgLy8gZWxlbWVudCBpcyBvbmx5IHN1Z2dlc3RlZCBieSB0aGUgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhjbHVkZSB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZWxlY3RvckRhdGEuc2VsZWN0b3JzW3RoaXMuc2VsZWN0b3JEYXRhLmFjdGl2ZVNlbGVjdG9ySW5kZXhdLnJlamVjdGVkRWxlbWVudHMuaW5jbHVkZXMoeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5jbGFzc0xpc3QuYWRkKHRoaXMucmVqZWN0aW5nQ2xhc3MgKyB0aGlzLnNlbGVjdG9yRGF0YS5hY3RpdmVTZWxlY3RvckluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvckRhdGEuc2VsZWN0b3JzW3RoaXMuc2VsZWN0b3JEYXRhLmFjdGl2ZVNlbGVjdG9ySW5kZXhdLnJlamVjdGVkRWxlbWVudHMucHVzaCh4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHguY2xhc3NMaXN0LnJlbW92ZSh0aGlzLnJlamVjdGluZ0NsYXNzICsgdGhpcy5zZWxlY3RvckRhdGEuYWN0aXZlU2VsZWN0b3JJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3JEYXRhLnNlbGVjdG9yc1t0aGlzLnNlbGVjdG9yRGF0YS5hY3RpdmVTZWxlY3RvckluZGV4XS5yZWplY3RlZEVsZW1lbnRzID0gdGhpcy5zZWxlY3RvckRhdGEuc2VsZWN0b3JzW3RoaXMuc2VsZWN0b3JEYXRhLmFjdGl2ZVNlbGVjdG9ySW5kZXhdLnJlamVjdGVkRWxlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsICE9PSB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7IC8vIGVsZW1lbnQgaXMgbm90IGN1cnJlbnRseSBpbmNsdWRlZCBpbiB0aGUgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RvckRhdGEuc2VsZWN0b3JzW3RoaXMuc2VsZWN0b3JEYXRhLmFjdGl2ZVNlbGVjdG9ySW5kZXhdLnJlamVjdGVkRWxlbWVudHMuaW5jbHVkZXMoeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50IGhhcyBwcmV2aW91c2x5IGJlZW4gbWFudWFsbHkgZXhjbHVkZWQ6IHJlbW92ZSBmcm9tIHJlamVjdGVkIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5yZWplY3RpbmdDbGFzcyArIHRoaXMuc2VsZWN0b3JEYXRhLmFjdGl2ZVNlbGVjdG9ySW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3JEYXRhLnNlbGVjdG9yc1t0aGlzLnNlbGVjdG9yRGF0YS5hY3RpdmVTZWxlY3RvckluZGV4XS5yZWplY3RlZEVsZW1lbnRzID0gdGhpcy5zZWxlY3RvckRhdGEuc2VsZWN0b3JzW3RoaXMuc2VsZWN0b3JEYXRhLmFjdGl2ZVNlbGVjdG9ySW5kZXhdLnJlamVjdGVkRWxlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwgIT09IHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBoYXNuJ3QgYmVlbiB0YWdnZWQgYXMgbWF0Y2hlZCwgaW1tZWRpYXRlbHkgcmUtc2VsZWN0IGl0OyB0aGlzIGNhbiBoYXBwZW4gaW4gdGhlIGNhc2Ugd2hlcmUgeW91IHVuc2VsZWN0IGEgbm9uLXNlbGVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxlbWVudCwgYW5kIHRoaXMgcmVtb3ZlcyBldmVyeXRoaW5nLiBUaGUgbWFpbiB3YXkgdGhhdCBoYXBwZW5zIGlzIHdoZW4gZWRpdGluZyBzZWxlY3RvcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF4LmNsYXNzTGlzdC5jb250YWlucyhcImF4aW9tLW1hdGNoZWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5jbGFzc0xpc3QuYWRkKHRoaXMuc2VsZWN0aW5nQ2xhc3MgKyB0aGlzLnNlbGVjdG9yRGF0YS5hY3RpdmVTZWxlY3RvckluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvckRhdGEuc2VsZWN0b3JzW3RoaXMuc2VsZWN0b3JEYXRhLmFjdGl2ZVNlbGVjdG9ySW5kZXhdLnNlbGVjdGVkRWxlbWVudHMucHVzaCh4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsgLy8gZWxlbWVudCBpcyBub3QgcmVqZWN0ZWQgb3Igc3VnZ2VzdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VsZWN0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LmNsYXNzTGlzdC5hZGQodGhpcy5zZWxlY3RpbmdDbGFzcyArIHRoaXMuc2VsZWN0b3JEYXRhLmFjdGl2ZVNlbGVjdG9ySW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3JEYXRhLnNlbGVjdG9yc1t0aGlzLnNlbGVjdG9yRGF0YS5hY3RpdmVTZWxlY3RvckluZGV4XS5zZWxlY3RlZEVsZW1lbnRzLnB1c2goeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29tYmluZWRTZWxlY3Rvcl8xID0gdGhpcy5oaWVyYXJjaHlBY3Rpb25zLmdldENvbWJpbmVkKGRvY3VtZW50LCB0aGlzLnNlbGVjdG9yRGF0YS5zZWxlY3RvcnNbdGhpcy5zZWxlY3RvckRhdGEuYWN0aXZlU2VsZWN0b3JJbmRleF0uc2VsZWN0ZWRFbGVtZW50cywgdGhpcy5zZWxlY3RvckRhdGEuc2VsZWN0b3JzW3RoaXMuc2VsZWN0b3JEYXRhLmFjdGl2ZVNlbGVjdG9ySW5kZXhdLnJlamVjdGVkRWxlbWVudHMsICdzZWxlY3RvcicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChjb21iaW5lZFNlbGVjdG9yXzEpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3JEYXRhLnNlbGVjdG9yc1t0aGlzLnNlbGVjdG9yRGF0YS5hY3RpdmVTZWxlY3RvckluZGV4XS5zZWxlY3RvciA9IGNvbWJpbmVkU2VsZWN0b3JfMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEF4aW9tQXBpSGVscGVyXzEuQXhpb21BcGlIZWxwZXIuYXBwbHlUb0lmcmFtZXMoZnVuY3Rpb24gKGluZGV4LCBjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tYmluZWRTZWxlY3Rvcl8xID0gX3RoaXMuaGllcmFyY2h5QWN0aW9ucy5nZXRDb21iaW5lZChjb250ZW50WzBdLCBfdGhpcy5zZWxlY3RvckRhdGEuc2VsZWN0b3JzW190aGlzLnNlbGVjdG9yRGF0YS5hY3RpdmVTZWxlY3RvckluZGV4XS5zZWxlY3RlZEVsZW1lbnRzLCBfdGhpcy5zZWxlY3RvckRhdGEuc2VsZWN0b3JzW190aGlzLnNlbGVjdG9yRGF0YS5hY3RpdmVTZWxlY3RvckluZGV4XS5yZWplY3RlZEVsZW1lbnRzLCAnc2VsZWN0b3InKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFswXS5xdWVyeVNlbGVjdG9yQWxsKGNvbWJpbmVkU2VsZWN0b3JfMSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZWxlY3RvckRhdGEuc2VsZWN0b3JzW190aGlzLnNlbGVjdG9yRGF0YS5hY3RpdmVTZWxlY3RvckluZGV4XS5zZWxlY3RvciA9IGNvbWJpbmVkU2VsZWN0b3JfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRNYXRjaGVzVjAxOTAoZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0SGlnaGxpZ2h0cyhkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgIEF4aW9tQXBpSGVscGVyXzEuQXhpb21BcGlIZWxwZXIuYXBwbHlUb0lmcmFtZXMoZnVuY3Rpb24gKGluZGV4LCBkb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmZpbmRNYXRjaGVzVjAxOTAoZG9jWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc2V0SGlnaGxpZ2h0cyhkb2NbMF0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHRva2VuIGZsYWcgLSBpZiB5b3Ugc2VsZWN0IHNvbWV0aGluZywgaXQncyBubyBsb25nZXIgc2VsZWN0ZWQgYnkgYSB0b2tlblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yRGF0YS5zZWxlY3RvcnNbdGhpcy5zZWxlY3RvckRhdGEuYWN0aXZlU2VsZWN0b3JJbmRleF0uaXNUb2tlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kU3RhdGVVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZhbHNlXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBJbmplY3RlZFNlbGVjdG9yVG9vbDtcbn0oKSk7XG5leHBvcnRzLkluamVjdGVkU2VsZWN0b3JUb29sID0gSW5qZWN0ZWRTZWxlY3RvclRvb2w7XG53aW5kb3dbJ2F4aW9tX3NlbGVjdG9yJ10gPSBuZXcgSW5qZWN0ZWRTZWxlY3RvclRvb2woKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///808\n")},809:function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AttributeSelector_1 = __webpack_require__(404);\nvar HierarchyActions = /** @class */ (function () {\n    function HierarchyActions() {\n        this.attributeSelector = new AttributeSelector_1.AttributeSelector();\n    }\n    /**\n     * Takes 2 collections of elements\n     * Returns a single AtrributeSelector that will:\n     * -select all includeElements\n     * -select none of the excludeElements\n     *\n     * @param includeElements Array of Elements to be included in the selection\n     * @param excludeElements Array of Elements to be excluded from the selection\n     *\n     * @returns String to be used as a selector compatable with document.querySelectorAll(selector: String)\n     * @example ':-webkit-any(div, body):not([id=\"g2\"]) > :-webkit-any(article, section)[class~=\"post\"]:not([id=\"a4\"]) > h3:not([id=\"h4\"])'\n     *\n     */\n    HierarchyActions.prototype.getCombined = function (document, includeElements, excludeElements, type) {\n        if (includeElements.length === 0) {\n            return '';\n        }\n        var includeSelectors = this.getAsAttributeSelectors(includeElements);\n        var excludeSelectors = this.getAsAttributeSelectors(excludeElements);\n        var inSections = [];\n        var exSections = [];\n        for (var _i = 0, includeSelectors_1 = includeSelectors; _i < includeSelectors_1.length; _i++) {\n            var selector = includeSelectors_1[_i];\n            inSections.push(this.splitHierarchyString(selector));\n        }\n        for (var _a = 0, excludeSelectors_1 = excludeSelectors; _a < excludeSelectors_1.length; _a++) {\n            var selector = excludeSelectors_1[_a];\n            exSections.push(this.splitHierarchyString(selector));\n        }\n        var allSections = [].concat(inSections, exSections);\n        var levels = [];\n        // The tags arrays are ordered with the highest element in the tree first, and this causes things to go out of sync when selectors are not \n        // the same length. For example, body > div > span and body > div will be compared as [[span, div], [div, body], [body, undefined]].\n        // To fix this we add a new reversed version of the tags and modifers to each of the objects we check.\n        for (var _b = 0, allSections_1 = allSections; _b < allSections_1.length; _b++) {\n            var as = allSections_1[_b];\n            as.tagsReversed = as.tags.slice().reverse();\n        }\n        for (var _c = 0, inSections_1 = inSections; _c < inSections_1.length; _c++) {\n            var is = inSections_1[_c];\n            is.tagsReversed = is.tags.slice().reverse();\n        }\n        // Loop through the tags. This entire loop is inside out. We are looping through the inner array \n        // (which represents the parts of the hierarchy for each selector), as\n        // the outer loop, and the outer array (which represents each selector) as the inner loop. The reason for this is so we can compare the\n        // individual parts of the two selector strings.\n        var largestTagIndex = 0;\n        for (var _d = 0, allSections_2 = allSections; _d < allSections_2.length; _d++) {\n            var section = allSections_2[_d];\n            if (section.tagsReversed.length > largestTagIndex) {\n                largestTagIndex = section.tags.length;\n            }\n        }\n        for (var index = 0; index < largestTagIndex; index++) {\n            // We loop through the outer loop and get an array of tags and modifiers for each section for this part of the hierarchy\n            var tags = [];\n            for (var _e = 0, inSections_2 = inSections; _e < inSections_2.length; _e++) {\n                var section = inSections_2[_e];\n                // get tags\n                if (section.tagsReversed[index]) {\n                    tags.push(section.tagsReversed[index]);\n                }\n            }\n            if (tags.length === 0) {\n                return '';\n            }\n            var tag = '';\n            if (tags.length === inSections.length) {\n                if (tags.length === 1) {\n                    tag = tags[0];\n                }\n                else {\n                    var reducedTags = [];\n                    for (var _f = 0, tags_1 = tags; _f < tags_1.length; _f++) {\n                        var t = tags_1[_f];\n                        if (reducedTags.indexOf(t) === -1) {\n                            reducedTags.push(t);\n                        }\n                    }\n                    if (reducedTags.length === 1) {\n                        tag = reducedTags[0];\n                    }\n                    else {\n                        tag = \":-webkit-any(\" + reducedTags.join(', ') + \")\";\n                    }\n                }\n                levels.push(tag);\n            }\n        }\n        var combinedSelector = '';\n        combinedSelector = levels.join(' > ');\n        combinedSelector = combinedSelector.replace(/\\n/g, '');\n        combinedSelector = combinedSelector.replace(/\\s\\s/g, ' ');\n        combinedSelector = combinedSelector.replace(/\\[class~=\"[^\\S]*\"\\]/g, '');\n        if (type === 'selector') {\n            var selectorWithNthSpecifiers = this.applyNthSpecifiers(document, combinedSelector, includeElements, excludeElements);\n            // If this selector selects the same number of results as the previous one, we don't use it; it's likely too specific.\n            if (document.querySelectorAll(combinedSelector).length !== document.querySelectorAll(selectorWithNthSpecifiers).length) {\n                combinedSelector = selectorWithNthSpecifiers;\n            }\n        }\n        var matchedElements = [];\n        try {\n            matchedElements = Array.from(document.querySelectorAll(combinedSelector));\n        }\n        catch (e) {\n        }\n        combinedSelector = this.trimAttributes(document, combinedSelector, matchedElements, excludeElements);\n        combinedSelector = this.trimHierarchy(document, combinedSelector, matchedElements, excludeElements);\n        return combinedSelector.replace(/\\:not\\(\\)/g, \"\"); // strip empty :not() attributes\n    };\n    HierarchyActions.prototype.excludedMatches = function (document, selector, excludedElements) {\n        //get all elements that are currently matched by the combined selector\n        var matching = [];\n        try {\n            matching = Array.from(document.querySelectorAll(selector));\n        }\n        catch (e) {\n        }\n        //check for any elements in excludeElements that matched\n        return matching.filter(function (el) {\n            return excludedElements.includes(el);\n        });\n    };\n    HierarchyActions.prototype.misMatches = function (document, selector, excludedElements) {\n        //get all elements that are currently matched by the combined selector\n        var matching = [];\n        try {\n            matching = Array.from(document.querySelectorAll(selector));\n        }\n        catch (e) {\n        }\n        //check for any elements not includeedElements that matched\n        return matching.filter(function (el) {\n            return excludedElements.includes(el);\n        });\n    };\n    HierarchyActions.prototype.overSelected = function (document, selector, elementsToMatch) {\n        //get all elements that are currently matched by the combined selector\n        var matching = [];\n        try {\n            matching = Array.from(document.querySelectorAll(selector));\n        }\n        catch (e) {\n        }\n        //check for any extra elements sneaking in\n        return matching.filter(function (el) {\n            return !elementsToMatch.includes(el);\n        });\n    };\n    HierarchyActions.prototype.missingElements = function (document, selector, elementsToMatch) {\n        //get all elements that are currently matched by the combined selector\n        var matching = [];\n        try {\n            matching = Array.from(document.querySelectorAll(selector));\n        }\n        catch (e) {\n        }\n        //check for any missing elements\n        return elementsToMatch.filter(function (el) {\n            return !matching.includes(el);\n        });\n    };\n    HierarchyActions.prototype.trimHierarchy = function (document, combinedSelector, includeElements, excludeElements) {\n        var selectorLevels = combinedSelector.split(' > ');\n        var trimmedLength = selectorLevels.length;\n        var trimmedSelector = selectorLevels.slice(selectorLevels.length - trimmedLength, selectorLevels.length).join(' > ');\n        while (trimmedLength > 0 && !this.missingElements(document, trimmedSelector, includeElements).length && !this.misMatches(document, trimmedSelector, excludeElements).length && !this.overSelected(document, trimmedSelector, includeElements).length) {\n            trimmedLength--;\n            trimmedSelector = selectorLevels.slice(selectorLevels.length - trimmedLength, selectorLevels.length).join(' > ');\n            if (/\\:not\\(\\:nth/.test(selectorLevels[selectorLevels.length - trimmedLength])) { // here we have a user specified exclusion and so we shouldn't strip it out\n                return selectorLevels.slice(selectorLevels.length - (trimmedLength), selectorLevels.length).join(' > ');\n            }\n        }\n        return selectorLevels.slice(selectorLevels.length - (trimmedLength + 1), selectorLevels.length).join(' > ');\n    };\n    HierarchyActions.prototype.trimSelector = function (document, selector, includeElements, excludeElements) {\n        var selectorLevels = selector.split(' > ');\n        var trimmedLength = selectorLevels.length;\n        var trimmedSelector = selectorLevels.slice(selectorLevels.length - trimmedLength, selectorLevels.length).join(' > ');\n        while (trimmedLength < selectorLevels.length - 1 && !this.missingElements(document, trimmedSelector, includeElements).length && !this.misMatches(document, trimmedSelector, excludeElements).length) {\n            trimmedLength++;\n            trimmedSelector = selectorLevels.slice(selectorLevels.length - trimmedLength, selectorLevels.length).join(' > ');\n            trimmedSelector = this.trimAttributes(document, trimmedSelector, includeElements, excludeElements);\n        }\n        return selectorLevels.slice(selectorLevels.length - (trimmedLength + 1), selectorLevels.length).join(' > ');\n    };\n    HierarchyActions.prototype.trimAttributes = function (document, combinedSelector, includeElements, excludeElements) {\n        var allAttributes = combinedSelector.match(/\\[[^\\s\\[\\]]*\\]/g);\n        if (allAttributes && allAttributes.length) {\n            for (var _i = 0, allAttributes_1 = allAttributes; _i < allAttributes_1.length; _i++) {\n                var attribute = allAttributes_1[_i];\n                attribute = attribute.replace(/\\+/g, \"\\\\+\");\n                // we will make a selector for testing where all occurances of attribute are stripped out\n                var testSelector = combinedSelector.replace(new RegExp(attribute.replace('[', '\\\\[').replace(']', '\\\\]'), 'g'), \"\");\n                if (!this.missingElements(document, testSelector, includeElements).length && !this.misMatches(document, testSelector, excludeElements).length && !this.overSelected(document, testSelector, includeElements).length) {\n                    combinedSelector = testSelector;\n                }\n            }\n        }\n        return combinedSelector;\n    };\n    HierarchyActions.prototype.applyNthSpecifiers = function (document, combinedSelector, includeElements, excludeElements) {\n        // ensure there are no hidden elements selected by the combinedSelector before adding the nthSelectors\n        var initialMatches = Array.from(document.querySelectorAll(combinedSelector));\n        var invisible = initialMatches.filter(function (el) {\n            return !(includeElements.includes(el) || $(el).filter(':visible').length);\n        });\n        var nthMods = [];\n        // Pull out the number of siblings of the target element at each depth\n        // \"Inc Levels\" and \"Ex Levels\" here are poorly named, but are basically the array of each selector's sibling counts, transposed.\n        var inc_levels = [];\n        for (var _i = 0, includeElements_1 = includeElements; _i < includeElements_1.length; _i++) {\n            var include = includeElements_1[_i];\n            var counts = treeCount(include);\n            for (var level in counts) {\n                if (Array.isArray(inc_levels[level])) {\n                    inc_levels[level].push(counts[level]);\n                }\n                else {\n                    inc_levels[level] = [counts[level]];\n                }\n            }\n        }\n        var exc_levels = [];\n        for (var _a = 0, excludeElements_1 = excludeElements; _a < excludeElements_1.length; _a++) {\n            var exclude = excludeElements_1[_a];\n            var counts = treeCount(exclude);\n            for (var level in counts) {\n                if (Array.isArray(exc_levels[level])) {\n                    exc_levels[level].push(counts[level]);\n                }\n                else {\n                    exc_levels[level] = [counts[level]];\n                }\n            }\n        }\n        for (var level in inc_levels) {\n            var inc_nth = inc_levels[level];\n            var exc_nth = exc_levels[level];\n            // This basically removes stuff from inc_nth that is in exc_nth, but is expressed needlessly generically.\n            var unique_nth = getUnique(inc_nth, exc_nth);\n            var nthMod = getNthMods({ include: inc_nth, exclude: unique_nth.exclude });\n            nthMods[level] = (nthMod !== undefined) ? nthMod : '';\n        }\n        var split = combinedSelector.split(' > ');\n        split.reverse();\n        for (var level in split) {\n            if (nthMods[level]) {\n                split[level] += nthMods[level];\n            }\n        }\n        split.reverse();\n        return split.join(' > ');\n        // 'HELPER' FUNCTIONS\n        // Seriously these should not be nested 2 deep in the parent function, needs a refactor badly\n        function treeCount(element) {\n            var counts = [];\n            var check = element;\n            while (check.parentElement && check.tagName) {\n                var count = countSiblings(check);\n                counts.push(count);\n                check = check.parentElement;\n            }\n            return counts;\n        }\n        function countSiblings(element) {\n            var siblingCount = 1;\n            var ofTypeCount = 1;\n            var check = element;\n            while (check.previousElementSibling && check.tagName) {\n                siblingCount++;\n                if (check.previousElementSibling.tagName === check.tagName) {\n                    ofTypeCount++;\n                }\n                check = check.previousElementSibling;\n            }\n            return siblingCount;\n        }\n        // returns items in a that aren't in b and in b that aren't in a\n        function getUnique(include, exclude) {\n            var uniqueInclude = [];\n            if (include && include.length) {\n                if (exclude && exclude.length) {\n                    uniqueInclude = include.filter(function (item) {\n                        return !exclude.includes(item);\n                    });\n                }\n                else { // there are no excludes specified and so all includes are unique\n                    uniqueInclude = include;\n                }\n            }\n            var uniqueExclude = [];\n            if (exclude && exclude.length) {\n                if (include && include.length) {\n                    uniqueExclude = exclude.filter(function (item) {\n                        return !include.includes(item);\n                    });\n                }\n                else { // there are no includes specified and so all excludes are unique\n                    uniqueExclude = exclude;\n                }\n            }\n            return { include: uniqueInclude, exclude: uniqueExclude };\n        }\n        function getNthMods(sample) {\n            var include = { series: sample.include, diffs: [], expandedSeries: [] };\n            var exclude = { series: sample.exclude, diffs: [], expandedSeries: [] };\n            // So a diff here is an array, containing the differences between each chosen element for that level of the hierarchy\n            // For example, if elemnt 0 has selected the 2nd sibling at a particular level, and element 1 has the 3rd, this generates a diff of 1\n            genDiffs(include);\n            var includeMeta = findSeries(include.series, include.diffs);\n            var pattern = getSeriesFormula(includeMeta);\n            var includePattern;\n            if (pattern) {\n                includePattern = \":nth-child(\" + pattern + \")\";\n            }\n            genDiffs(exclude);\n            exclude = findSeries(exclude.series, include.diffs);\n            var excludePatterns = [];\n            if (exclude.expandedSeries.length && exclude.diffs[0] !== undefined && exclude.series[0] !== undefined && !hasCommonItem(include.series, exclude.expandedSeries)) {\n                // generate pattern\n                var m = exclude.diffs[0];\n                var c = exclude.series[0]; // use series so that any pattern starts with first excluded element\n                var offset = (c > 0) ? \"+\" + c : (c < 0) ? \"\" + c : '';\n                var pattern_1 = m + \"n\" + offset;\n                var exc_pattern = \":not(:nth-child(\" + pattern_1 + \"))\";\n                if (!excludePatterns.includes(exc_pattern)) {\n                    excludePatterns.push(exc_pattern);\n                }\n            }\n            else {\n                // generate nths\n                for (var _i = 0, _a = exclude.series; _i < _a.length; _i++) {\n                    var val = _a[_i];\n                    var exc_pattern = \":not(:nth-child(\" + val + \"))\";\n                    if (!excludePatterns.includes(exc_pattern)) {\n                        excludePatterns.push(exc_pattern);\n                    }\n                }\n            }\n            var nthMods = '';\n            if (includePattern) {\n                nthMods += includePattern;\n            }\n            if (excludePatterns.length) {\n                nthMods += \"\" + excludePatterns.join('');\n            }\n            return nthMods;\n            // HELPER FUNCTIONS\n            // Same anti-pattern as previously\n            function genDiffs(set) {\n                var diffs = [];\n                var series = set.series.sort(function (a, b) {\n                    return a - b;\n                });\n                for (var i = 0; i < series.length - 1; i++) {\n                    var newDiff = series[i + 1] - series[i];\n                    if (newDiff > 0 && !diffs.includes(newDiff)) {\n                        diffs.push(newDiff);\n                    }\n                }\n                set.diffs = diffs;\n                set.sortedDiffs = diffs.sort(function (a, b) {\n                    return a - b;\n                });\n            }\n            function hasCommonItem(a, b) {\n                var commonItem = false;\n                for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {\n                    var item = a_1[_i];\n                    if (b.includes(item)) {\n                        commonItem = true;\n                    }\n                }\n                return commonItem;\n            }\n            function allFoundIn(a, b) {\n                for (var _i = 0, a_2 = a; _i < a_2.length; _i++) {\n                    var item = a_2[_i];\n                    if (!b.includes(item)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            function getExpandedSeries(series, stepValue) {\n                if (!series.length) {\n                    return [];\n                }\n                var expandedSeries = [];\n                var sortedSeries = JSON.parse(JSON.stringify(series));\n                sortedSeries.sort(function (b, a) {\n                    var diff = b - a;\n                    return diff;\n                });\n                var seriesLimit = sortedSeries[sortedSeries.length - 1];\n                var seriesStart = seriesLimit % stepValue;\n                expandedSeries.push(seriesLimit);\n                while (expandedSeries[0] > seriesStart) {\n                    expandedSeries.unshift(expandedSeries[0] - stepValue);\n                }\n                return expandedSeries;\n            }\n            function findSeries(series, diffs) {\n                var result = { series: series, expandedSeries: [], diffs: [] };\n                if (!diffs.length) {\n                    result.expandedSeries = [series[0]];\n                }\n                else {\n                    var stepValue = diffs[0];\n                    var done = false;\n                    while (stepValue > 0 && !done) {\n                        var testSeries = getExpandedSeries(series, stepValue);\n                        if (allFoundIn(series, testSeries)) {\n                            result = { series: series, expandedSeries: testSeries, diffs: [stepValue] };\n                            done = true;\n                        }\n                        else {\n                            stepValue--;\n                        }\n                    }\n                }\n                return result;\n            }\n            function getSeriesFormula(setObject) {\n                var m; // (multiplier)\n                var c; // (x shift)\n                // set m value (multiplier)\n                if (!setObject.diffs.length) {\n                    m = 0;\n                }\n                else {\n                    m = setObject.diffs[0];\n                }\n                // set c value (x shift)\n                if (m === 0) {\n                    c = setObject.expandedSeries[0];\n                    if (c) {\n                        return \"\" + c;\n                    }\n                }\n                else {\n                    c = (setObject.expandedSeries[0] !== undefined) ? setObject.expandedSeries[0] - m : 0;\n                }\n                var nthDescriptor = m + \"n \";\n                if (c !== 0) {\n                    if (c > 0) {\n                        nthDescriptor += '+';\n                    }\n                    nthDescriptor += \"\" + c;\n                }\n                return nthDescriptor;\n            }\n        }\n    };\n    /**\n     * Takes an array of Elements and returns an Array of AttributeSelectors\n     *\n     * @param elements Array of type Elements\n     *\n     * @returns Array of AttributeSelectors\n     * @example [\n     *              'body > table[id=\"a1\"] > tr[id=\"b2\"] > div[id=\"c1\"] > div[id=\"g1] > article[id=\"a2\"][class~=\"post\"] > h3[id=\"h2\"]',\n     *              'body > div[id=\"g3] > article[id=\"a9\"][class~=\"post\"] > h3[id=\"h9\"]'\n     *              'body > section[class~=\"post\"] > h3[id=\"h10\"]'\n     *          ]\n     */\n    HierarchyActions.prototype.getAsAttributeSelectors = function (elements, document, excludeElements) {\n        var attributeSelectors = [];\n        for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {\n            var el = elements_1[_i];\n            if (typeof el === 'string' || !(Object.keys(el).length === 0 && el.constructor === Object)) {\n                var selector = this.attributeSelector.getSelector(el);\n                var trimmedSelector = (document === undefined) ? selector : this.trimAttributes(document, selector, [el], excludeElements);\n                attributeSelectors.push(trimmedSelector);\n            }\n        }\n        return attributeSelectors;\n    };\n    /**\n     *\n     * @param hierarchyString String based on the css hierachy selector\n     *\n     * @example splitHierarchyString('body > table[id=\"a1\"] > tr[id=\"b1\"] > div[id=\"c1\"][class~=\"target\"]:not(\".sticky\") > div[id=\"g1] > article[id=\"a1\"][class~=\"post\"] > h3[id=\"h1\"]')\n     *\n     * @returns Object {\n     *                    hierarchyString, (input param String)\n     *                    tags,            (html tags from input string)\n     *                    mods,            (css selectors applied to each html tag)\n     *                    seperators       (hierarchy seperators as strings)\n     *          }\n     * @example {\n     *      hierachyString: 'body > table[id=\"a1\"] > tr[id=\"b1\"] > div[id=\"c1\"][class~=\"target\"]:not(\".sticky\") > div[id=\"g1] > article[id=\"a1\"][class~=\"post\"] > h3[id=\"h1\"]',\n     *      tags: ['body', 'table', 'tr', 'div', 'div', 'article', 'h3']\n     *      mods: ['', '[id=\"a1\"]', '[id=\"b1\"]', '', '[id=\"c1\"][class~=\"target\"]:not(\".sticky\")', '[id=\"g1]', '[id=\"a1\"][class~=\"post\"]', '[id=\"h1\"]'],\n     *      seperators: [' > ', ' > ', ' > ', ' > ', ' > ', ' > ']\n     * }\n     */\n    HierarchyActions.prototype.splitHierarchyString = function (hierarchyString) {\n        // get the seperator strings between each level\n        var seperators = []; // a seperater per level e.g. ' > '\n        var sections = hierarchyString.split(/[\\s][\\s]*/);\n        for (var s = 0; s < sections.length - 1; s++) { // populate seperators\n            seperators.push(' > ');\n        }\n        // Split the hierarchy into levels\n        var levels = hierarchyString.split(' > ').reverse();\n        // get the html tag and modifiers (attribute and alias selectors) at each level of the hierarchy\n        var tags = []; // a html tag per level\n        var mods = []; // a String with all modifier selector at each level\n        for (var depth = 0; depth < levels.length; depth++) {\n            tags[depth] = levels[depth].split(/[\\[\\:]/)[0];\n            mods[depth] = levels[depth].substr(tags[depth].length);\n        }\n        return {\n            hierarchyString: hierarchyString,\n            tags: tags,\n            mods: mods,\n            seperators: seperators //TODO: redundant?\n        };\n    };\n    /**\n     * Takes a collection of arrays and compares the items in each array\n     * return a collection of items that can be found in all the arrays provided\n     *\n     * @param arrays Array of Arrays\n     *\n     * @returns Array of items common to all arrays provided in the arrays param\n     * @example getCommonItems([[1,2,3,4,5,6,7,8,9,10,11,12], [2,4,6,8,10,12], [4,8,12]])\n     *\n     * [4, 12]\n     */\n    HierarchyActions.prototype.getCommonItems = function (arrays) {\n        if (arrays.length === 0) {\n            return [];\n        }\n        if (arrays.length === 1) {\n            return arrays[0];\n        }\n        var commonItems = [];\n        var count = {};\n        for (var _i = 0, arrays_1 = arrays; _i < arrays_1.length; _i++) {\n            var a = arrays_1[_i];\n            for (var i = 0; i < a.length; i++) {\n                count[a[i]] = (count[a[i]] === undefined) ? count[a[i]] = 1 : count[a[i]] + 1;\n            }\n        }\n        var counts = Object.values(count);\n        var items = Object.keys(count);\n        for (var c = 0; c < counts.length; c++) {\n            if (counts[c] === arrays.length) { //item was found in all arrays\n                commonItems.push(items[c]);\n            }\n        }\n        return commonItems;\n    };\n    /**\n     * Takes an array and a collection of arrays\n     * and finds the items that are unique to the single Array\n     * and items that are in the arrays but not in the single array\n     *\n     * @param singleArray Array of items\n     * @param arrays Array of Array of items\n     *\n     * @example getDiff([3,6,9,12], [[2,4,6,8,10,12], [4,8,12]])\n     *\n     * @returns Object {\n     *              unique, (Items unique to the array)\n     *              missing, (Items each array in arrays but not in the sinlge array)\n     *          }\n     * @example {\n     *      unique: [3,9],\n     *      missing: [4,8]\n     * }\n     */\n    HierarchyActions.prototype.getDiff = function (singleArray, arrays) {\n        var unique = [];\n        var missing = [];\n        var common = this.getCommonItems(arrays);\n        missing = common.filter(function (item) {\n            return singleArray.indexOf(item) === -1;\n        });\n        for (var _i = 0, singleArray_1 = singleArray; _i < singleArray_1.length; _i++) {\n            var item = singleArray_1[_i];\n            var exclusive = true;\n            for (var _a = 0, arrays_2 = arrays; _a < arrays_2.length; _a++) {\n                var arr = arrays_2[_a];\n                if (arr.indexOf(item) > -1) {\n                    exclusive = false;\n                }\n            }\n            if (exclusive) {\n                unique.push(item);\n            }\n        }\n        return { unique: unique, missing: missing };\n    };\n    HierarchyActions.prototype.selectorAtLevel = function (selector, level) {\n        var levels = selector.split(' > ');\n        var res = (levels.length - level > 0) ? levels.slice(0, levels.length - level).join(' > ') : undefined;\n        return res;\n    };\n    HierarchyActions.prototype.testSelectorAtLevelSelectors = function (document, selector, allSelectors, groups) {\n        var testGroup = document.querySelector(selector);\n        var matches = [];\n        try {\n            matches = Array.from(testGroup.querySelectorAll(allSelectors));\n        }\n        catch (e) {\n            // failing to use selector on element, no action required\n        }\n        for (var _i = 0, _a = groups[0]; _i < _a.length; _i++) {\n            var el = _a[_i];\n            if (!matches.includes(el)) {\n                // testGroup is one step too large\n                return false;\n            }\n        }\n        return true;\n    };\n    HierarchyActions.prototype.testSelectorAtLevelGrouping = function (document, selector, allSelectors, groups) {\n        var testGroup = document.querySelector(selector);\n        var matches = [];\n        try {\n            matches = Array.from(testGroup.querySelectorAll(allSelectors));\n        }\n        catch (e) {\n            // failing to use selector on element, no action required\n        }\n        for (var _i = 0, matches_1 = matches; _i < matches_1.length; _i++) {\n            var match = matches_1[_i];\n            if (!groups[0].includes(match)) {\n                // testGroup is one step too large\n                return true;\n            }\n        }\n        return false;\n    };\n    HierarchyActions.prototype.findGroupSelectors = function (document, selectors, groups) {\n        var allSelectors = selectors.join(',');\n        var groupSelectors = [];\n        for (var _i = 0, selectors_1 = selectors; _i < selectors_1.length; _i++) {\n            var selector = selectors_1[_i];\n            var trimmed = 'body';\n            var level = 0;\n            var done = false;\n            while (trimmed !== undefined && !done) {\n                trimmed = this.selectorAtLevel(selector, level);\n                var testA = this.testSelectorAtLevelSelectors(document, trimmed, allSelectors, groups);\n                var testB = this.testSelectorAtLevelGrouping(document, trimmed, allSelectors, groups);\n                if (testA && !testB) {\n                    done = true;\n                }\n                else {\n                    if (testB) {\n                        trimmed = this.selectorAtLevel(selector, level - 1);\n                        done = true;\n                    }\n                    else {\n                        level++;\n                    }\n                }\n            }\n            groupSelectors.push(trimmed);\n        }\n        //TODO: remove duplicates before returning\n        return groupSelectors;\n    };\n    return HierarchyActions;\n}());\nexports.HierarchyActions = HierarchyActions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODA5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3JlY29yZGVyL1NlbGVjdG9ycy9IaWVyYWNoeUFjdGlvbnMudHM/Zjc2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBBdHRyaWJ1dGVTZWxlY3Rvcl8xID0gcmVxdWlyZShcIi4vQXR0cmlidXRlU2VsZWN0b3JcIik7XG52YXIgSGllcmFyY2h5QWN0aW9ucyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIaWVyYXJjaHlBY3Rpb25zKCkge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZVNlbGVjdG9yID0gbmV3IEF0dHJpYnV0ZVNlbGVjdG9yXzEuQXR0cmlidXRlU2VsZWN0b3IoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFrZXMgMiBjb2xsZWN0aW9ucyBvZiBlbGVtZW50c1xuICAgICAqIFJldHVybnMgYSBzaW5nbGUgQXRycmlidXRlU2VsZWN0b3IgdGhhdCB3aWxsOlxuICAgICAqIC1zZWxlY3QgYWxsIGluY2x1ZGVFbGVtZW50c1xuICAgICAqIC1zZWxlY3Qgbm9uZSBvZiB0aGUgZXhjbHVkZUVsZW1lbnRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5jbHVkZUVsZW1lbnRzIEFycmF5IG9mIEVsZW1lbnRzIHRvIGJlIGluY2x1ZGVkIGluIHRoZSBzZWxlY3Rpb25cbiAgICAgKiBAcGFyYW0gZXhjbHVkZUVsZW1lbnRzIEFycmF5IG9mIEVsZW1lbnRzIHRvIGJlIGV4Y2x1ZGVkIGZyb20gdGhlIHNlbGVjdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMgU3RyaW5nIHRvIGJlIHVzZWQgYXMgYSBzZWxlY3RvciBjb21wYXRhYmxlIHdpdGggZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcjogU3RyaW5nKVxuICAgICAqIEBleGFtcGxlICc6LXdlYmtpdC1hbnkoZGl2LCBib2R5KTpub3QoW2lkPVwiZzJcIl0pID4gOi13ZWJraXQtYW55KGFydGljbGUsIHNlY3Rpb24pW2NsYXNzfj1cInBvc3RcIl06bm90KFtpZD1cImE0XCJdKSA+IGgzOm5vdChbaWQ9XCJoNFwiXSknXG4gICAgICpcbiAgICAgKi9cbiAgICBIaWVyYXJjaHlBY3Rpb25zLnByb3RvdHlwZS5nZXRDb21iaW5lZCA9IGZ1bmN0aW9uIChkb2N1bWVudCwgaW5jbHVkZUVsZW1lbnRzLCBleGNsdWRlRWxlbWVudHMsIHR5cGUpIHtcbiAgICAgICAgaWYgKGluY2x1ZGVFbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5jbHVkZVNlbGVjdG9ycyA9IHRoaXMuZ2V0QXNBdHRyaWJ1dGVTZWxlY3RvcnMoaW5jbHVkZUVsZW1lbnRzKTtcbiAgICAgICAgdmFyIGV4Y2x1ZGVTZWxlY3RvcnMgPSB0aGlzLmdldEFzQXR0cmlidXRlU2VsZWN0b3JzKGV4Y2x1ZGVFbGVtZW50cyk7XG4gICAgICAgIHZhciBpblNlY3Rpb25zID0gW107XG4gICAgICAgIHZhciBleFNlY3Rpb25zID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgaW5jbHVkZVNlbGVjdG9yc18xID0gaW5jbHVkZVNlbGVjdG9yczsgX2kgPCBpbmNsdWRlU2VsZWN0b3JzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBpbmNsdWRlU2VsZWN0b3JzXzFbX2ldO1xuICAgICAgICAgICAgaW5TZWN0aW9ucy5wdXNoKHRoaXMuc3BsaXRIaWVyYXJjaHlTdHJpbmcoc2VsZWN0b3IpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfYSA9IDAsIGV4Y2x1ZGVTZWxlY3RvcnNfMSA9IGV4Y2x1ZGVTZWxlY3RvcnM7IF9hIDwgZXhjbHVkZVNlbGVjdG9yc18xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gZXhjbHVkZVNlbGVjdG9yc18xW19hXTtcbiAgICAgICAgICAgIGV4U2VjdGlvbnMucHVzaCh0aGlzLnNwbGl0SGllcmFyY2h5U3RyaW5nKHNlbGVjdG9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFsbFNlY3Rpb25zID0gW10uY29uY2F0KGluU2VjdGlvbnMsIGV4U2VjdGlvbnMpO1xuICAgICAgICB2YXIgbGV2ZWxzID0gW107XG4gICAgICAgIC8vIFRoZSB0YWdzIGFycmF5cyBhcmUgb3JkZXJlZCB3aXRoIHRoZSBoaWdoZXN0IGVsZW1lbnQgaW4gdGhlIHRyZWUgZmlyc3QsIGFuZCB0aGlzIGNhdXNlcyB0aGluZ3MgdG8gZ28gb3V0IG9mIHN5bmMgd2hlbiBzZWxlY3RvcnMgYXJlIG5vdCBcbiAgICAgICAgLy8gdGhlIHNhbWUgbGVuZ3RoLiBGb3IgZXhhbXBsZSwgYm9keSA+IGRpdiA+IHNwYW4gYW5kIGJvZHkgPiBkaXYgd2lsbCBiZSBjb21wYXJlZCBhcyBbW3NwYW4sIGRpdl0sIFtkaXYsIGJvZHldLCBbYm9keSwgdW5kZWZpbmVkXV0uXG4gICAgICAgIC8vIFRvIGZpeCB0aGlzIHdlIGFkZCBhIG5ldyByZXZlcnNlZCB2ZXJzaW9uIG9mIHRoZSB0YWdzIGFuZCBtb2RpZmVycyB0byBlYWNoIG9mIHRoZSBvYmplY3RzIHdlIGNoZWNrLlxuICAgICAgICBmb3IgKHZhciBfYiA9IDAsIGFsbFNlY3Rpb25zXzEgPSBhbGxTZWN0aW9uczsgX2IgPCBhbGxTZWN0aW9uc18xLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgdmFyIGFzID0gYWxsU2VjdGlvbnNfMVtfYl07XG4gICAgICAgICAgICBhcy50YWdzUmV2ZXJzZWQgPSBhcy50YWdzLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9jID0gMCwgaW5TZWN0aW9uc18xID0gaW5TZWN0aW9uczsgX2MgPCBpblNlY3Rpb25zXzEubGVuZ3RoOyBfYysrKSB7XG4gICAgICAgICAgICB2YXIgaXMgPSBpblNlY3Rpb25zXzFbX2NdO1xuICAgICAgICAgICAgaXMudGFnc1JldmVyc2VkID0gaXMudGFncy5zbGljZSgpLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMb29wIHRocm91Z2ggdGhlIHRhZ3MuIFRoaXMgZW50aXJlIGxvb3AgaXMgaW5zaWRlIG91dC4gV2UgYXJlIGxvb3BpbmcgdGhyb3VnaCB0aGUgaW5uZXIgYXJyYXkgXG4gICAgICAgIC8vICh3aGljaCByZXByZXNlbnRzIHRoZSBwYXJ0cyBvZiB0aGUgaGllcmFyY2h5IGZvciBlYWNoIHNlbGVjdG9yKSwgYXNcbiAgICAgICAgLy8gdGhlIG91dGVyIGxvb3AsIGFuZCB0aGUgb3V0ZXIgYXJyYXkgKHdoaWNoIHJlcHJlc2VudHMgZWFjaCBzZWxlY3RvcikgYXMgdGhlIGlubmVyIGxvb3AuIFRoZSByZWFzb24gZm9yIHRoaXMgaXMgc28gd2UgY2FuIGNvbXBhcmUgdGhlXG4gICAgICAgIC8vIGluZGl2aWR1YWwgcGFydHMgb2YgdGhlIHR3byBzZWxlY3RvciBzdHJpbmdzLlxuICAgICAgICB2YXIgbGFyZ2VzdFRhZ0luZGV4ID0gMDtcbiAgICAgICAgZm9yICh2YXIgX2QgPSAwLCBhbGxTZWN0aW9uc18yID0gYWxsU2VjdGlvbnM7IF9kIDwgYWxsU2VjdGlvbnNfMi5sZW5ndGg7IF9kKyspIHtcbiAgICAgICAgICAgIHZhciBzZWN0aW9uID0gYWxsU2VjdGlvbnNfMltfZF07XG4gICAgICAgICAgICBpZiAoc2VjdGlvbi50YWdzUmV2ZXJzZWQubGVuZ3RoID4gbGFyZ2VzdFRhZ0luZGV4KSB7XG4gICAgICAgICAgICAgICAgbGFyZ2VzdFRhZ0luZGV4ID0gc2VjdGlvbi50YWdzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGFyZ2VzdFRhZ0luZGV4OyBpbmRleCsrKSB7XG4gICAgICAgICAgICAvLyBXZSBsb29wIHRocm91Z2ggdGhlIG91dGVyIGxvb3AgYW5kIGdldCBhbiBhcnJheSBvZiB0YWdzIGFuZCBtb2RpZmllcnMgZm9yIGVhY2ggc2VjdGlvbiBmb3IgdGhpcyBwYXJ0IG9mIHRoZSBoaWVyYXJjaHlcbiAgICAgICAgICAgIHZhciB0YWdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfZSA9IDAsIGluU2VjdGlvbnNfMiA9IGluU2VjdGlvbnM7IF9lIDwgaW5TZWN0aW9uc18yLmxlbmd0aDsgX2UrKykge1xuICAgICAgICAgICAgICAgIHZhciBzZWN0aW9uID0gaW5TZWN0aW9uc18yW19lXTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGFnc1xuICAgICAgICAgICAgICAgIGlmIChzZWN0aW9uLnRhZ3NSZXZlcnNlZFtpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGFncy5wdXNoKHNlY3Rpb24udGFnc1JldmVyc2VkW2luZGV4XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRhZyA9ICcnO1xuICAgICAgICAgICAgaWYgKHRhZ3MubGVuZ3RoID09PSBpblNlY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICh0YWdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0YWcgPSB0YWdzWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZHVjZWRUYWdzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9mID0gMCwgdGFnc18xID0gdGFnczsgX2YgPCB0YWdzXzEubGVuZ3RoOyBfZisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHRhZ3NfMVtfZl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVkdWNlZFRhZ3MuaW5kZXhPZih0KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWR1Y2VkVGFncy5wdXNoKHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWR1Y2VkVGFncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZyA9IHJlZHVjZWRUYWdzWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnID0gXCI6LXdlYmtpdC1hbnkoXCIgKyByZWR1Y2VkVGFncy5qb2luKCcsICcpICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV2ZWxzLnB1c2godGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tYmluZWRTZWxlY3RvciA9ICcnO1xuICAgICAgICBjb21iaW5lZFNlbGVjdG9yID0gbGV2ZWxzLmpvaW4oJyA+ICcpO1xuICAgICAgICBjb21iaW5lZFNlbGVjdG9yID0gY29tYmluZWRTZWxlY3Rvci5yZXBsYWNlKC9cXG4vZywgJycpO1xuICAgICAgICBjb21iaW5lZFNlbGVjdG9yID0gY29tYmluZWRTZWxlY3Rvci5yZXBsYWNlKC9cXHNcXHMvZywgJyAnKTtcbiAgICAgICAgY29tYmluZWRTZWxlY3RvciA9IGNvbWJpbmVkU2VsZWN0b3IucmVwbGFjZSgvXFxbY2xhc3N+PVwiW15cXFNdKlwiXFxdL2csICcnKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzZWxlY3RvcicpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RvcldpdGhOdGhTcGVjaWZpZXJzID0gdGhpcy5hcHBseU50aFNwZWNpZmllcnMoZG9jdW1lbnQsIGNvbWJpbmVkU2VsZWN0b3IsIGluY2x1ZGVFbGVtZW50cywgZXhjbHVkZUVsZW1lbnRzKTtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgc2VsZWN0b3Igc2VsZWN0cyB0aGUgc2FtZSBudW1iZXIgb2YgcmVzdWx0cyBhcyB0aGUgcHJldmlvdXMgb25lLCB3ZSBkb24ndCB1c2UgaXQ7IGl0J3MgbGlrZWx5IHRvbyBzcGVjaWZpYy5cbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGNvbWJpbmVkU2VsZWN0b3IpLmxlbmd0aCAhPT0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcldpdGhOdGhTcGVjaWZpZXJzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb21iaW5lZFNlbGVjdG9yID0gc2VsZWN0b3JXaXRoTnRoU3BlY2lmaWVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF0Y2hlZEVsZW1lbnRzID0gW107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtYXRjaGVkRWxlbWVudHMgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoY29tYmluZWRTZWxlY3RvcikpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICAgICAgY29tYmluZWRTZWxlY3RvciA9IHRoaXMudHJpbUF0dHJpYnV0ZXMoZG9jdW1lbnQsIGNvbWJpbmVkU2VsZWN0b3IsIG1hdGNoZWRFbGVtZW50cywgZXhjbHVkZUVsZW1lbnRzKTtcbiAgICAgICAgY29tYmluZWRTZWxlY3RvciA9IHRoaXMudHJpbUhpZXJhcmNoeShkb2N1bWVudCwgY29tYmluZWRTZWxlY3RvciwgbWF0Y2hlZEVsZW1lbnRzLCBleGNsdWRlRWxlbWVudHMpO1xuICAgICAgICByZXR1cm4gY29tYmluZWRTZWxlY3Rvci5yZXBsYWNlKC9cXDpub3RcXChcXCkvZywgXCJcIik7IC8vIHN0cmlwIGVtcHR5IDpub3QoKSBhdHRyaWJ1dGVzXG4gICAgfTtcbiAgICBIaWVyYXJjaHlBY3Rpb25zLnByb3RvdHlwZS5leGNsdWRlZE1hdGNoZXMgPSBmdW5jdGlvbiAoZG9jdW1lbnQsIHNlbGVjdG9yLCBleGNsdWRlZEVsZW1lbnRzKSB7XG4gICAgICAgIC8vZ2V0IGFsbCBlbGVtZW50cyB0aGF0IGFyZSBjdXJyZW50bHkgbWF0Y2hlZCBieSB0aGUgY29tYmluZWQgc2VsZWN0b3JcbiAgICAgICAgdmFyIG1hdGNoaW5nID0gW107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtYXRjaGluZyA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICAgICAgLy9jaGVjayBmb3IgYW55IGVsZW1lbnRzIGluIGV4Y2x1ZGVFbGVtZW50cyB0aGF0IG1hdGNoZWRcbiAgICAgICAgcmV0dXJuIG1hdGNoaW5nLmZpbHRlcihmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBleGNsdWRlZEVsZW1lbnRzLmluY2x1ZGVzKGVsKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIaWVyYXJjaHlBY3Rpb25zLnByb3RvdHlwZS5taXNNYXRjaGVzID0gZnVuY3Rpb24gKGRvY3VtZW50LCBzZWxlY3RvciwgZXhjbHVkZWRFbGVtZW50cykge1xuICAgICAgICAvL2dldCBhbGwgZWxlbWVudHMgdGhhdCBhcmUgY3VycmVudGx5IG1hdGNoZWQgYnkgdGhlIGNvbWJpbmVkIHNlbGVjdG9yXG4gICAgICAgIHZhciBtYXRjaGluZyA9IFtdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWF0Y2hpbmcgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgICAgIC8vY2hlY2sgZm9yIGFueSBlbGVtZW50cyBub3QgaW5jbHVkZWVkRWxlbWVudHMgdGhhdCBtYXRjaGVkXG4gICAgICAgIHJldHVybiBtYXRjaGluZy5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhjbHVkZWRFbGVtZW50cy5pbmNsdWRlcyhlbCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSGllcmFyY2h5QWN0aW9ucy5wcm90b3R5cGUub3ZlclNlbGVjdGVkID0gZnVuY3Rpb24gKGRvY3VtZW50LCBzZWxlY3RvciwgZWxlbWVudHNUb01hdGNoKSB7XG4gICAgICAgIC8vZ2V0IGFsbCBlbGVtZW50cyB0aGF0IGFyZSBjdXJyZW50bHkgbWF0Y2hlZCBieSB0aGUgY29tYmluZWQgc2VsZWN0b3JcbiAgICAgICAgdmFyIG1hdGNoaW5nID0gW107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtYXRjaGluZyA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICAgICAgLy9jaGVjayBmb3IgYW55IGV4dHJhIGVsZW1lbnRzIHNuZWFraW5nIGluXG4gICAgICAgIHJldHVybiBtYXRjaGluZy5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gIWVsZW1lbnRzVG9NYXRjaC5pbmNsdWRlcyhlbCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSGllcmFyY2h5QWN0aW9ucy5wcm90b3R5cGUubWlzc2luZ0VsZW1lbnRzID0gZnVuY3Rpb24gKGRvY3VtZW50LCBzZWxlY3RvciwgZWxlbWVudHNUb01hdGNoKSB7XG4gICAgICAgIC8vZ2V0IGFsbCBlbGVtZW50cyB0aGF0IGFyZSBjdXJyZW50bHkgbWF0Y2hlZCBieSB0aGUgY29tYmluZWQgc2VsZWN0b3JcbiAgICAgICAgdmFyIG1hdGNoaW5nID0gW107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtYXRjaGluZyA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICAgICAgLy9jaGVjayBmb3IgYW55IG1pc3NpbmcgZWxlbWVudHNcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzVG9NYXRjaC5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gIW1hdGNoaW5nLmluY2x1ZGVzKGVsKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIaWVyYXJjaHlBY3Rpb25zLnByb3RvdHlwZS50cmltSGllcmFyY2h5ID0gZnVuY3Rpb24gKGRvY3VtZW50LCBjb21iaW5lZFNlbGVjdG9yLCBpbmNsdWRlRWxlbWVudHMsIGV4Y2x1ZGVFbGVtZW50cykge1xuICAgICAgICB2YXIgc2VsZWN0b3JMZXZlbHMgPSBjb21iaW5lZFNlbGVjdG9yLnNwbGl0KCcgPiAnKTtcbiAgICAgICAgdmFyIHRyaW1tZWRMZW5ndGggPSBzZWxlY3RvckxldmVscy5sZW5ndGg7XG4gICAgICAgIHZhciB0cmltbWVkU2VsZWN0b3IgPSBzZWxlY3RvckxldmVscy5zbGljZShzZWxlY3RvckxldmVscy5sZW5ndGggLSB0cmltbWVkTGVuZ3RoLCBzZWxlY3RvckxldmVscy5sZW5ndGgpLmpvaW4oJyA+ICcpO1xuICAgICAgICB3aGlsZSAodHJpbW1lZExlbmd0aCA+IDAgJiYgIXRoaXMubWlzc2luZ0VsZW1lbnRzKGRvY3VtZW50LCB0cmltbWVkU2VsZWN0b3IsIGluY2x1ZGVFbGVtZW50cykubGVuZ3RoICYmICF0aGlzLm1pc01hdGNoZXMoZG9jdW1lbnQsIHRyaW1tZWRTZWxlY3RvciwgZXhjbHVkZUVsZW1lbnRzKS5sZW5ndGggJiYgIXRoaXMub3ZlclNlbGVjdGVkKGRvY3VtZW50LCB0cmltbWVkU2VsZWN0b3IsIGluY2x1ZGVFbGVtZW50cykubGVuZ3RoKSB7XG4gICAgICAgICAgICB0cmltbWVkTGVuZ3RoLS07XG4gICAgICAgICAgICB0cmltbWVkU2VsZWN0b3IgPSBzZWxlY3RvckxldmVscy5zbGljZShzZWxlY3RvckxldmVscy5sZW5ndGggLSB0cmltbWVkTGVuZ3RoLCBzZWxlY3RvckxldmVscy5sZW5ndGgpLmpvaW4oJyA+ICcpO1xuICAgICAgICAgICAgaWYgKC9cXDpub3RcXChcXDpudGgvLnRlc3Qoc2VsZWN0b3JMZXZlbHNbc2VsZWN0b3JMZXZlbHMubGVuZ3RoIC0gdHJpbW1lZExlbmd0aF0pKSB7IC8vIGhlcmUgd2UgaGF2ZSBhIHVzZXIgc3BlY2lmaWVkIGV4Y2x1c2lvbiBhbmQgc28gd2Ugc2hvdWxkbid0IHN0cmlwIGl0IG91dFxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RvckxldmVscy5zbGljZShzZWxlY3RvckxldmVscy5sZW5ndGggLSAodHJpbW1lZExlbmd0aCksIHNlbGVjdG9yTGV2ZWxzLmxlbmd0aCkuam9pbignID4gJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yTGV2ZWxzLnNsaWNlKHNlbGVjdG9yTGV2ZWxzLmxlbmd0aCAtICh0cmltbWVkTGVuZ3RoICsgMSksIHNlbGVjdG9yTGV2ZWxzLmxlbmd0aCkuam9pbignID4gJyk7XG4gICAgfTtcbiAgICBIaWVyYXJjaHlBY3Rpb25zLnByb3RvdHlwZS50cmltU2VsZWN0b3IgPSBmdW5jdGlvbiAoZG9jdW1lbnQsIHNlbGVjdG9yLCBpbmNsdWRlRWxlbWVudHMsIGV4Y2x1ZGVFbGVtZW50cykge1xuICAgICAgICB2YXIgc2VsZWN0b3JMZXZlbHMgPSBzZWxlY3Rvci5zcGxpdCgnID4gJyk7XG4gICAgICAgIHZhciB0cmltbWVkTGVuZ3RoID0gc2VsZWN0b3JMZXZlbHMubGVuZ3RoO1xuICAgICAgICB2YXIgdHJpbW1lZFNlbGVjdG9yID0gc2VsZWN0b3JMZXZlbHMuc2xpY2Uoc2VsZWN0b3JMZXZlbHMubGVuZ3RoIC0gdHJpbW1lZExlbmd0aCwgc2VsZWN0b3JMZXZlbHMubGVuZ3RoKS5qb2luKCcgPiAnKTtcbiAgICAgICAgd2hpbGUgKHRyaW1tZWRMZW5ndGggPCBzZWxlY3RvckxldmVscy5sZW5ndGggLSAxICYmICF0aGlzLm1pc3NpbmdFbGVtZW50cyhkb2N1bWVudCwgdHJpbW1lZFNlbGVjdG9yLCBpbmNsdWRlRWxlbWVudHMpLmxlbmd0aCAmJiAhdGhpcy5taXNNYXRjaGVzKGRvY3VtZW50LCB0cmltbWVkU2VsZWN0b3IsIGV4Y2x1ZGVFbGVtZW50cykubGVuZ3RoKSB7XG4gICAgICAgICAgICB0cmltbWVkTGVuZ3RoKys7XG4gICAgICAgICAgICB0cmltbWVkU2VsZWN0b3IgPSBzZWxlY3RvckxldmVscy5zbGljZShzZWxlY3RvckxldmVscy5sZW5ndGggLSB0cmltbWVkTGVuZ3RoLCBzZWxlY3RvckxldmVscy5sZW5ndGgpLmpvaW4oJyA+ICcpO1xuICAgICAgICAgICAgdHJpbW1lZFNlbGVjdG9yID0gdGhpcy50cmltQXR0cmlidXRlcyhkb2N1bWVudCwgdHJpbW1lZFNlbGVjdG9yLCBpbmNsdWRlRWxlbWVudHMsIGV4Y2x1ZGVFbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yTGV2ZWxzLnNsaWNlKHNlbGVjdG9yTGV2ZWxzLmxlbmd0aCAtICh0cmltbWVkTGVuZ3RoICsgMSksIHNlbGVjdG9yTGV2ZWxzLmxlbmd0aCkuam9pbignID4gJyk7XG4gICAgfTtcbiAgICBIaWVyYXJjaHlBY3Rpb25zLnByb3RvdHlwZS50cmltQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChkb2N1bWVudCwgY29tYmluZWRTZWxlY3RvciwgaW5jbHVkZUVsZW1lbnRzLCBleGNsdWRlRWxlbWVudHMpIHtcbiAgICAgICAgdmFyIGFsbEF0dHJpYnV0ZXMgPSBjb21iaW5lZFNlbGVjdG9yLm1hdGNoKC9cXFtbXlxcc1xcW1xcXV0qXFxdL2cpO1xuICAgICAgICBpZiAoYWxsQXR0cmlidXRlcyAmJiBhbGxBdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBhbGxBdHRyaWJ1dGVzXzEgPSBhbGxBdHRyaWJ1dGVzOyBfaSA8IGFsbEF0dHJpYnV0ZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gYWxsQXR0cmlidXRlc18xW19pXTtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGUucmVwbGFjZSgvXFwrL2csIFwiXFxcXCtcIik7XG4gICAgICAgICAgICAgICAgLy8gd2Ugd2lsbCBtYWtlIGEgc2VsZWN0b3IgZm9yIHRlc3Rpbmcgd2hlcmUgYWxsIG9jY3VyYW5jZXMgb2YgYXR0cmlidXRlIGFyZSBzdHJpcHBlZCBvdXRcbiAgICAgICAgICAgICAgICB2YXIgdGVzdFNlbGVjdG9yID0gY29tYmluZWRTZWxlY3Rvci5yZXBsYWNlKG5ldyBSZWdFeHAoYXR0cmlidXRlLnJlcGxhY2UoJ1snLCAnXFxcXFsnKS5yZXBsYWNlKCddJywgJ1xcXFxdJyksICdnJyksIFwiXCIpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5taXNzaW5nRWxlbWVudHMoZG9jdW1lbnQsIHRlc3RTZWxlY3RvciwgaW5jbHVkZUVsZW1lbnRzKS5sZW5ndGggJiYgIXRoaXMubWlzTWF0Y2hlcyhkb2N1bWVudCwgdGVzdFNlbGVjdG9yLCBleGNsdWRlRWxlbWVudHMpLmxlbmd0aCAmJiAhdGhpcy5vdmVyU2VsZWN0ZWQoZG9jdW1lbnQsIHRlc3RTZWxlY3RvciwgaW5jbHVkZUVsZW1lbnRzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tYmluZWRTZWxlY3RvciA9IHRlc3RTZWxlY3RvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkU2VsZWN0b3I7XG4gICAgfTtcbiAgICBIaWVyYXJjaHlBY3Rpb25zLnByb3RvdHlwZS5hcHBseU50aFNwZWNpZmllcnMgPSBmdW5jdGlvbiAoZG9jdW1lbnQsIGNvbWJpbmVkU2VsZWN0b3IsIGluY2x1ZGVFbGVtZW50cywgZXhjbHVkZUVsZW1lbnRzKSB7XG4gICAgICAgIC8vIGVuc3VyZSB0aGVyZSBhcmUgbm8gaGlkZGVuIGVsZW1lbnRzIHNlbGVjdGVkIGJ5IHRoZSBjb21iaW5lZFNlbGVjdG9yIGJlZm9yZSBhZGRpbmcgdGhlIG50aFNlbGVjdG9yc1xuICAgICAgICB2YXIgaW5pdGlhbE1hdGNoZXMgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoY29tYmluZWRTZWxlY3RvcikpO1xuICAgICAgICB2YXIgaW52aXNpYmxlID0gaW5pdGlhbE1hdGNoZXMuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuICEoaW5jbHVkZUVsZW1lbnRzLmluY2x1ZGVzKGVsKSB8fCAkKGVsKS5maWx0ZXIoJzp2aXNpYmxlJykubGVuZ3RoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBudGhNb2RzID0gW107XG4gICAgICAgIC8vIFB1bGwgb3V0IHRoZSBudW1iZXIgb2Ygc2libGluZ3Mgb2YgdGhlIHRhcmdldCBlbGVtZW50IGF0IGVhY2ggZGVwdGhcbiAgICAgICAgLy8gXCJJbmMgTGV2ZWxzXCIgYW5kIFwiRXggTGV2ZWxzXCIgaGVyZSBhcmUgcG9vcmx5IG5hbWVkLCBidXQgYXJlIGJhc2ljYWxseSB0aGUgYXJyYXkgb2YgZWFjaCBzZWxlY3RvcidzIHNpYmxpbmcgY291bnRzLCB0cmFuc3Bvc2VkLlxuICAgICAgICB2YXIgaW5jX2xldmVscyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGluY2x1ZGVFbGVtZW50c18xID0gaW5jbHVkZUVsZW1lbnRzOyBfaSA8IGluY2x1ZGVFbGVtZW50c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGluY2x1ZGUgPSBpbmNsdWRlRWxlbWVudHNfMVtfaV07XG4gICAgICAgICAgICB2YXIgY291bnRzID0gdHJlZUNvdW50KGluY2x1ZGUpO1xuICAgICAgICAgICAgZm9yICh2YXIgbGV2ZWwgaW4gY291bnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5jX2xldmVsc1tsZXZlbF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGluY19sZXZlbHNbbGV2ZWxdLnB1c2goY291bnRzW2xldmVsXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmNfbGV2ZWxzW2xldmVsXSA9IFtjb3VudHNbbGV2ZWxdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV4Y19sZXZlbHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBleGNsdWRlRWxlbWVudHNfMSA9IGV4Y2x1ZGVFbGVtZW50czsgX2EgPCBleGNsdWRlRWxlbWVudHNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgIHZhciBleGNsdWRlID0gZXhjbHVkZUVsZW1lbnRzXzFbX2FdO1xuICAgICAgICAgICAgdmFyIGNvdW50cyA9IHRyZWVDb3VudChleGNsdWRlKTtcbiAgICAgICAgICAgIGZvciAodmFyIGxldmVsIGluIGNvdW50cykge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV4Y19sZXZlbHNbbGV2ZWxdKSkge1xuICAgICAgICAgICAgICAgICAgICBleGNfbGV2ZWxzW2xldmVsXS5wdXNoKGNvdW50c1tsZXZlbF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXhjX2xldmVsc1tsZXZlbF0gPSBbY291bnRzW2xldmVsXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGxldmVsIGluIGluY19sZXZlbHMpIHtcbiAgICAgICAgICAgIHZhciBpbmNfbnRoID0gaW5jX2xldmVsc1tsZXZlbF07XG4gICAgICAgICAgICB2YXIgZXhjX250aCA9IGV4Y19sZXZlbHNbbGV2ZWxdO1xuICAgICAgICAgICAgLy8gVGhpcyBiYXNpY2FsbHkgcmVtb3ZlcyBzdHVmZiBmcm9tIGluY19udGggdGhhdCBpcyBpbiBleGNfbnRoLCBidXQgaXMgZXhwcmVzc2VkIG5lZWRsZXNzbHkgZ2VuZXJpY2FsbHkuXG4gICAgICAgICAgICB2YXIgdW5pcXVlX250aCA9IGdldFVuaXF1ZShpbmNfbnRoLCBleGNfbnRoKTtcbiAgICAgICAgICAgIHZhciBudGhNb2QgPSBnZXROdGhNb2RzKHsgaW5jbHVkZTogaW5jX250aCwgZXhjbHVkZTogdW5pcXVlX250aC5leGNsdWRlIH0pO1xuICAgICAgICAgICAgbnRoTW9kc1tsZXZlbF0gPSAobnRoTW9kICE9PSB1bmRlZmluZWQpID8gbnRoTW9kIDogJyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNwbGl0ID0gY29tYmluZWRTZWxlY3Rvci5zcGxpdCgnID4gJyk7XG4gICAgICAgIHNwbGl0LnJldmVyc2UoKTtcbiAgICAgICAgZm9yICh2YXIgbGV2ZWwgaW4gc3BsaXQpIHtcbiAgICAgICAgICAgIGlmIChudGhNb2RzW2xldmVsXSkge1xuICAgICAgICAgICAgICAgIHNwbGl0W2xldmVsXSArPSBudGhNb2RzW2xldmVsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzcGxpdC5yZXZlcnNlKCk7XG4gICAgICAgIHJldHVybiBzcGxpdC5qb2luKCcgPiAnKTtcbiAgICAgICAgLy8gJ0hFTFBFUicgRlVOQ1RJT05TXG4gICAgICAgIC8vIFNlcmlvdXNseSB0aGVzZSBzaG91bGQgbm90IGJlIG5lc3RlZCAyIGRlZXAgaW4gdGhlIHBhcmVudCBmdW5jdGlvbiwgbmVlZHMgYSByZWZhY3RvciBiYWRseVxuICAgICAgICBmdW5jdGlvbiB0cmVlQ291bnQoZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGNvdW50cyA9IFtdO1xuICAgICAgICAgICAgdmFyIGNoZWNrID0gZWxlbWVudDtcbiAgICAgICAgICAgIHdoaWxlIChjaGVjay5wYXJlbnRFbGVtZW50ICYmIGNoZWNrLnRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY291bnQgPSBjb3VudFNpYmxpbmdzKGNoZWNrKTtcbiAgICAgICAgICAgICAgICBjb3VudHMucHVzaChjb3VudCk7XG4gICAgICAgICAgICAgICAgY2hlY2sgPSBjaGVjay5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvdW50cztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb3VudFNpYmxpbmdzKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBzaWJsaW5nQ291bnQgPSAxO1xuICAgICAgICAgICAgdmFyIG9mVHlwZUNvdW50ID0gMTtcbiAgICAgICAgICAgIHZhciBjaGVjayA9IGVsZW1lbnQ7XG4gICAgICAgICAgICB3aGlsZSAoY2hlY2sucHJldmlvdXNFbGVtZW50U2libGluZyAmJiBjaGVjay50YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgc2libGluZ0NvdW50Kys7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrLnByZXZpb3VzRWxlbWVudFNpYmxpbmcudGFnTmFtZSA9PT0gY2hlY2sudGFnTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBvZlR5cGVDb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGVjayA9IGNoZWNrLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2libGluZ0NvdW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIHJldHVybnMgaXRlbXMgaW4gYSB0aGF0IGFyZW4ndCBpbiBiIGFuZCBpbiBiIHRoYXQgYXJlbid0IGluIGFcbiAgICAgICAgZnVuY3Rpb24gZ2V0VW5pcXVlKGluY2x1ZGUsIGV4Y2x1ZGUpIHtcbiAgICAgICAgICAgIHZhciB1bmlxdWVJbmNsdWRlID0gW107XG4gICAgICAgICAgICBpZiAoaW5jbHVkZSAmJiBpbmNsdWRlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChleGNsdWRlICYmIGV4Y2x1ZGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZUluY2x1ZGUgPSBpbmNsdWRlLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFleGNsdWRlLmluY2x1ZGVzKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIHRoZXJlIGFyZSBubyBleGNsdWRlcyBzcGVjaWZpZWQgYW5kIHNvIGFsbCBpbmNsdWRlcyBhcmUgdW5pcXVlXG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZUluY2x1ZGUgPSBpbmNsdWRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB1bmlxdWVFeGNsdWRlID0gW107XG4gICAgICAgICAgICBpZiAoZXhjbHVkZSAmJiBleGNsdWRlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlICYmIGluY2x1ZGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZUV4Y2x1ZGUgPSBleGNsdWRlLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFpbmNsdWRlLmluY2x1ZGVzKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIHRoZXJlIGFyZSBubyBpbmNsdWRlcyBzcGVjaWZpZWQgYW5kIHNvIGFsbCBleGNsdWRlcyBhcmUgdW5pcXVlXG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZUV4Y2x1ZGUgPSBleGNsdWRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGluY2x1ZGU6IHVuaXF1ZUluY2x1ZGUsIGV4Y2x1ZGU6IHVuaXF1ZUV4Y2x1ZGUgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXROdGhNb2RzKHNhbXBsZSkge1xuICAgICAgICAgICAgdmFyIGluY2x1ZGUgPSB7IHNlcmllczogc2FtcGxlLmluY2x1ZGUsIGRpZmZzOiBbXSwgZXhwYW5kZWRTZXJpZXM6IFtdIH07XG4gICAgICAgICAgICB2YXIgZXhjbHVkZSA9IHsgc2VyaWVzOiBzYW1wbGUuZXhjbHVkZSwgZGlmZnM6IFtdLCBleHBhbmRlZFNlcmllczogW10gfTtcbiAgICAgICAgICAgIC8vIFNvIGEgZGlmZiBoZXJlIGlzIGFuIGFycmF5LCBjb250YWluaW5nIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGVhY2ggY2hvc2VuIGVsZW1lbnQgZm9yIHRoYXQgbGV2ZWwgb2YgdGhlIGhpZXJhcmNoeVxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGUsIGlmIGVsZW1udCAwIGhhcyBzZWxlY3RlZCB0aGUgMm5kIHNpYmxpbmcgYXQgYSBwYXJ0aWN1bGFyIGxldmVsLCBhbmQgZWxlbWVudCAxIGhhcyB0aGUgM3JkLCB0aGlzIGdlbmVyYXRlcyBhIGRpZmYgb2YgMVxuICAgICAgICAgICAgZ2VuRGlmZnMoaW5jbHVkZSk7XG4gICAgICAgICAgICB2YXIgaW5jbHVkZU1ldGEgPSBmaW5kU2VyaWVzKGluY2x1ZGUuc2VyaWVzLCBpbmNsdWRlLmRpZmZzKTtcbiAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gZ2V0U2VyaWVzRm9ybXVsYShpbmNsdWRlTWV0YSk7XG4gICAgICAgICAgICB2YXIgaW5jbHVkZVBhdHRlcm47XG4gICAgICAgICAgICBpZiAocGF0dGVybikge1xuICAgICAgICAgICAgICAgIGluY2x1ZGVQYXR0ZXJuID0gXCI6bnRoLWNoaWxkKFwiICsgcGF0dGVybiArIFwiKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuRGlmZnMoZXhjbHVkZSk7XG4gICAgICAgICAgICBleGNsdWRlID0gZmluZFNlcmllcyhleGNsdWRlLnNlcmllcywgaW5jbHVkZS5kaWZmcyk7XG4gICAgICAgICAgICB2YXIgZXhjbHVkZVBhdHRlcm5zID0gW107XG4gICAgICAgICAgICBpZiAoZXhjbHVkZS5leHBhbmRlZFNlcmllcy5sZW5ndGggJiYgZXhjbHVkZS5kaWZmc1swXSAhPT0gdW5kZWZpbmVkICYmIGV4Y2x1ZGUuc2VyaWVzWzBdICE9PSB1bmRlZmluZWQgJiYgIWhhc0NvbW1vbkl0ZW0oaW5jbHVkZS5zZXJpZXMsIGV4Y2x1ZGUuZXhwYW5kZWRTZXJpZXMpKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2VuZXJhdGUgcGF0dGVyblxuICAgICAgICAgICAgICAgIHZhciBtID0gZXhjbHVkZS5kaWZmc1swXTtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGV4Y2x1ZGUuc2VyaWVzWzBdOyAvLyB1c2Ugc2VyaWVzIHNvIHRoYXQgYW55IHBhdHRlcm4gc3RhcnRzIHdpdGggZmlyc3QgZXhjbHVkZWQgZWxlbWVudFxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAoYyA+IDApID8gXCIrXCIgKyBjIDogKGMgPCAwKSA/IFwiXCIgKyBjIDogJyc7XG4gICAgICAgICAgICAgICAgdmFyIHBhdHRlcm5fMSA9IG0gKyBcIm5cIiArIG9mZnNldDtcbiAgICAgICAgICAgICAgICB2YXIgZXhjX3BhdHRlcm4gPSBcIjpub3QoOm50aC1jaGlsZChcIiArIHBhdHRlcm5fMSArIFwiKSlcIjtcbiAgICAgICAgICAgICAgICBpZiAoIWV4Y2x1ZGVQYXR0ZXJucy5pbmNsdWRlcyhleGNfcGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhjbHVkZVBhdHRlcm5zLnB1c2goZXhjX3BhdHRlcm4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGdlbmVyYXRlIG50aHNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gZXhjbHVkZS5zZXJpZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBleGNfcGF0dGVybiA9IFwiOm5vdCg6bnRoLWNoaWxkKFwiICsgdmFsICsgXCIpKVwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV4Y2x1ZGVQYXR0ZXJucy5pbmNsdWRlcyhleGNfcGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVQYXR0ZXJucy5wdXNoKGV4Y19wYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBudGhNb2RzID0gJyc7XG4gICAgICAgICAgICBpZiAoaW5jbHVkZVBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICBudGhNb2RzICs9IGluY2x1ZGVQYXR0ZXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4Y2x1ZGVQYXR0ZXJucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBudGhNb2RzICs9IFwiXCIgKyBleGNsdWRlUGF0dGVybnMuam9pbignJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnRoTW9kcztcbiAgICAgICAgICAgIC8vIEhFTFBFUiBGVU5DVElPTlNcbiAgICAgICAgICAgIC8vIFNhbWUgYW50aS1wYXR0ZXJuIGFzIHByZXZpb3VzbHlcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdlbkRpZmZzKHNldCkge1xuICAgICAgICAgICAgICAgIHZhciBkaWZmcyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBzZXJpZXMgPSBzZXQuc2VyaWVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VyaWVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3RGlmZiA9IHNlcmllc1tpICsgMV0gLSBzZXJpZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdEaWZmID4gMCAmJiAhZGlmZnMuaW5jbHVkZXMobmV3RGlmZikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZzLnB1c2gobmV3RGlmZik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0LmRpZmZzID0gZGlmZnM7XG4gICAgICAgICAgICAgICAgc2V0LnNvcnRlZERpZmZzID0gZGlmZnMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBoYXNDb21tb25JdGVtKGEsIGIpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tbW9uSXRlbSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgYV8xID0gYTsgX2kgPCBhXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gYV8xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIuaW5jbHVkZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1vbkl0ZW0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tb25JdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gYWxsRm91bmRJbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBhXzIgPSBhOyBfaSA8IGFfMi5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBhXzJbX2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWIuaW5jbHVkZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldEV4cGFuZGVkU2VyaWVzKHNlcmllcywgc3RlcFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGV4cGFuZGVkU2VyaWVzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIHNvcnRlZFNlcmllcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc2VyaWVzKSk7XG4gICAgICAgICAgICAgICAgc29ydGVkU2VyaWVzLnNvcnQoZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpZmYgPSBiIC0gYTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIHNlcmllc0xpbWl0ID0gc29ydGVkU2VyaWVzW3NvcnRlZFNlcmllcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICB2YXIgc2VyaWVzU3RhcnQgPSBzZXJpZXNMaW1pdCAlIHN0ZXBWYWx1ZTtcbiAgICAgICAgICAgICAgICBleHBhbmRlZFNlcmllcy5wdXNoKHNlcmllc0xpbWl0KTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZXhwYW5kZWRTZXJpZXNbMF0gPiBzZXJpZXNTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBleHBhbmRlZFNlcmllcy51bnNoaWZ0KGV4cGFuZGVkU2VyaWVzWzBdIC0gc3RlcFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cGFuZGVkU2VyaWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZmluZFNlcmllcyhzZXJpZXMsIGRpZmZzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHsgc2VyaWVzOiBzZXJpZXMsIGV4cGFuZGVkU2VyaWVzOiBbXSwgZGlmZnM6IFtdIH07XG4gICAgICAgICAgICAgICAgaWYgKCFkaWZmcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmV4cGFuZGVkU2VyaWVzID0gW3Nlcmllc1swXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RlcFZhbHVlID0gZGlmZnNbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGVwVmFsdWUgPiAwICYmICFkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVzdFNlcmllcyA9IGdldEV4cGFuZGVkU2VyaWVzKHNlcmllcywgc3RlcFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbGxGb3VuZEluKHNlcmllcywgdGVzdFNlcmllcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7IHNlcmllczogc2VyaWVzLCBleHBhbmRlZFNlcmllczogdGVzdFNlcmllcywgZGlmZnM6IFtzdGVwVmFsdWVdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwVmFsdWUtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0U2VyaWVzRm9ybXVsYShzZXRPYmplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgbTsgLy8gKG11bHRpcGxpZXIpXG4gICAgICAgICAgICAgICAgdmFyIGM7IC8vICh4IHNoaWZ0KVxuICAgICAgICAgICAgICAgIC8vIHNldCBtIHZhbHVlIChtdWx0aXBsaWVyKVxuICAgICAgICAgICAgICAgIGlmICghc2V0T2JqZWN0LmRpZmZzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBtID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG0gPSBzZXRPYmplY3QuZGlmZnNbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHNldCBjIHZhbHVlICh4IHNoaWZ0KVxuICAgICAgICAgICAgICAgIGlmIChtID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBzZXRPYmplY3QuZXhwYW5kZWRTZXJpZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIiArIGM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGMgPSAoc2V0T2JqZWN0LmV4cGFuZGVkU2VyaWVzWzBdICE9PSB1bmRlZmluZWQpID8gc2V0T2JqZWN0LmV4cGFuZGVkU2VyaWVzWzBdIC0gbSA6IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBudGhEZXNjcmlwdG9yID0gbSArIFwibiBcIjtcbiAgICAgICAgICAgICAgICBpZiAoYyAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG50aERlc2NyaXB0b3IgKz0gJysnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG50aERlc2NyaXB0b3IgKz0gXCJcIiArIGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudGhEZXNjcmlwdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUYWtlcyBhbiBhcnJheSBvZiBFbGVtZW50cyBhbmQgcmV0dXJucyBhbiBBcnJheSBvZiBBdHRyaWJ1dGVTZWxlY3RvcnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtZW50cyBBcnJheSBvZiB0eXBlIEVsZW1lbnRzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBcnJheSBvZiBBdHRyaWJ1dGVTZWxlY3RvcnNcbiAgICAgKiBAZXhhbXBsZSBbXG4gICAgICogICAgICAgICAgICAgICdib2R5ID4gdGFibGVbaWQ9XCJhMVwiXSA+IHRyW2lkPVwiYjJcIl0gPiBkaXZbaWQ9XCJjMVwiXSA+IGRpdltpZD1cImcxXSA+IGFydGljbGVbaWQ9XCJhMlwiXVtjbGFzc349XCJwb3N0XCJdID4gaDNbaWQ9XCJoMlwiXScsXG4gICAgICogICAgICAgICAgICAgICdib2R5ID4gZGl2W2lkPVwiZzNdID4gYXJ0aWNsZVtpZD1cImE5XCJdW2NsYXNzfj1cInBvc3RcIl0gPiBoM1tpZD1cImg5XCJdJ1xuICAgICAqICAgICAgICAgICAgICAnYm9keSA+IHNlY3Rpb25bY2xhc3N+PVwicG9zdFwiXSA+IGgzW2lkPVwiaDEwXCJdJ1xuICAgICAqICAgICAgICAgIF1cbiAgICAgKi9cbiAgICBIaWVyYXJjaHlBY3Rpb25zLnByb3RvdHlwZS5nZXRBc0F0dHJpYnV0ZVNlbGVjdG9ycyA9IGZ1bmN0aW9uIChlbGVtZW50cywgZG9jdW1lbnQsIGV4Y2x1ZGVFbGVtZW50cykge1xuICAgICAgICB2YXIgYXR0cmlidXRlU2VsZWN0b3JzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgZWxlbWVudHNfMSA9IGVsZW1lbnRzOyBfaSA8IGVsZW1lbnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBlbGVtZW50c18xW19pXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnIHx8ICEoT2JqZWN0LmtleXMoZWwpLmxlbmd0aCA9PT0gMCAmJiBlbC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IHRoaXMuYXR0cmlidXRlU2VsZWN0b3IuZ2V0U2VsZWN0b3IoZWwpO1xuICAgICAgICAgICAgICAgIHZhciB0cmltbWVkU2VsZWN0b3IgPSAoZG9jdW1lbnQgPT09IHVuZGVmaW5lZCkgPyBzZWxlY3RvciA6IHRoaXMudHJpbUF0dHJpYnV0ZXMoZG9jdW1lbnQsIHNlbGVjdG9yLCBbZWxdLCBleGNsdWRlRWxlbWVudHMpO1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZVNlbGVjdG9ycy5wdXNoKHRyaW1tZWRTZWxlY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZVNlbGVjdG9ycztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGhpZXJhcmNoeVN0cmluZyBTdHJpbmcgYmFzZWQgb24gdGhlIGNzcyBoaWVyYWNoeSBzZWxlY3RvclxuICAgICAqXG4gICAgICogQGV4YW1wbGUgc3BsaXRIaWVyYXJjaHlTdHJpbmcoJ2JvZHkgPiB0YWJsZVtpZD1cImExXCJdID4gdHJbaWQ9XCJiMVwiXSA+IGRpdltpZD1cImMxXCJdW2NsYXNzfj1cInRhcmdldFwiXTpub3QoXCIuc3RpY2t5XCIpID4gZGl2W2lkPVwiZzFdID4gYXJ0aWNsZVtpZD1cImExXCJdW2NsYXNzfj1cInBvc3RcIl0gPiBoM1tpZD1cImgxXCJdJylcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIE9iamVjdCB7XG4gICAgICogICAgICAgICAgICAgICAgICAgIGhpZXJhcmNoeVN0cmluZywgKGlucHV0IHBhcmFtIFN0cmluZylcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgdGFncywgICAgICAgICAgICAoaHRtbCB0YWdzIGZyb20gaW5wdXQgc3RyaW5nKVxuICAgICAqICAgICAgICAgICAgICAgICAgICBtb2RzLCAgICAgICAgICAgIChjc3Mgc2VsZWN0b3JzIGFwcGxpZWQgdG8gZWFjaCBodG1sIHRhZylcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgc2VwZXJhdG9ycyAgICAgICAoaGllcmFyY2h5IHNlcGVyYXRvcnMgYXMgc3RyaW5ncylcbiAgICAgKiAgICAgICAgICB9XG4gICAgICogQGV4YW1wbGUge1xuICAgICAqICAgICAgaGllcmFjaHlTdHJpbmc6ICdib2R5ID4gdGFibGVbaWQ9XCJhMVwiXSA+IHRyW2lkPVwiYjFcIl0gPiBkaXZbaWQ9XCJjMVwiXVtjbGFzc349XCJ0YXJnZXRcIl06bm90KFwiLnN0aWNreVwiKSA+IGRpdltpZD1cImcxXSA+IGFydGljbGVbaWQ9XCJhMVwiXVtjbGFzc349XCJwb3N0XCJdID4gaDNbaWQ9XCJoMVwiXScsXG4gICAgICogICAgICB0YWdzOiBbJ2JvZHknLCAndGFibGUnLCAndHInLCAnZGl2JywgJ2RpdicsICdhcnRpY2xlJywgJ2gzJ11cbiAgICAgKiAgICAgIG1vZHM6IFsnJywgJ1tpZD1cImExXCJdJywgJ1tpZD1cImIxXCJdJywgJycsICdbaWQ9XCJjMVwiXVtjbGFzc349XCJ0YXJnZXRcIl06bm90KFwiLnN0aWNreVwiKScsICdbaWQ9XCJnMV0nLCAnW2lkPVwiYTFcIl1bY2xhc3N+PVwicG9zdFwiXScsICdbaWQ9XCJoMVwiXSddLFxuICAgICAqICAgICAgc2VwZXJhdG9yczogWycgPiAnLCAnID4gJywgJyA+ICcsICcgPiAnLCAnID4gJywgJyA+ICddXG4gICAgICogfVxuICAgICAqL1xuICAgIEhpZXJhcmNoeUFjdGlvbnMucHJvdG90eXBlLnNwbGl0SGllcmFyY2h5U3RyaW5nID0gZnVuY3Rpb24gKGhpZXJhcmNoeVN0cmluZykge1xuICAgICAgICAvLyBnZXQgdGhlIHNlcGVyYXRvciBzdHJpbmdzIGJldHdlZW4gZWFjaCBsZXZlbFxuICAgICAgICB2YXIgc2VwZXJhdG9ycyA9IFtdOyAvLyBhIHNlcGVyYXRlciBwZXIgbGV2ZWwgZS5nLiAnID4gJ1xuICAgICAgICB2YXIgc2VjdGlvbnMgPSBoaWVyYXJjaHlTdHJpbmcuc3BsaXQoL1tcXHNdW1xcc10qLyk7XG4gICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgc2VjdGlvbnMubGVuZ3RoIC0gMTsgcysrKSB7IC8vIHBvcHVsYXRlIHNlcGVyYXRvcnNcbiAgICAgICAgICAgIHNlcGVyYXRvcnMucHVzaCgnID4gJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3BsaXQgdGhlIGhpZXJhcmNoeSBpbnRvIGxldmVsc1xuICAgICAgICB2YXIgbGV2ZWxzID0gaGllcmFyY2h5U3RyaW5nLnNwbGl0KCcgPiAnKS5yZXZlcnNlKCk7XG4gICAgICAgIC8vIGdldCB0aGUgaHRtbCB0YWcgYW5kIG1vZGlmaWVycyAoYXR0cmlidXRlIGFuZCBhbGlhcyBzZWxlY3RvcnMpIGF0IGVhY2ggbGV2ZWwgb2YgdGhlIGhpZXJhcmNoeVxuICAgICAgICB2YXIgdGFncyA9IFtdOyAvLyBhIGh0bWwgdGFnIHBlciBsZXZlbFxuICAgICAgICB2YXIgbW9kcyA9IFtdOyAvLyBhIFN0cmluZyB3aXRoIGFsbCBtb2RpZmllciBzZWxlY3RvciBhdCBlYWNoIGxldmVsXG4gICAgICAgIGZvciAodmFyIGRlcHRoID0gMDsgZGVwdGggPCBsZXZlbHMubGVuZ3RoOyBkZXB0aCsrKSB7XG4gICAgICAgICAgICB0YWdzW2RlcHRoXSA9IGxldmVsc1tkZXB0aF0uc3BsaXQoL1tcXFtcXDpdLylbMF07XG4gICAgICAgICAgICBtb2RzW2RlcHRoXSA9IGxldmVsc1tkZXB0aF0uc3Vic3RyKHRhZ3NbZGVwdGhdLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhpZXJhcmNoeVN0cmluZzogaGllcmFyY2h5U3RyaW5nLFxuICAgICAgICAgICAgdGFnczogdGFncyxcbiAgICAgICAgICAgIG1vZHM6IG1vZHMsXG4gICAgICAgICAgICBzZXBlcmF0b3JzOiBzZXBlcmF0b3JzIC8vVE9ETzogcmVkdW5kYW50P1xuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBjb2xsZWN0aW9uIG9mIGFycmF5cyBhbmQgY29tcGFyZXMgdGhlIGl0ZW1zIGluIGVhY2ggYXJyYXlcbiAgICAgKiByZXR1cm4gYSBjb2xsZWN0aW9uIG9mIGl0ZW1zIHRoYXQgY2FuIGJlIGZvdW5kIGluIGFsbCB0aGUgYXJyYXlzIHByb3ZpZGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJyYXlzIEFycmF5IG9mIEFycmF5c1xuICAgICAqXG4gICAgICogQHJldHVybnMgQXJyYXkgb2YgaXRlbXMgY29tbW9uIHRvIGFsbCBhcnJheXMgcHJvdmlkZWQgaW4gdGhlIGFycmF5cyBwYXJhbVxuICAgICAqIEBleGFtcGxlIGdldENvbW1vbkl0ZW1zKFtbMSwyLDMsNCw1LDYsNyw4LDksMTAsMTEsMTJdLCBbMiw0LDYsOCwxMCwxMl0sIFs0LDgsMTJdXSlcbiAgICAgKlxuICAgICAqIFs0LCAxMl1cbiAgICAgKi9cbiAgICBIaWVyYXJjaHlBY3Rpb25zLnByb3RvdHlwZS5nZXRDb21tb25JdGVtcyA9IGZ1bmN0aW9uIChhcnJheXMpIHtcbiAgICAgICAgaWYgKGFycmF5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyYXlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5c1swXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tbW9uSXRlbXMgPSBbXTtcbiAgICAgICAgdmFyIGNvdW50ID0ge307XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgYXJyYXlzXzEgPSBhcnJheXM7IF9pIDwgYXJyYXlzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGFycmF5c18xW19pXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvdW50W2FbaV1dID0gKGNvdW50W2FbaV1dID09PSB1bmRlZmluZWQpID8gY291bnRbYVtpXV0gPSAxIDogY291bnRbYVtpXV0gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjb3VudHMgPSBPYmplY3QudmFsdWVzKGNvdW50KTtcbiAgICAgICAgdmFyIGl0ZW1zID0gT2JqZWN0LmtleXMoY291bnQpO1xuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNvdW50cy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgaWYgKGNvdW50c1tjXSA9PT0gYXJyYXlzLmxlbmd0aCkgeyAvL2l0ZW0gd2FzIGZvdW5kIGluIGFsbCBhcnJheXNcbiAgICAgICAgICAgICAgICBjb21tb25JdGVtcy5wdXNoKGl0ZW1zW2NdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tbW9uSXRlbXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUYWtlcyBhbiBhcnJheSBhbmQgYSBjb2xsZWN0aW9uIG9mIGFycmF5c1xuICAgICAqIGFuZCBmaW5kcyB0aGUgaXRlbXMgdGhhdCBhcmUgdW5pcXVlIHRvIHRoZSBzaW5nbGUgQXJyYXlcbiAgICAgKiBhbmQgaXRlbXMgdGhhdCBhcmUgaW4gdGhlIGFycmF5cyBidXQgbm90IGluIHRoZSBzaW5nbGUgYXJyYXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzaW5nbGVBcnJheSBBcnJheSBvZiBpdGVtc1xuICAgICAqIEBwYXJhbSBhcnJheXMgQXJyYXkgb2YgQXJyYXkgb2YgaXRlbXNcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIGdldERpZmYoWzMsNiw5LDEyXSwgW1syLDQsNiw4LDEwLDEyXSwgWzQsOCwxMl1dKVxuICAgICAqXG4gICAgICogQHJldHVybnMgT2JqZWN0IHtcbiAgICAgKiAgICAgICAgICAgICAgdW5pcXVlLCAoSXRlbXMgdW5pcXVlIHRvIHRoZSBhcnJheSlcbiAgICAgKiAgICAgICAgICAgICAgbWlzc2luZywgKEl0ZW1zIGVhY2ggYXJyYXkgaW4gYXJyYXlzIGJ1dCBub3QgaW4gdGhlIHNpbmxnZSBhcnJheSlcbiAgICAgKiAgICAgICAgICB9XG4gICAgICogQGV4YW1wbGUge1xuICAgICAqICAgICAgdW5pcXVlOiBbMyw5XSxcbiAgICAgKiAgICAgIG1pc3Npbmc6IFs0LDhdXG4gICAgICogfVxuICAgICAqL1xuICAgIEhpZXJhcmNoeUFjdGlvbnMucHJvdG90eXBlLmdldERpZmYgPSBmdW5jdGlvbiAoc2luZ2xlQXJyYXksIGFycmF5cykge1xuICAgICAgICB2YXIgdW5pcXVlID0gW107XG4gICAgICAgIHZhciBtaXNzaW5nID0gW107XG4gICAgICAgIHZhciBjb21tb24gPSB0aGlzLmdldENvbW1vbkl0ZW1zKGFycmF5cyk7XG4gICAgICAgIG1pc3NpbmcgPSBjb21tb24uZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gc2luZ2xlQXJyYXkuaW5kZXhPZihpdGVtKSA9PT0gLTE7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNpbmdsZUFycmF5XzEgPSBzaW5nbGVBcnJheTsgX2kgPCBzaW5nbGVBcnJheV8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBzaW5nbGVBcnJheV8xW19pXTtcbiAgICAgICAgICAgIHZhciBleGNsdXNpdmUgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBhcnJheXNfMiA9IGFycmF5czsgX2EgPCBhcnJheXNfMi5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJyID0gYXJyYXlzXzJbX2FdO1xuICAgICAgICAgICAgICAgIGlmIChhcnIuaW5kZXhPZihpdGVtKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1c2l2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleGNsdXNpdmUpIHtcbiAgICAgICAgICAgICAgICB1bmlxdWUucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB1bmlxdWU6IHVuaXF1ZSwgbWlzc2luZzogbWlzc2luZyB9O1xuICAgIH07XG4gICAgSGllcmFyY2h5QWN0aW9ucy5wcm90b3R5cGUuc2VsZWN0b3JBdExldmVsID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBsZXZlbCkge1xuICAgICAgICB2YXIgbGV2ZWxzID0gc2VsZWN0b3Iuc3BsaXQoJyA+ICcpO1xuICAgICAgICB2YXIgcmVzID0gKGxldmVscy5sZW5ndGggLSBsZXZlbCA+IDApID8gbGV2ZWxzLnNsaWNlKDAsIGxldmVscy5sZW5ndGggLSBsZXZlbCkuam9pbignID4gJykgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBIaWVyYXJjaHlBY3Rpb25zLnByb3RvdHlwZS50ZXN0U2VsZWN0b3JBdExldmVsU2VsZWN0b3JzID0gZnVuY3Rpb24gKGRvY3VtZW50LCBzZWxlY3RvciwgYWxsU2VsZWN0b3JzLCBncm91cHMpIHtcbiAgICAgICAgdmFyIHRlc3RHcm91cCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWF0Y2hlcyA9IEFycmF5LmZyb20odGVzdEdyb3VwLnF1ZXJ5U2VsZWN0b3JBbGwoYWxsU2VsZWN0b3JzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIGZhaWxpbmcgdG8gdXNlIHNlbGVjdG9yIG9uIGVsZW1lbnQsIG5vIGFjdGlvbiByZXF1aXJlZFxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBncm91cHNbMF07IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBfYVtfaV07XG4gICAgICAgICAgICBpZiAoIW1hdGNoZXMuaW5jbHVkZXMoZWwpKSB7XG4gICAgICAgICAgICAgICAgLy8gdGVzdEdyb3VwIGlzIG9uZSBzdGVwIHRvbyBsYXJnZVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEhpZXJhcmNoeUFjdGlvbnMucHJvdG90eXBlLnRlc3RTZWxlY3RvckF0TGV2ZWxHcm91cGluZyA9IGZ1bmN0aW9uIChkb2N1bWVudCwgc2VsZWN0b3IsIGFsbFNlbGVjdG9ycywgZ3JvdXBzKSB7XG4gICAgICAgIHZhciB0ZXN0R3JvdXAgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1hdGNoZXMgPSBBcnJheS5mcm9tKHRlc3RHcm91cC5xdWVyeVNlbGVjdG9yQWxsKGFsbFNlbGVjdG9ycykpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBmYWlsaW5nIHRvIHVzZSBzZWxlY3RvciBvbiBlbGVtZW50LCBubyBhY3Rpb24gcmVxdWlyZWRcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG1hdGNoZXNfMSA9IG1hdGNoZXM7IF9pIDwgbWF0Y2hlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gbWF0Y2hlc18xW19pXTtcbiAgICAgICAgICAgIGlmICghZ3JvdXBzWzBdLmluY2x1ZGVzKG1hdGNoKSkge1xuICAgICAgICAgICAgICAgIC8vIHRlc3RHcm91cCBpcyBvbmUgc3RlcCB0b28gbGFyZ2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBIaWVyYXJjaHlBY3Rpb25zLnByb3RvdHlwZS5maW5kR3JvdXBTZWxlY3RvcnMgPSBmdW5jdGlvbiAoZG9jdW1lbnQsIHNlbGVjdG9ycywgZ3JvdXBzKSB7XG4gICAgICAgIHZhciBhbGxTZWxlY3RvcnMgPSBzZWxlY3RvcnMuam9pbignLCcpO1xuICAgICAgICB2YXIgZ3JvdXBTZWxlY3RvcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzZWxlY3RvcnNfMSA9IHNlbGVjdG9yczsgX2kgPCBzZWxlY3RvcnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IHNlbGVjdG9yc18xW19pXTtcbiAgICAgICAgICAgIHZhciB0cmltbWVkID0gJ2JvZHknO1xuICAgICAgICAgICAgdmFyIGxldmVsID0gMDtcbiAgICAgICAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAodHJpbW1lZCAhPT0gdW5kZWZpbmVkICYmICFkb25lKSB7XG4gICAgICAgICAgICAgICAgdHJpbW1lZCA9IHRoaXMuc2VsZWN0b3JBdExldmVsKHNlbGVjdG9yLCBsZXZlbCk7XG4gICAgICAgICAgICAgICAgdmFyIHRlc3RBID0gdGhpcy50ZXN0U2VsZWN0b3JBdExldmVsU2VsZWN0b3JzKGRvY3VtZW50LCB0cmltbWVkLCBhbGxTZWxlY3RvcnMsIGdyb3Vwcyk7XG4gICAgICAgICAgICAgICAgdmFyIHRlc3RCID0gdGhpcy50ZXN0U2VsZWN0b3JBdExldmVsR3JvdXBpbmcoZG9jdW1lbnQsIHRyaW1tZWQsIGFsbFNlbGVjdG9ycywgZ3JvdXBzKTtcbiAgICAgICAgICAgICAgICBpZiAodGVzdEEgJiYgIXRlc3RCKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlc3RCKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmltbWVkID0gdGhpcy5zZWxlY3RvckF0TGV2ZWwoc2VsZWN0b3IsIGxldmVsIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncm91cFNlbGVjdG9ycy5wdXNoKHRyaW1tZWQpO1xuICAgICAgICB9XG4gICAgICAgIC8vVE9ETzogcmVtb3ZlIGR1cGxpY2F0ZXMgYmVmb3JlIHJldHVybmluZ1xuICAgICAgICByZXR1cm4gZ3JvdXBTZWxlY3RvcnM7XG4gICAgfTtcbiAgICByZXR1cm4gSGllcmFyY2h5QWN0aW9ucztcbn0oKSk7XG5leHBvcnRzLkhpZXJhcmNoeUFjdGlvbnMgPSBIaWVyYXJjaHlBY3Rpb25zO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///809\n")},810:function(module,exports,__webpack_require__){"use strict";eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nvar ClassSelector_1 = __importDefault(__webpack_require__(811));\nvar ElementSelector_1 = __importDefault(__webpack_require__(812));\nvar HierarchySelector_1 = __importDefault(__webpack_require__(813));\nvar IdSelector_1 = __importDefault(__webpack_require__(815));\nvar InnerTextSelector_1 = __importDefault(__webpack_require__(816));\nvar ParentElementSelector_1 = __importDefault(__webpack_require__(817));\n/**\n * When the simmer selector fails, uses the naive hierarchy selector as a fallback\n */\nvar SelectorFacade = /** @class */ (function () {\n    function SelectorFacade(multiple) {\n        if (multiple === void 0) { multiple = false; }\n        this.multiple = multiple;\n        this.classSelector = new ClassSelector_1.default();\n        this.hierarchySelector = new HierarchySelector_1.default();\n        this.elementSelector = new ElementSelector_1.default();\n        this.innerTextSelector = new InnerTextSelector_1.default();\n        this.parentElementSelector = new ParentElementSelector_1.default();\n        this.idSelector = new IdSelector_1.default();\n    }\n    SelectorFacade.prototype.getSelector = function (element) {\n        var selected = false;\n        var classSelector = this.classSelector.getSelector(element);\n        var hierarchySelector = this.hierarchySelector.getSelector(element);\n        var elementSelector = this.elementSelector.getSelector(element);\n        var innerTextSelector = this.innerTextSelector.getSelector(element);\n        var parentElementSelector = this.parentElementSelector.getSelector(element);\n        var idSelector = this.idSelector.getSelector(element);\n        selected = this.generateAxiomSelector(hierarchySelector, elementSelector, parentElementSelector, innerTextSelector, classSelector, idSelector);\n        return selected;\n    };\n    SelectorFacade.prototype.generateAxiomSelector = function (hierarchy, targetElement, targetParent, innerText, classSel, idSel) {\n        var axSel = {\n            hierarchy: hierarchy,\n            targetElement: targetElement,\n            targetParent: targetParent,\n            innerText: innerText,\n            class: classSel,\n            id: idSel\n        };\n        return axSel;\n    };\n    return SelectorFacade;\n}());\nexports.SelectorFacade = SelectorFacade;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODEwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3JlY29yZGVyL1NlbGVjdG9ycy9TZWxlY3RvckZhY2FkZS50cz8wNDkxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIENsYXNzU2VsZWN0b3JfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9DbGFzc1NlbGVjdG9yXCIpKTtcbnZhciBFbGVtZW50U2VsZWN0b3JfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9FbGVtZW50U2VsZWN0b3JcIikpO1xudmFyIEhpZXJhcmNoeVNlbGVjdG9yXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vSGllcmFyY2h5U2VsZWN0b3JcIikpO1xudmFyIElkU2VsZWN0b3JfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9JZFNlbGVjdG9yXCIpKTtcbnZhciBJbm5lclRleHRTZWxlY3Rvcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL0lubmVyVGV4dFNlbGVjdG9yXCIpKTtcbnZhciBQYXJlbnRFbGVtZW50U2VsZWN0b3JfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9QYXJlbnRFbGVtZW50U2VsZWN0b3JcIikpO1xuLyoqXG4gKiBXaGVuIHRoZSBzaW1tZXIgc2VsZWN0b3IgZmFpbHMsIHVzZXMgdGhlIG5haXZlIGhpZXJhcmNoeSBzZWxlY3RvciBhcyBhIGZhbGxiYWNrXG4gKi9cbnZhciBTZWxlY3RvckZhY2FkZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZWxlY3RvckZhY2FkZShtdWx0aXBsZSkge1xuICAgICAgICBpZiAobXVsdGlwbGUgPT09IHZvaWQgMCkgeyBtdWx0aXBsZSA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMubXVsdGlwbGUgPSBtdWx0aXBsZTtcbiAgICAgICAgdGhpcy5jbGFzc1NlbGVjdG9yID0gbmV3IENsYXNzU2VsZWN0b3JfMS5kZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuaGllcmFyY2h5U2VsZWN0b3IgPSBuZXcgSGllcmFyY2h5U2VsZWN0b3JfMS5kZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuZWxlbWVudFNlbGVjdG9yID0gbmV3IEVsZW1lbnRTZWxlY3Rvcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5pbm5lclRleHRTZWxlY3RvciA9IG5ldyBJbm5lclRleHRTZWxlY3Rvcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5wYXJlbnRFbGVtZW50U2VsZWN0b3IgPSBuZXcgUGFyZW50RWxlbWVudFNlbGVjdG9yXzEuZGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmlkU2VsZWN0b3IgPSBuZXcgSWRTZWxlY3Rvcl8xLmRlZmF1bHQoKTtcbiAgICB9XG4gICAgU2VsZWN0b3JGYWNhZGUucHJvdG90eXBlLmdldFNlbGVjdG9yID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBjbGFzc1NlbGVjdG9yID0gdGhpcy5jbGFzc1NlbGVjdG9yLmdldFNlbGVjdG9yKGVsZW1lbnQpO1xuICAgICAgICB2YXIgaGllcmFyY2h5U2VsZWN0b3IgPSB0aGlzLmhpZXJhcmNoeVNlbGVjdG9yLmdldFNlbGVjdG9yKGVsZW1lbnQpO1xuICAgICAgICB2YXIgZWxlbWVudFNlbGVjdG9yID0gdGhpcy5lbGVtZW50U2VsZWN0b3IuZ2V0U2VsZWN0b3IoZWxlbWVudCk7XG4gICAgICAgIHZhciBpbm5lclRleHRTZWxlY3RvciA9IHRoaXMuaW5uZXJUZXh0U2VsZWN0b3IuZ2V0U2VsZWN0b3IoZWxlbWVudCk7XG4gICAgICAgIHZhciBwYXJlbnRFbGVtZW50U2VsZWN0b3IgPSB0aGlzLnBhcmVudEVsZW1lbnRTZWxlY3Rvci5nZXRTZWxlY3RvcihlbGVtZW50KTtcbiAgICAgICAgdmFyIGlkU2VsZWN0b3IgPSB0aGlzLmlkU2VsZWN0b3IuZ2V0U2VsZWN0b3IoZWxlbWVudCk7XG4gICAgICAgIHNlbGVjdGVkID0gdGhpcy5nZW5lcmF0ZUF4aW9tU2VsZWN0b3IoaGllcmFyY2h5U2VsZWN0b3IsIGVsZW1lbnRTZWxlY3RvciwgcGFyZW50RWxlbWVudFNlbGVjdG9yLCBpbm5lclRleHRTZWxlY3RvciwgY2xhc3NTZWxlY3RvciwgaWRTZWxlY3Rvcik7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICB9O1xuICAgIFNlbGVjdG9yRmFjYWRlLnByb3RvdHlwZS5nZW5lcmF0ZUF4aW9tU2VsZWN0b3IgPSBmdW5jdGlvbiAoaGllcmFyY2h5LCB0YXJnZXRFbGVtZW50LCB0YXJnZXRQYXJlbnQsIGlubmVyVGV4dCwgY2xhc3NTZWwsIGlkU2VsKSB7XG4gICAgICAgIHZhciBheFNlbCA9IHtcbiAgICAgICAgICAgIGhpZXJhcmNoeTogaGllcmFyY2h5LFxuICAgICAgICAgICAgdGFyZ2V0RWxlbWVudDogdGFyZ2V0RWxlbWVudCxcbiAgICAgICAgICAgIHRhcmdldFBhcmVudDogdGFyZ2V0UGFyZW50LFxuICAgICAgICAgICAgaW5uZXJUZXh0OiBpbm5lclRleHQsXG4gICAgICAgICAgICBjbGFzczogY2xhc3NTZWwsXG4gICAgICAgICAgICBpZDogaWRTZWxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF4U2VsO1xuICAgIH07XG4gICAgcmV0dXJuIFNlbGVjdG9yRmFjYWRlO1xufSgpKTtcbmV4cG9ydHMuU2VsZWN0b3JGYWNhZGUgPSBTZWxlY3RvckZhY2FkZTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///810\n')},811:function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ClassSelector = /** @class */ (function () {\n    function ClassSelector() {\n    }\n    ClassSelector.prototype.getSelector = function (el) {\n        if (!el) {\n            return;\n        }\n        var classes = el.getAttribute('class') || '';\n        classes = classes.replace(/axiom-matched|axiom-suggested-group|axiom-link|axiom-download|axiom-sel-\\S+|selectorgadget_\\w+/g, '').trim();\n        if (classes !== '') {\n            classes = '.' + classes.replace(/\\s+/g, '.');\n        }\n        return classes;\n    };\n    return ClassSelector;\n}());\nexports.default = ClassSelector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODExLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3JlY29yZGVyL1NlbGVjdG9ycy9DbGFzc1NlbGVjdG9yLnRzPzJmNzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ2xhc3NTZWxlY3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDbGFzc1NlbGVjdG9yKCkge1xuICAgIH1cbiAgICBDbGFzc1NlbGVjdG9yLnByb3RvdHlwZS5nZXRTZWxlY3RvciA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNsYXNzZXMgPSBlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJyc7XG4gICAgICAgIGNsYXNzZXMgPSBjbGFzc2VzLnJlcGxhY2UoL2F4aW9tLW1hdGNoZWR8YXhpb20tc3VnZ2VzdGVkLWdyb3VwfGF4aW9tLWxpbmt8YXhpb20tZG93bmxvYWR8YXhpb20tc2VsLVxcUyt8c2VsZWN0b3JnYWRnZXRfXFx3Ky9nLCAnJykudHJpbSgpO1xuICAgICAgICBpZiAoY2xhc3NlcyAhPT0gJycpIHtcbiAgICAgICAgICAgIGNsYXNzZXMgPSAnLicgKyBjbGFzc2VzLnJlcGxhY2UoL1xccysvZywgJy4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xhc3NlcztcbiAgICB9O1xuICAgIHJldHVybiBDbGFzc1NlbGVjdG9yO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENsYXNzU2VsZWN0b3I7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///811\n")},812:function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * Fetches the element in a string format\n */\nvar ElementSelector = /** @class */ (function () {\n    function ElementSelector() {\n    }\n    ElementSelector.prototype.getSelector = function (el) {\n        el.classList.remove(\'selectorgadget_selected\');\n        return el.outerHTML.replace(/\\"/g, "\\\'");\n    };\n    return ElementSelector;\n}());\nexports.default = ElementSelector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODEyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3JlY29yZGVyL1NlbGVjdG9ycy9FbGVtZW50U2VsZWN0b3IudHM/NDI3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogRmV0Y2hlcyB0aGUgZWxlbWVudCBpbiBhIHN0cmluZyBmb3JtYXRcbiAqL1xudmFyIEVsZW1lbnRTZWxlY3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbGVtZW50U2VsZWN0b3IoKSB7XG4gICAgfVxuICAgIEVsZW1lbnRTZWxlY3Rvci5wcm90b3R5cGUuZ2V0U2VsZWN0b3IgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0b3JnYWRnZXRfc2VsZWN0ZWQnKTtcbiAgICAgICAgcmV0dXJuIGVsLm91dGVySFRNTC5yZXBsYWNlKC9cXFwiL2csIFwiXFwnXCIpO1xuICAgIH07XG4gICAgcmV0dXJuIEVsZW1lbnRTZWxlY3Rvcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBFbGVtZW50U2VsZWN0b3I7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///812\n')},813:function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// tslint:disable-next-line:no-var-requires\n__webpack_require__(814);\n/**\n * Generates a selector for the hierarchy of the target element from DOM\n */\nvar HierarchySelector = /** @class */ (function () {\n    function HierarchySelector() {\n    }\n    HierarchySelector.prototype.getSelector = function (el) {\n        var stack = [];\n        // Bottom-up selector generator algorithm\n        while (el.parentNode != null) {\n            // Total count of siblings for a group\n            var sibCount = 0;\n            // Index of the sibling we are targetting\n            var sibIndex = 0;\n            // tslint:disable-next-line:prefer-for-of\n            for (var i = 0; i < el.parentNode.childNodes.length; i++) {\n                var sib = el.parentNode.childNodes[i];\n                /**\n                 * Avoid adding axiom injected toolbar components from messing the heirarchy of the selector\n                 * TODO: More specific; we'll define a particular AXIOM hash and check for that (in env)\n                 */\n                if (sib.nodeType === Node.ELEMENT_NODE) {\n                    if (sib.id && (typeof sib.id === 'string' && sib.id.includes('axiom'))) {\n                        continue;\n                    }\n                    if (sib.nodeName === el.nodeName) {\n                        if (sib === el) {\n                            sibIndex = sibCount;\n                        }\n                        sibCount++;\n                    }\n                }\n            }\n            if (sibCount > 1) {\n                if (sibIndex > 1 && (sibIndex + 1 === el.parentNode.childNodes.length || $(el).is(':nth-last-of-type(1)'))) {\n                    // If last child of a group, use the following snippet instead of `nth-of-type(sibIndex+1)`\n                    stack.unshift(el.nodeName.toLowerCase() + ':nth-last-of-type(1)');\n                }\n                else {\n                    stack.unshift(el.nodeName.toLowerCase() + ':nth-of-type(' + (sibIndex + 1) + ')');\n                }\n            }\n            else {\n                stack.unshift(el.nodeName.toLowerCase());\n            }\n            el = el.parentNode;\n        }\n        // removes the html element\n        stack.shift();\n        // Test the selector and trim it if it's working fine\n        var selector = stack.join(' > ');\n        var firstEl = null;\n        while (document.querySelectorAll(selector).length === 1 && stack.length >= 2) {\n            firstEl = stack.shift();\n            selector = stack.join(' > ');\n        }\n        // This is needed because the iframe code is not feature complete\n        if (firstEl) {\n            stack.unshift(firstEl);\n        }\n        if (stack.length > 0) {\n            // joins each tags of the selector by space (children element)\n            return stack.join(' > ');\n        }\n        else {\n            // failed to fetch the selector\n            return false;\n        }\n    };\n    HierarchySelector.prototype.getSelectorForSizzle = function (el) {\n        var stack = [];\n        // Bottom-up selector generator algorithm\n        while (el.parentNode != null) {\n            // Total count of siblings for a group\n            var sibCount = 0;\n            // Index of the sibling we are targetting\n            var sibIndex = 0;\n            // tslint:disable-next-line:prefer-for-of\n            for (var i = 0; i < el.parentNode.childNodes.length; i++) {\n                var sib = el.parentNode.childNodes[i];\n                /**\n                 * Avoid adding axiom injected toolbar components from messing the heirarchy of the selector\n                 * TODO: More specific; we'll define a particular AXIOM hash and check for that (in env)\n                 */\n                if (sib.nodeType === Node.ELEMENT_NODE) {\n                    if (sib.id && (typeof sib.id === 'string' && sib.id.includes('axiom'))) {\n                        continue;\n                    }\n                    if (sib === el) {\n                        sibIndex = sibCount;\n                    }\n                    sibCount++;\n                }\n            }\n            if (sibCount > 1) {\n                var path = el.nodeName.toLowerCase();\n                // Add the classname to node element when it is requested\n                if (el.className) {\n                    var refs = el.className.split(\" \");\n                    for (var i = 0, len = refs.length; i < len; i++) {\n                        var cssName = refs[i];\n                        var escaped = this.escapeCssNames(cssName);\n                        escaped = CSS.escape(escaped);\n                        if (cssName && escaped.length > 0) {\n                            path += '.' + escaped;\n                        }\n                    }\n                }\n                if (sibIndex > 1) {\n                    path += ':nth-child(' + (sibIndex + 1) + ')';\n                }\n                stack.unshift(path);\n            }\n            else {\n                stack.unshift(el.nodeName.toLowerCase());\n            }\n            el = el.parentNode;\n        }\n        // removes the html element\n        stack = stack.slice(1);\n        if (stack.length > 0) {\n            // joins each tags of the selector by space (children element)\n            return stack.join(' > ');\n        }\n        else {\n            // failed to fetch the selector\n            return false;\n        }\n    };\n    HierarchySelector.prototype.escapeCssNames = function (name) {\n        if (name) {\n            try {\n                return name.replace(/\\bselectorgadget_\\w+\\b/g, '').replace(/\\\\/g, '\\\\\\\\').replace(/[\\#\\;\\&\\,\\.\\+\\*\\~\\'\\:\\\"\\!\\^\\$\\[\\]\\(\\)\\=\\>\\|\\/]/g, function (e) {\n                    return '\\\\' + e;\n                }).replace(/\\s+/, '');\n            }\n            catch (e) {\n                if (window.console) {\n                    console.log('---');\n                    console.log(\"exception in escapeCssNames\");\n                    console.log(name);\n                    console.log('---');\n                }\n                return '';\n            }\n        }\n        else {\n            return '';\n        }\n    };\n    return HierarchySelector;\n}());\nexports.default = HierarchySelector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODEzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3JlY29yZGVyL1NlbGVjdG9ycy9IaWVyYXJjaHlTZWxlY3Rvci50cz8xMTgxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXZhci1yZXF1aXJlc1xucmVxdWlyZSgnY3NzLmVzY2FwZScpO1xuLyoqXG4gKiBHZW5lcmF0ZXMgYSBzZWxlY3RvciBmb3IgdGhlIGhpZXJhcmNoeSBvZiB0aGUgdGFyZ2V0IGVsZW1lbnQgZnJvbSBET01cbiAqL1xudmFyIEhpZXJhcmNoeVNlbGVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhpZXJhcmNoeVNlbGVjdG9yKCkge1xuICAgIH1cbiAgICBIaWVyYXJjaHlTZWxlY3Rvci5wcm90b3R5cGUuZ2V0U2VsZWN0b3IgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIHN0YWNrID0gW107XG4gICAgICAgIC8vIEJvdHRvbS11cCBzZWxlY3RvciBnZW5lcmF0b3IgYWxnb3JpdGhtXG4gICAgICAgIHdoaWxlIChlbC5wYXJlbnROb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRvdGFsIGNvdW50IG9mIHNpYmxpbmdzIGZvciBhIGdyb3VwXG4gICAgICAgICAgICB2YXIgc2liQ291bnQgPSAwO1xuICAgICAgICAgICAgLy8gSW5kZXggb2YgdGhlIHNpYmxpbmcgd2UgYXJlIHRhcmdldHRpbmdcbiAgICAgICAgICAgIHZhciBzaWJJbmRleCA9IDA7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6cHJlZmVyLWZvci1vZlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbC5wYXJlbnROb2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2liID0gZWwucGFyZW50Tm9kZS5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEF2b2lkIGFkZGluZyBheGlvbSBpbmplY3RlZCB0b29sYmFyIGNvbXBvbmVudHMgZnJvbSBtZXNzaW5nIHRoZSBoZWlyYXJjaHkgb2YgdGhlIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgICogVE9ETzogTW9yZSBzcGVjaWZpYzsgd2UnbGwgZGVmaW5lIGEgcGFydGljdWxhciBBWElPTSBoYXNoIGFuZCBjaGVjayBmb3IgdGhhdCAoaW4gZW52KVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChzaWIubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWIuaWQgJiYgKHR5cGVvZiBzaWIuaWQgPT09ICdzdHJpbmcnICYmIHNpYi5pZC5pbmNsdWRlcygnYXhpb20nKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWIubm9kZU5hbWUgPT09IGVsLm5vZGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2liID09PSBlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpYkluZGV4ID0gc2liQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWJDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNpYkNvdW50ID4gMSkge1xuICAgICAgICAgICAgICAgIGlmIChzaWJJbmRleCA+IDEgJiYgKHNpYkluZGV4ICsgMSA9PT0gZWwucGFyZW50Tm9kZS5jaGlsZE5vZGVzLmxlbmd0aCB8fCAkKGVsKS5pcygnOm50aC1sYXN0LW9mLXR5cGUoMSknKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgbGFzdCBjaGlsZCBvZiBhIGdyb3VwLCB1c2UgdGhlIGZvbGxvd2luZyBzbmlwcGV0IGluc3RlYWQgb2YgYG50aC1vZi10eXBlKHNpYkluZGV4KzEpYFxuICAgICAgICAgICAgICAgICAgICBzdGFjay51bnNoaWZ0KGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKyAnOm50aC1sYXN0LW9mLXR5cGUoMSknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnVuc2hpZnQoZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSArICc6bnRoLW9mLXR5cGUoJyArIChzaWJJbmRleCArIDEpICsgJyknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFjay51bnNoaWZ0KGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbW92ZXMgdGhlIGh0bWwgZWxlbWVudFxuICAgICAgICBzdGFjay5zaGlmdCgpO1xuICAgICAgICAvLyBUZXN0IHRoZSBzZWxlY3RvciBhbmQgdHJpbSBpdCBpZiBpdCdzIHdvcmtpbmcgZmluZVxuICAgICAgICB2YXIgc2VsZWN0b3IgPSBzdGFjay5qb2luKCcgPiAnKTtcbiAgICAgICAgdmFyIGZpcnN0RWwgPSBudWxsO1xuICAgICAgICB3aGlsZSAoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikubGVuZ3RoID09PSAxICYmIHN0YWNrLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICBmaXJzdEVsID0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgIHNlbGVjdG9yID0gc3RhY2suam9pbignID4gJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgaWZyYW1lIGNvZGUgaXMgbm90IGZlYXR1cmUgY29tcGxldGVcbiAgICAgICAgaWYgKGZpcnN0RWwpIHtcbiAgICAgICAgICAgIHN0YWNrLnVuc2hpZnQoZmlyc3RFbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIGpvaW5zIGVhY2ggdGFncyBvZiB0aGUgc2VsZWN0b3IgYnkgc3BhY2UgKGNoaWxkcmVuIGVsZW1lbnQpXG4gICAgICAgICAgICByZXR1cm4gc3RhY2suam9pbignID4gJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBmYWlsZWQgdG8gZmV0Y2ggdGhlIHNlbGVjdG9yXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEhpZXJhcmNoeVNlbGVjdG9yLnByb3RvdHlwZS5nZXRTZWxlY3RvckZvclNpenpsZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICAgICAgLy8gQm90dG9tLXVwIHNlbGVjdG9yIGdlbmVyYXRvciBhbGdvcml0aG1cbiAgICAgICAgd2hpbGUgKGVsLnBhcmVudE5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVG90YWwgY291bnQgb2Ygc2libGluZ3MgZm9yIGEgZ3JvdXBcbiAgICAgICAgICAgIHZhciBzaWJDb3VudCA9IDA7XG4gICAgICAgICAgICAvLyBJbmRleCBvZiB0aGUgc2libGluZyB3ZSBhcmUgdGFyZ2V0dGluZ1xuICAgICAgICAgICAgdmFyIHNpYkluZGV4ID0gMDtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpwcmVmZXItZm9yLW9mXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsLnBhcmVudE5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzaWIgPSBlbC5wYXJlbnROb2RlLmNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQXZvaWQgYWRkaW5nIGF4aW9tIGluamVjdGVkIHRvb2xiYXIgY29tcG9uZW50cyBmcm9tIG1lc3NpbmcgdGhlIGhlaXJhcmNoeSBvZiB0aGUgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgKiBUT0RPOiBNb3JlIHNwZWNpZmljOyB3ZSdsbCBkZWZpbmUgYSBwYXJ0aWN1bGFyIEFYSU9NIGhhc2ggYW5kIGNoZWNrIGZvciB0aGF0IChpbiBlbnYpXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKHNpYi5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpYi5pZCAmJiAodHlwZW9mIHNpYi5pZCA9PT0gJ3N0cmluZycgJiYgc2liLmlkLmluY2x1ZGVzKCdheGlvbScpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpYiA9PT0gZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpYkluZGV4ID0gc2liQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2liQ291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2liQ291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGggPSBlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgY2xhc3NuYW1lIHRvIG5vZGUgZWxlbWVudCB3aGVuIGl0IGlzIHJlcXVlc3RlZFxuICAgICAgICAgICAgICAgIGlmIChlbC5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZnMgPSBlbC5jbGFzc05hbWUuc3BsaXQoXCIgXCIpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcmVmcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNzc05hbWUgPSByZWZzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVzY2FwZWQgPSB0aGlzLmVzY2FwZUNzc05hbWVzKGNzc05hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZCA9IENTUy5lc2NhcGUoZXNjYXBlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3NzTmFtZSAmJiBlc2NhcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoICs9ICcuJyArIGVzY2FwZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNpYkluZGV4ID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoICs9ICc6bnRoLWNoaWxkKCcgKyAoc2liSW5kZXggKyAxKSArICcpJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhY2sudW5zaGlmdChwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YWNrLnVuc2hpZnQoZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtb3ZlcyB0aGUgaHRtbCBlbGVtZW50XG4gICAgICAgIHN0YWNrID0gc3RhY2suc2xpY2UoMSk7XG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBqb2lucyBlYWNoIHRhZ3Mgb2YgdGhlIHNlbGVjdG9yIGJ5IHNwYWNlIChjaGlsZHJlbiBlbGVtZW50KVxuICAgICAgICAgICAgcmV0dXJuIHN0YWNrLmpvaW4oJyA+ICcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZmFpbGVkIHRvIGZldGNoIHRoZSBzZWxlY3RvclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIaWVyYXJjaHlTZWxlY3Rvci5wcm90b3R5cGUuZXNjYXBlQ3NzTmFtZXMgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZS5yZXBsYWNlKC9cXGJzZWxlY3RvcmdhZGdldF9cXHcrXFxiL2csICcnKS5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpLnJlcGxhY2UoL1tcXCNcXDtcXCZcXCxcXC5cXCtcXCpcXH5cXCdcXDpcXFwiXFwhXFxeXFwkXFxbXFxdXFwoXFwpXFw9XFw+XFx8XFwvXS9nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1xcXFwnICsgZTtcbiAgICAgICAgICAgICAgICB9KS5yZXBsYWNlKC9cXHMrLywgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAod2luZG93LmNvbnNvbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJy0tLScpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImV4Y2VwdGlvbiBpbiBlc2NhcGVDc3NOYW1lc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCctLS0nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSGllcmFyY2h5U2VsZWN0b3I7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSGllcmFyY2h5U2VsZWN0b3I7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///813\n")},814:function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/*! https://mths.be/cssescape v1.5.1 by @mathias | MIT license */\n;(function(root, factory) {\n\t// https://github.com/umdjs/umd/blob/master/returnExports.js\n\tif (true) {\n\t\t// For Node.js.\n\t\tmodule.exports = factory(root);\n\t} else {}\n}(typeof global != 'undefined' ? global : this, function(root) {\n\n\tif (root.CSS && root.CSS.escape) {\n\t\treturn root.CSS.escape;\n\t}\n\n\t// https://drafts.csswg.org/cssom/#serialize-an-identifier\n\tvar cssEscape = function(value) {\n\t\tif (arguments.length == 0) {\n\t\t\tthrow new TypeError('`CSS.escape` requires an argument.');\n\t\t}\n\t\tvar string = String(value);\n\t\tvar length = string.length;\n\t\tvar index = -1;\n\t\tvar codeUnit;\n\t\tvar result = '';\n\t\tvar firstCodeUnit = string.charCodeAt(0);\n\t\twhile (++index < length) {\n\t\t\tcodeUnit = string.charCodeAt(index);\n\t\t\t// Note: there’s no need to special-case astral symbols, surrogate\n\t\t\t// pairs, or lone surrogates.\n\n\t\t\t// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER\n\t\t\t// (U+FFFD).\n\t\t\tif (codeUnit == 0x0000) {\n\t\t\t\tresult += '\\uFFFD';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t// If the character is in the range [\\1-\\1F] (U+0001 to U+001F) or is\n\t\t\t\t// U+007F, […]\n\t\t\t\t(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||\n\t\t\t\t// If the character is the first character and is in the range [0-9]\n\t\t\t\t// (U+0030 to U+0039), […]\n\t\t\t\t(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||\n\t\t\t\t// If the character is the second character and is in the range [0-9]\n\t\t\t\t// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]\n\t\t\t\t(\n\t\t\t\t\tindex == 1 &&\n\t\t\t\t\tcodeUnit >= 0x0030 && codeUnit <= 0x0039 &&\n\t\t\t\t\tfirstCodeUnit == 0x002D\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\t// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point\n\t\t\t\tresult += '\\\\' + codeUnit.toString(16) + ' ';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t// If the character is the first character and is a `-` (U+002D), and\n\t\t\t\t// there is no second character, […]\n\t\t\t\tindex == 0 &&\n\t\t\t\tlength == 1 &&\n\t\t\t\tcodeUnit == 0x002D\n\t\t\t) {\n\t\t\t\tresult += '\\\\' + string.charAt(index);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If the character is not handled by one of the above rules and is\n\t\t\t// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or\n\t\t\t// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to\n\t\t\t// U+005A), or [a-z] (U+0061 to U+007A), […]\n\t\t\tif (\n\t\t\t\tcodeUnit >= 0x0080 ||\n\t\t\t\tcodeUnit == 0x002D ||\n\t\t\t\tcodeUnit == 0x005F ||\n\t\t\t\tcodeUnit >= 0x0030 && codeUnit <= 0x0039 ||\n\t\t\t\tcodeUnit >= 0x0041 && codeUnit <= 0x005A ||\n\t\t\t\tcodeUnit >= 0x0061 && codeUnit <= 0x007A\n\t\t\t) {\n\t\t\t\t// the character itself\n\t\t\t\tresult += string.charAt(index);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Otherwise, the escaped character.\n\t\t\t// https://drafts.csswg.org/cssom/#escape-a-character\n\t\t\tresult += '\\\\' + string.charAt(index);\n\n\t\t}\n\t\treturn result;\n\t};\n\n\tif (!root.CSS) {\n\t\troot.CSS = {};\n\t}\n\n\troot.CSS.escape = cssEscape;\n\treturn cssEscape;\n\n}));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(38)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODE0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nzcy5lc2NhcGUvY3NzLmVzY2FwZS5qcz9lN2E1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBodHRwczovL210aHMuYmUvY3NzZXNjYXBlIHYxLjUuMSBieSBAbWF0aGlhcyB8IE1JVCBsaWNlbnNlICovXG47KGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3VtZGpzL3VtZC9ibG9iL21hc3Rlci9yZXR1cm5FeHBvcnRzLmpzXG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0Jykge1xuXHRcdC8vIEZvciBOb2RlLmpzLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyb290KTtcblx0fSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEZvciBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5LmJpbmQocm9vdCwgcm9vdCkpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIEZvciBicm93c2VyIGdsb2JhbHMgKG5vdCBleHBvc2luZyB0aGUgZnVuY3Rpb24gc2VwYXJhdGVseSkuXG5cdFx0ZmFjdG9yeShyb290KTtcblx0fVxufSh0eXBlb2YgZ2xvYmFsICE9ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdGhpcywgZnVuY3Rpb24ocm9vdCkge1xuXG5cdGlmIChyb290LkNTUyAmJiByb290LkNTUy5lc2NhcGUpIHtcblx0XHRyZXR1cm4gcm9vdC5DU1MuZXNjYXBlO1xuXHR9XG5cblx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNzZXJpYWxpemUtYW4taWRlbnRpZmllclxuXHR2YXIgY3NzRXNjYXBlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdgQ1NTLmVzY2FwZWAgcmVxdWlyZXMgYW4gYXJndW1lbnQuJyk7XG5cdFx0fVxuXHRcdHZhciBzdHJpbmcgPSBTdHJpbmcodmFsdWUpO1xuXHRcdHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdHZhciBjb2RlVW5pdDtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0dmFyIGZpcnN0Q29kZVVuaXQgPSBzdHJpbmcuY2hhckNvZGVBdCgwKTtcblx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0Y29kZVVuaXQgPSBzdHJpbmcuY2hhckNvZGVBdChpbmRleCk7XG5cdFx0XHQvLyBOb3RlOiB0aGVyZeKAmXMgbm8gbmVlZCB0byBzcGVjaWFsLWNhc2UgYXN0cmFsIHN5bWJvbHMsIHN1cnJvZ2F0ZVxuXHRcdFx0Ly8gcGFpcnMsIG9yIGxvbmUgc3Vycm9nYXRlcy5cblxuXHRcdFx0Ly8gSWYgdGhlIGNoYXJhY3RlciBpcyBOVUxMIChVKzAwMDApLCB0aGVuIHRoZSBSRVBMQUNFTUVOVCBDSEFSQUNURVJcblx0XHRcdC8vIChVK0ZGRkQpLlxuXHRcdFx0aWYgKGNvZGVVbml0ID09IDB4MDAwMCkge1xuXHRcdFx0XHRyZXN1bHQgKz0gJ1xcdUZGRkQnO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKFxuXHRcdFx0XHQvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGluIHRoZSByYW5nZSBbXFwxLVxcMUZdIChVKzAwMDEgdG8gVSswMDFGKSBvciBpc1xuXHRcdFx0XHQvLyBVKzAwN0YsIFvigKZdXG5cdFx0XHRcdChjb2RlVW5pdCA+PSAweDAwMDEgJiYgY29kZVVuaXQgPD0gMHgwMDFGKSB8fCBjb2RlVW5pdCA9PSAweDAwN0YgfHxcblx0XHRcdFx0Ly8gSWYgdGhlIGNoYXJhY3RlciBpcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCBpcyBpbiB0aGUgcmFuZ2UgWzAtOV1cblx0XHRcdFx0Ly8gKFUrMDAzMCB0byBVKzAwMzkpLCBb4oCmXVxuXHRcdFx0XHQoaW5kZXggPT0gMCAmJiBjb2RlVW5pdCA+PSAweDAwMzAgJiYgY29kZVVuaXQgPD0gMHgwMDM5KSB8fFxuXHRcdFx0XHQvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIHRoZSBzZWNvbmQgY2hhcmFjdGVyIGFuZCBpcyBpbiB0aGUgcmFuZ2UgWzAtOV1cblx0XHRcdFx0Ly8gKFUrMDAzMCB0byBVKzAwMzkpIGFuZCB0aGUgZmlyc3QgY2hhcmFjdGVyIGlzIGEgYC1gIChVKzAwMkQpLCBb4oCmXVxuXHRcdFx0XHQoXG5cdFx0XHRcdFx0aW5kZXggPT0gMSAmJlxuXHRcdFx0XHRcdGNvZGVVbml0ID49IDB4MDAzMCAmJiBjb2RlVW5pdCA8PSAweDAwMzkgJiZcblx0XHRcdFx0XHRmaXJzdENvZGVVbml0ID09IDB4MDAyRFxuXHRcdFx0XHQpXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNlc2NhcGUtYS1jaGFyYWN0ZXItYXMtY29kZS1wb2ludFxuXHRcdFx0XHRyZXN1bHQgKz0gJ1xcXFwnICsgY29kZVVuaXQudG9TdHJpbmcoMTYpICsgJyAnO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKFxuXHRcdFx0XHQvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIGlzIGEgYC1gIChVKzAwMkQpLCBhbmRcblx0XHRcdFx0Ly8gdGhlcmUgaXMgbm8gc2Vjb25kIGNoYXJhY3RlciwgW+KApl1cblx0XHRcdFx0aW5kZXggPT0gMCAmJlxuXHRcdFx0XHRsZW5ndGggPT0gMSAmJlxuXHRcdFx0XHRjb2RlVW5pdCA9PSAweDAwMkRcblx0XHRcdCkge1xuXHRcdFx0XHRyZXN1bHQgKz0gJ1xcXFwnICsgc3RyaW5nLmNoYXJBdChpbmRleCk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIG5vdCBoYW5kbGVkIGJ5IG9uZSBvZiB0aGUgYWJvdmUgcnVsZXMgYW5kIGlzXG5cdFx0XHQvLyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gVSswMDgwLCBpcyBgLWAgKFUrMDAyRCkgb3IgYF9gIChVKzAwNUYpLCBvclxuXHRcdFx0Ly8gaXMgaW4gb25lIG9mIHRoZSByYW5nZXMgWzAtOV0gKFUrMDAzMCB0byBVKzAwMzkpLCBbQS1aXSAoVSswMDQxIHRvXG5cdFx0XHQvLyBVKzAwNUEpLCBvciBbYS16XSAoVSswMDYxIHRvIFUrMDA3QSksIFvigKZdXG5cdFx0XHRpZiAoXG5cdFx0XHRcdGNvZGVVbml0ID49IDB4MDA4MCB8fFxuXHRcdFx0XHRjb2RlVW5pdCA9PSAweDAwMkQgfHxcblx0XHRcdFx0Y29kZVVuaXQgPT0gMHgwMDVGIHx8XG5cdFx0XHRcdGNvZGVVbml0ID49IDB4MDAzMCAmJiBjb2RlVW5pdCA8PSAweDAwMzkgfHxcblx0XHRcdFx0Y29kZVVuaXQgPj0gMHgwMDQxICYmIGNvZGVVbml0IDw9IDB4MDA1QSB8fFxuXHRcdFx0XHRjb2RlVW5pdCA+PSAweDAwNjEgJiYgY29kZVVuaXQgPD0gMHgwMDdBXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gdGhlIGNoYXJhY3RlciBpdHNlbGZcblx0XHRcdFx0cmVzdWx0ICs9IHN0cmluZy5jaGFyQXQoaW5kZXgpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG5cdFx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2VzY2FwZS1hLWNoYXJhY3RlclxuXHRcdFx0cmVzdWx0ICs9ICdcXFxcJyArIHN0cmluZy5jaGFyQXQoaW5kZXgpO1xuXG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0aWYgKCFyb290LkNTUykge1xuXHRcdHJvb3QuQ1NTID0ge307XG5cdH1cblxuXHRyb290LkNTUy5lc2NhcGUgPSBjc3NFc2NhcGU7XG5cdHJldHVybiBjc3NFc2NhcGU7XG5cbn0pKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///814\n")},815:function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * Fetches the parent of the element in a string format\n */\nvar IdSelector = /** @class */ (function () {\n    function IdSelector() {\n    }\n    IdSelector.prototype.getSelector = function (el) {\n        return "#" + el.id;\n    };\n    return IdSelector;\n}());\nexports.default = IdSelector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODE1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3JlY29yZGVyL1NlbGVjdG9ycy9JZFNlbGVjdG9yLnRzPzMyNGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEZldGNoZXMgdGhlIHBhcmVudCBvZiB0aGUgZWxlbWVudCBpbiBhIHN0cmluZyBmb3JtYXRcbiAqL1xudmFyIElkU2VsZWN0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSWRTZWxlY3RvcigpIHtcbiAgICB9XG4gICAgSWRTZWxlY3Rvci5wcm90b3R5cGUuZ2V0U2VsZWN0b3IgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuIFwiI1wiICsgZWwuaWQ7XG4gICAgfTtcbiAgICByZXR1cm4gSWRTZWxlY3Rvcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBJZFNlbGVjdG9yO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///815\n')},816:function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * Fetches the inner text of an element in a string\n */\nvar InnerTextSelector = /** @class */ (function () {\n    function InnerTextSelector() {\n    }\n    InnerTextSelector.prototype.getSelector = function (el) {\n        return el.textContent.trim();\n    };\n    return InnerTextSelector;\n}());\nexports.default = InnerTextSelector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODE2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3JlY29yZGVyL1NlbGVjdG9ycy9Jbm5lclRleHRTZWxlY3Rvci50cz9mNmFjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBGZXRjaGVzIHRoZSBpbm5lciB0ZXh0IG9mIGFuIGVsZW1lbnQgaW4gYSBzdHJpbmdcbiAqL1xudmFyIElubmVyVGV4dFNlbGVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElubmVyVGV4dFNlbGVjdG9yKCkge1xuICAgIH1cbiAgICBJbm5lclRleHRTZWxlY3Rvci5wcm90b3R5cGUuZ2V0U2VsZWN0b3IgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuIGVsLnRleHRDb250ZW50LnRyaW0oKTtcbiAgICB9O1xuICAgIHJldHVybiBJbm5lclRleHRTZWxlY3Rvcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBJbm5lclRleHRTZWxlY3RvcjtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///816\n')},817:function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * Fetches the parent of the element in a string format\n */\nvar ParentElementSelector = /** @class */ (function () {\n    function ParentElementSelector() {\n    }\n    ParentElementSelector.prototype.getSelector = function (el) {\n        el.classList.remove(\'selectorgadget_selected\');\n        return el.parentElement.outerHTML.replace(/\\"/g, "\\\'");\n    };\n    return ParentElementSelector;\n}());\nexports.default = ParentElementSelector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODE3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3JlY29yZGVyL1NlbGVjdG9ycy9QYXJlbnRFbGVtZW50U2VsZWN0b3IudHM/ZmIxNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogRmV0Y2hlcyB0aGUgcGFyZW50IG9mIHRoZSBlbGVtZW50IGluIGEgc3RyaW5nIGZvcm1hdFxuICovXG52YXIgUGFyZW50RWxlbWVudFNlbGVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhcmVudEVsZW1lbnRTZWxlY3RvcigpIHtcbiAgICB9XG4gICAgUGFyZW50RWxlbWVudFNlbGVjdG9yLnByb3RvdHlwZS5nZXRTZWxlY3RvciA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RvcmdhZGdldF9zZWxlY3RlZCcpO1xuICAgICAgICByZXR1cm4gZWwucGFyZW50RWxlbWVudC5vdXRlckhUTUwucmVwbGFjZSgvXFxcIi9nLCBcIlxcJ1wiKTtcbiAgICB9O1xuICAgIHJldHVybiBQYXJlbnRFbGVtZW50U2VsZWN0b3I7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUGFyZW50RWxlbWVudFNlbGVjdG9yO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///817\n')},818:function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ScrapeHelper_1 = __webpack_require__(405);\nvar BorderHighlight = /** @class */ (function () {\n    function BorderHighlight(doc, iframeElement, iframeSupportEnabled) {\n        var _this = this;\n        if (iframeElement === void 0) { iframeElement = false; }\n        if (iframeSupportEnabled === void 0) { iframeSupportEnabled = false; }\n        this.borderWidth = 5;\n        this.borderPadding = 2;\n        this.activeSelectorIndex = 0;\n        this.resultType = 'textContent';\n        this.scrapeHelper = new ScrapeHelper_1.ScrapeHelper();\n        this.doc = doc;\n        this.iframeElement = iframeElement;\n        this.iframeSupportEnabled = iframeSupportEnabled;\n        doc.onscroll = function (e) {\n            jQuery(_this.borderElement).hide();\n        };\n    }\n    BorderHighlight.prototype.updateactiveSelectorIndex = function (id) {\n        this.activeSelectorIndex = id;\n    };\n    BorderHighlight.prototype.updateResultType = function (resultType) {\n        this.resultType = (resultType === 'axiom-download' ? \"outerHTML\" : resultType);\n    };\n    BorderHighlight.prototype.updateWindex = function (windex) {\n        this.windex = windex;\n    };\n    BorderHighlight.prototype.inject = function () {\n        this.setupBorder();\n        jQuery(this.doc).on('mouseover.axiom-selection', this.mouseoverHandler.bind(this));\n        jQuery(this.doc).on('mouseout.axiom-selection:not(.axiom-shield-overlay)', this.mouseLeaveHandler.bind(this));\n    };\n    BorderHighlight.prototype.eject = function () {\n        this.removeBorderFromDom();\n        jQuery(this.doc).off('mouseover.axiom-selection');\n        jQuery(this.doc).off('mouseout.axiom-selection');\n    };\n    BorderHighlight.prototype.setupBorder = function () {\n        if (!this.borderElement) {\n            var width_1 = this.borderWidth + 'px';\n            var bottomHeight = this.borderWidth * 2 + 'px';\n            this.shieldOverlay = jQuery(\"<div class=\\\"axiom-shield-overlay axiom-tool axiom-selector-ignore\\\"></div>\");\n            this.borderElement = jQuery(\"<div class=\\\"axiom-tool-highlight-border\\\"></div>\").hide();\n            this.bTop = jQuery('<div>').addClass('axiom-border-highlight').addClass('axiom-border-top').css('height', width_1);\n            this.bLeft = jQuery('<div>').addClass('axiom-border-highlight').addClass('axiom-border-left').css('width', width_1);\n            this.bBottom = jQuery('<div>').addClass('axiom-border-highlight').addClass('axiom-border-bottom').css('min-height', width_1).css('text-overflow', 'clip').css('font-family', 'Quicksand,sans-serif');\n            $(this.bBottom).each(function (index, el) {\n                el.style.setProperty('padding-left', width_1, 'important');\n            });\n            this.preview = jQuery(\"\\n            <div id=\\\"axiom-preview-wrapper\\\"\\n            style=\\\"\\n            position:relative!important;\\n            left:0!important;\\n            display: flex!important;\\n            justify-content: center!important;\\n            padding: 0!important;\\n            justify-content: start!important;\\n            font-size:12px!important;\\n            line-height:0px!important;\\n            background-color;red!important;\\n            background;red!important;\\n            min-height:10px!important;\\n            height:auto!important;\\n            max-width:400px!important;\\n            width: auto!important;\\n            white-space:nowrap!important;\\n            overflow:visible!important;\\n            overflow-x: clip!important;\\n            margin: 0!important;\\n            float:none!important;\\n            font-weight:bold!important;\\n            box-sizing: initial!important;\\n            top: 5px!important;\\n            scrollbar-width: none!important;\\n            \\\"\\n            >\\n              <p\\n              ></p>\\n            </div>\"); //TODO: hide this\n            this.bBottom.append(this.preview);\n            this.bRight = jQuery('<div>').addClass('axiom-border-highlight').addClass('axiom-border-right').css('width', width_1);\n            this.addBorderToDom();\n        }\n    };\n    BorderHighlight.prototype.removeBorderFromDom = function () {\n        if (this.borderElement) {\n            this.borderElement.remove();\n            this.bTop.remove();\n            this.bRight.remove();\n            this.bBottom.remove();\n            this.bRight.remove();\n        }\n        this.borderElement = this.bTop = this.bRight = this.bBottom = this.bLeft = null;\n    };\n    BorderHighlight.prototype.addBorderToDom = function () {\n        this.borderElement.append(this.shieldOverlay);\n        this.borderElement.append(this.bTop);\n        this.borderElement.append(this.bRight);\n        this.borderElement.append(this.bBottom);\n        this.borderElement.append(this.bLeft);\n        this.doc.body.appendChild(this.borderElement.get(0));\n    };\n    BorderHighlight.prototype.showBorder = function () {\n        this.borderElement.show();\n    };\n    BorderHighlight.prototype.removeBorder = function () {\n        if (this.borderElement) {\n            this.borderElement.hide();\n        }\n    };\n    BorderHighlight.prototype.makeBorders = function (targetElem) {\n        var _this = this;\n        if (targetElem.tagName === 'IFRAME') {\n            return;\n        }\n        var element = jQuery(targetElem);\n        var position = element.offset();\n        var top = position.top - scrollY;\n        var left = position.left;\n        var width = element.outerWidth();\n        var height = element.outerHeight();\n        this.preview.show();\n        this.bTop.css('width', (width + this.borderPadding * 2 + this.borderWidth * 2) + 'px')\n            .css('top', (top - this.borderWidth - this.borderPadding) + 'px')\n            .css('left', (left - this.borderPadding - this.borderWidth) + 'px');\n        this.bRight.css('height', (height + this.borderPadding * 2) + 'px')\n            .css('top', (top - this.borderPadding) + 'px')\n            .css('left', (left + width + this.borderPadding) + 'px');\n        this.bBottom.css('width', (width + this.borderPadding * 2 + this.borderWidth * 2 - 5) + 'px')\n            .css('top', (top + height + this.borderPadding) + 'px')\n            .css('left', (left - this.borderPadding - this.borderWidth) + 'px')\n            .css('color', '#F5F5F5')\n            .css('height', this.borderWidth * 4 + 'px');\n        this.bLeft.css('height', (height + this.borderPadding * 2) + 'px')\n            .css('top', (top - this.borderPadding) + 'px')\n            .css('left', (left - this.borderPadding - this.borderWidth) + 'px');\n        this.shieldOverlay.css('top', top + 'px') // used to prevent selection of invlaid elements (iframes)\n            .css('left', left + 'px');\n        if (targetElem.tagName.toLowerCase() === 'iframe') { // we expand the shield over the dissalowed elements\n            this.shieldOverlay.css('width', width + 'px')\n                .css('height', height + 'px');\n            this.shieldOverlay.off(\"click\");\n            this.shieldOverlay.click(function (e) {\n                _this.shieldOverlay.off(\"click\");\n                if (_this.windex !== undefined) {\n                    var navigate = confirm(\"You have selected content within an iframe that can't currently be selected. Would you like to try to goto the url?\\n(Current selections will be lost if you click 'OK')\");\n                    if (navigate) {\n                        var currentURL = window.location.href;\n                        var frameSrc = targetElem.src;\n                        // add goto widget with frame src\n                        chrome.runtime.sendMessage({\n                            action: \"change_url\",\n                            origin: currentURL,\n                            target: frameSrc,\n                            windex: _this.windex\n                        });\n                    }\n                }\n                else {\n                    alert(\"Magic button cannot be placed here, as this is a window getting content from a different website. Please select another area of the page\");\n                }\n            });\n        }\n        else {\n            this.shieldOverlay.css('width', 0 + 'px')\n                .css('height', 0 + 'px');\n            this.shieldOverlay.off(\"click\");\n        }\n        // Make a way to target clicks on these border elements to direct to the element beneath\n        // TODO\n        // modify the colors if we are removing a selection\n        var removingSelection = $(targetElem).is(\".axiom-sel-suggested-\" + this.activeSelectorIndex + \", .axiom-sel-selected-\" + this.activeSelectorIndex);\n        if (removingSelection) {\n            $(\".axiom-border-highlight\").each(function (index, el) {\n                el.style.setProperty(\"background-color\", \"rgb(245, 58, 58)\", \"important\");\n            });\n        }\n        else {\n            $(\".axiom-border-highlight\").each(function (index, el) {\n                el.style.setProperty(\"background-color\", \"#FFAB00\", \"important\");\n            });\n        }\n        if (this.iframeElement && !this.iframeSupportEnabled) {\n            this.preview.children('p').text('Enable iframe support');\n        }\n        else {\n            var preview = this.scrapeHelper.getData(targetElem, this.resultType);\n            if (this.resultType === 'textContent') {\n                var text = targetElem['innerText'];\n                if (text) {\n                    preview = text;\n                }\n                else {\n                    preview = '';\n                }\n            }\n            preview = (preview) ? preview : '';\n            preview = (preview.length > 25) ? preview.substr(0, 25) + '...' : preview;\n            this.preview.children('p').text(preview);\n        }\n        this.showBorder();\n    };\n    /**\n     * This is just debarring the chrome extension items, we can make this more cool\n     *\n     * @param element\n     */\n    BorderHighlight.prototype.selectable = function (element) {\n        if (element.tagName.toLowerCase() === \"body\" || jQuery(element).hasClass('axiom-selector-ignore')) {\n            return false;\n        }\n        return true;\n    };\n    BorderHighlight.prototype.mouseoverHandler = function (e) {\n        var target = e.target;\n        if (this.resultType === 'link') {\n            while (target.parentElement && !/\\S/.test(this.scrapeHelper.getData(target, this.resultType))) {\n                target = target.parentElement;\n            }\n        }\n        if (this.selectable(target) && e.target !== this.shieldOverlay.get(0)) {\n            this.makeBorders(target);\n        }\n    };\n    BorderHighlight.prototype.mouseLeaveHandler = function (e) {\n        if (e.target === this.doc.body || e.target === this.doc.body.parentNode || e.relatedTarget === this.shieldOverlay.get(0)) {\n            return false;\n        }\n        this.removeBorder();\n        return false;\n    };\n    BorderHighlight.prototype.setIframeSupportEnabled = function (val) {\n        this.iframeSupportEnabled = val;\n    };\n    return BorderHighlight;\n}());\nexports.BorderHighlight = BorderHighlight;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODE4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3JlY29yZGVyL3Rvb2wvQm9yZGVySGlnaGxpZ2h0LnRzPzEwOTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgU2NyYXBlSGVscGVyXzEgPSByZXF1aXJlKFwiLi9TY3JhcGVIZWxwZXJcIik7XG52YXIgQm9yZGVySGlnaGxpZ2h0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJvcmRlckhpZ2hsaWdodChkb2MsIGlmcmFtZUVsZW1lbnQsIGlmcmFtZVN1cHBvcnRFbmFibGVkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChpZnJhbWVFbGVtZW50ID09PSB2b2lkIDApIHsgaWZyYW1lRWxlbWVudCA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChpZnJhbWVTdXBwb3J0RW5hYmxlZCA9PT0gdm9pZCAwKSB7IGlmcmFtZVN1cHBvcnRFbmFibGVkID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy5ib3JkZXJXaWR0aCA9IDU7XG4gICAgICAgIHRoaXMuYm9yZGVyUGFkZGluZyA9IDI7XG4gICAgICAgIHRoaXMuYWN0aXZlU2VsZWN0b3JJbmRleCA9IDA7XG4gICAgICAgIHRoaXMucmVzdWx0VHlwZSA9ICd0ZXh0Q29udGVudCc7XG4gICAgICAgIHRoaXMuc2NyYXBlSGVscGVyID0gbmV3IFNjcmFwZUhlbHBlcl8xLlNjcmFwZUhlbHBlcigpO1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgdGhpcy5pZnJhbWVFbGVtZW50ID0gaWZyYW1lRWxlbWVudDtcbiAgICAgICAgdGhpcy5pZnJhbWVTdXBwb3J0RW5hYmxlZCA9IGlmcmFtZVN1cHBvcnRFbmFibGVkO1xuICAgICAgICBkb2Mub25zY3JvbGwgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgalF1ZXJ5KF90aGlzLmJvcmRlckVsZW1lbnQpLmhpZGUoKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgQm9yZGVySGlnaGxpZ2h0LnByb3RvdHlwZS51cGRhdGVhY3RpdmVTZWxlY3RvckluZGV4ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlU2VsZWN0b3JJbmRleCA9IGlkO1xuICAgIH07XG4gICAgQm9yZGVySGlnaGxpZ2h0LnByb3RvdHlwZS51cGRhdGVSZXN1bHRUeXBlID0gZnVuY3Rpb24gKHJlc3VsdFR5cGUpIHtcbiAgICAgICAgdGhpcy5yZXN1bHRUeXBlID0gKHJlc3VsdFR5cGUgPT09ICdheGlvbS1kb3dubG9hZCcgPyBcIm91dGVySFRNTFwiIDogcmVzdWx0VHlwZSk7XG4gICAgfTtcbiAgICBCb3JkZXJIaWdobGlnaHQucHJvdG90eXBlLnVwZGF0ZVdpbmRleCA9IGZ1bmN0aW9uICh3aW5kZXgpIHtcbiAgICAgICAgdGhpcy53aW5kZXggPSB3aW5kZXg7XG4gICAgfTtcbiAgICBCb3JkZXJIaWdobGlnaHQucHJvdG90eXBlLmluamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXR1cEJvcmRlcigpO1xuICAgICAgICBqUXVlcnkodGhpcy5kb2MpLm9uKCdtb3VzZW92ZXIuYXhpb20tc2VsZWN0aW9uJywgdGhpcy5tb3VzZW92ZXJIYW5kbGVyLmJpbmQodGhpcykpO1xuICAgICAgICBqUXVlcnkodGhpcy5kb2MpLm9uKCdtb3VzZW91dC5heGlvbS1zZWxlY3Rpb246bm90KC5heGlvbS1zaGllbGQtb3ZlcmxheSknLCB0aGlzLm1vdXNlTGVhdmVIYW5kbGVyLmJpbmQodGhpcykpO1xuICAgIH07XG4gICAgQm9yZGVySGlnaGxpZ2h0LnByb3RvdHlwZS5lamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVCb3JkZXJGcm9tRG9tKCk7XG4gICAgICAgIGpRdWVyeSh0aGlzLmRvYykub2ZmKCdtb3VzZW92ZXIuYXhpb20tc2VsZWN0aW9uJyk7XG4gICAgICAgIGpRdWVyeSh0aGlzLmRvYykub2ZmKCdtb3VzZW91dC5heGlvbS1zZWxlY3Rpb24nKTtcbiAgICB9O1xuICAgIEJvcmRlckhpZ2hsaWdodC5wcm90b3R5cGUuc2V0dXBCb3JkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5ib3JkZXJFbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgd2lkdGhfMSA9IHRoaXMuYm9yZGVyV2lkdGggKyAncHgnO1xuICAgICAgICAgICAgdmFyIGJvdHRvbUhlaWdodCA9IHRoaXMuYm9yZGVyV2lkdGggKiAyICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMuc2hpZWxkT3ZlcmxheSA9IGpRdWVyeShcIjxkaXYgY2xhc3M9XFxcImF4aW9tLXNoaWVsZC1vdmVybGF5IGF4aW9tLXRvb2wgYXhpb20tc2VsZWN0b3ItaWdub3JlXFxcIj48L2Rpdj5cIik7XG4gICAgICAgICAgICB0aGlzLmJvcmRlckVsZW1lbnQgPSBqUXVlcnkoXCI8ZGl2IGNsYXNzPVxcXCJheGlvbS10b29sLWhpZ2hsaWdodC1ib3JkZXJcXFwiPjwvZGl2PlwiKS5oaWRlKCk7XG4gICAgICAgICAgICB0aGlzLmJUb3AgPSBqUXVlcnkoJzxkaXY+JykuYWRkQ2xhc3MoJ2F4aW9tLWJvcmRlci1oaWdobGlnaHQnKS5hZGRDbGFzcygnYXhpb20tYm9yZGVyLXRvcCcpLmNzcygnaGVpZ2h0Jywgd2lkdGhfMSk7XG4gICAgICAgICAgICB0aGlzLmJMZWZ0ID0galF1ZXJ5KCc8ZGl2PicpLmFkZENsYXNzKCdheGlvbS1ib3JkZXItaGlnaGxpZ2h0JykuYWRkQ2xhc3MoJ2F4aW9tLWJvcmRlci1sZWZ0JykuY3NzKCd3aWR0aCcsIHdpZHRoXzEpO1xuICAgICAgICAgICAgdGhpcy5iQm90dG9tID0galF1ZXJ5KCc8ZGl2PicpLmFkZENsYXNzKCdheGlvbS1ib3JkZXItaGlnaGxpZ2h0JykuYWRkQ2xhc3MoJ2F4aW9tLWJvcmRlci1ib3R0b20nKS5jc3MoJ21pbi1oZWlnaHQnLCB3aWR0aF8xKS5jc3MoJ3RleHQtb3ZlcmZsb3cnLCAnY2xpcCcpLmNzcygnZm9udC1mYW1pbHknLCAnUXVpY2tzYW5kLHNhbnMtc2VyaWYnKTtcbiAgICAgICAgICAgICQodGhpcy5iQm90dG9tKS5lYWNoKGZ1bmN0aW9uIChpbmRleCwgZWwpIHtcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eSgncGFkZGluZy1sZWZ0Jywgd2lkdGhfMSwgJ2ltcG9ydGFudCcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnByZXZpZXcgPSBqUXVlcnkoXCJcXG4gICAgICAgICAgICA8ZGl2IGlkPVxcXCJheGlvbS1wcmV2aWV3LXdyYXBwZXJcXFwiXFxuICAgICAgICAgICAgc3R5bGU9XFxcIlxcbiAgICAgICAgICAgIHBvc2l0aW9uOnJlbGF0aXZlIWltcG9ydGFudDtcXG4gICAgICAgICAgICBsZWZ0OjAhaW1wb3J0YW50O1xcbiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXghaW1wb3J0YW50O1xcbiAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyIWltcG9ydGFudDtcXG4gICAgICAgICAgICBwYWRkaW5nOiAwIWltcG9ydGFudDtcXG4gICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHN0YXJ0IWltcG9ydGFudDtcXG4gICAgICAgICAgICBmb250LXNpemU6MTJweCFpbXBvcnRhbnQ7XFxuICAgICAgICAgICAgbGluZS1oZWlnaHQ6MHB4IWltcG9ydGFudDtcXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yO3JlZCFpbXBvcnRhbnQ7XFxuICAgICAgICAgICAgYmFja2dyb3VuZDtyZWQhaW1wb3J0YW50O1xcbiAgICAgICAgICAgIG1pbi1oZWlnaHQ6MTBweCFpbXBvcnRhbnQ7XFxuICAgICAgICAgICAgaGVpZ2h0OmF1dG8haW1wb3J0YW50O1xcbiAgICAgICAgICAgIG1heC13aWR0aDo0MDBweCFpbXBvcnRhbnQ7XFxuICAgICAgICAgICAgd2lkdGg6IGF1dG8haW1wb3J0YW50O1xcbiAgICAgICAgICAgIHdoaXRlLXNwYWNlOm5vd3JhcCFpbXBvcnRhbnQ7XFxuICAgICAgICAgICAgb3ZlcmZsb3c6dmlzaWJsZSFpbXBvcnRhbnQ7XFxuICAgICAgICAgICAgb3ZlcmZsb3cteDogY2xpcCFpbXBvcnRhbnQ7XFxuICAgICAgICAgICAgbWFyZ2luOiAwIWltcG9ydGFudDtcXG4gICAgICAgICAgICBmbG9hdDpub25lIWltcG9ydGFudDtcXG4gICAgICAgICAgICBmb250LXdlaWdodDpib2xkIWltcG9ydGFudDtcXG4gICAgICAgICAgICBib3gtc2l6aW5nOiBpbml0aWFsIWltcG9ydGFudDtcXG4gICAgICAgICAgICB0b3A6IDVweCFpbXBvcnRhbnQ7XFxuICAgICAgICAgICAgc2Nyb2xsYmFyLXdpZHRoOiBub25lIWltcG9ydGFudDtcXG4gICAgICAgICAgICBcXFwiXFxuICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgPHBcXG4gICAgICAgICAgICAgID48L3A+XFxuICAgICAgICAgICAgPC9kaXY+XCIpOyAvL1RPRE86IGhpZGUgdGhpc1xuICAgICAgICAgICAgdGhpcy5iQm90dG9tLmFwcGVuZCh0aGlzLnByZXZpZXcpO1xuICAgICAgICAgICAgdGhpcy5iUmlnaHQgPSBqUXVlcnkoJzxkaXY+JykuYWRkQ2xhc3MoJ2F4aW9tLWJvcmRlci1oaWdobGlnaHQnKS5hZGRDbGFzcygnYXhpb20tYm9yZGVyLXJpZ2h0JykuY3NzKCd3aWR0aCcsIHdpZHRoXzEpO1xuICAgICAgICAgICAgdGhpcy5hZGRCb3JkZXJUb0RvbSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCb3JkZXJIaWdobGlnaHQucHJvdG90eXBlLnJlbW92ZUJvcmRlckZyb21Eb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmJvcmRlckVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuYm9yZGVyRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuYlRvcC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuYlJpZ2h0LnJlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy5iQm90dG9tLnJlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy5iUmlnaHQucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ib3JkZXJFbGVtZW50ID0gdGhpcy5iVG9wID0gdGhpcy5iUmlnaHQgPSB0aGlzLmJCb3R0b20gPSB0aGlzLmJMZWZ0ID0gbnVsbDtcbiAgICB9O1xuICAgIEJvcmRlckhpZ2hsaWdodC5wcm90b3R5cGUuYWRkQm9yZGVyVG9Eb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYm9yZGVyRWxlbWVudC5hcHBlbmQodGhpcy5zaGllbGRPdmVybGF5KTtcbiAgICAgICAgdGhpcy5ib3JkZXJFbGVtZW50LmFwcGVuZCh0aGlzLmJUb3ApO1xuICAgICAgICB0aGlzLmJvcmRlckVsZW1lbnQuYXBwZW5kKHRoaXMuYlJpZ2h0KTtcbiAgICAgICAgdGhpcy5ib3JkZXJFbGVtZW50LmFwcGVuZCh0aGlzLmJCb3R0b20pO1xuICAgICAgICB0aGlzLmJvcmRlckVsZW1lbnQuYXBwZW5kKHRoaXMuYkxlZnQpO1xuICAgICAgICB0aGlzLmRvYy5ib2R5LmFwcGVuZENoaWxkKHRoaXMuYm9yZGVyRWxlbWVudC5nZXQoMCkpO1xuICAgIH07XG4gICAgQm9yZGVySGlnaGxpZ2h0LnByb3RvdHlwZS5zaG93Qm9yZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmJvcmRlckVsZW1lbnQuc2hvdygpO1xuICAgIH07XG4gICAgQm9yZGVySGlnaGxpZ2h0LnByb3RvdHlwZS5yZW1vdmVCb3JkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmJvcmRlckVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuYm9yZGVyRWxlbWVudC5oaWRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJvcmRlckhpZ2hsaWdodC5wcm90b3R5cGUubWFrZUJvcmRlcnMgPSBmdW5jdGlvbiAodGFyZ2V0RWxlbSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGFyZ2V0RWxlbS50YWdOYW1lID09PSAnSUZSQU1FJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbGVtZW50ID0galF1ZXJ5KHRhcmdldEVsZW0pO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBlbGVtZW50Lm9mZnNldCgpO1xuICAgICAgICB2YXIgdG9wID0gcG9zaXRpb24udG9wIC0gc2Nyb2xsWTtcbiAgICAgICAgdmFyIGxlZnQgPSBwb3NpdGlvbi5sZWZ0O1xuICAgICAgICB2YXIgd2lkdGggPSBlbGVtZW50Lm91dGVyV2lkdGgoKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IGVsZW1lbnQub3V0ZXJIZWlnaHQoKTtcbiAgICAgICAgdGhpcy5wcmV2aWV3LnNob3coKTtcbiAgICAgICAgdGhpcy5iVG9wLmNzcygnd2lkdGgnLCAod2lkdGggKyB0aGlzLmJvcmRlclBhZGRpbmcgKiAyICsgdGhpcy5ib3JkZXJXaWR0aCAqIDIpICsgJ3B4JylcbiAgICAgICAgICAgIC5jc3MoJ3RvcCcsICh0b3AgLSB0aGlzLmJvcmRlcldpZHRoIC0gdGhpcy5ib3JkZXJQYWRkaW5nKSArICdweCcpXG4gICAgICAgICAgICAuY3NzKCdsZWZ0JywgKGxlZnQgLSB0aGlzLmJvcmRlclBhZGRpbmcgLSB0aGlzLmJvcmRlcldpZHRoKSArICdweCcpO1xuICAgICAgICB0aGlzLmJSaWdodC5jc3MoJ2hlaWdodCcsIChoZWlnaHQgKyB0aGlzLmJvcmRlclBhZGRpbmcgKiAyKSArICdweCcpXG4gICAgICAgICAgICAuY3NzKCd0b3AnLCAodG9wIC0gdGhpcy5ib3JkZXJQYWRkaW5nKSArICdweCcpXG4gICAgICAgICAgICAuY3NzKCdsZWZ0JywgKGxlZnQgKyB3aWR0aCArIHRoaXMuYm9yZGVyUGFkZGluZykgKyAncHgnKTtcbiAgICAgICAgdGhpcy5iQm90dG9tLmNzcygnd2lkdGgnLCAod2lkdGggKyB0aGlzLmJvcmRlclBhZGRpbmcgKiAyICsgdGhpcy5ib3JkZXJXaWR0aCAqIDIgLSA1KSArICdweCcpXG4gICAgICAgICAgICAuY3NzKCd0b3AnLCAodG9wICsgaGVpZ2h0ICsgdGhpcy5ib3JkZXJQYWRkaW5nKSArICdweCcpXG4gICAgICAgICAgICAuY3NzKCdsZWZ0JywgKGxlZnQgLSB0aGlzLmJvcmRlclBhZGRpbmcgLSB0aGlzLmJvcmRlcldpZHRoKSArICdweCcpXG4gICAgICAgICAgICAuY3NzKCdjb2xvcicsICcjRjVGNUY1JylcbiAgICAgICAgICAgIC5jc3MoJ2hlaWdodCcsIHRoaXMuYm9yZGVyV2lkdGggKiA0ICsgJ3B4Jyk7XG4gICAgICAgIHRoaXMuYkxlZnQuY3NzKCdoZWlnaHQnLCAoaGVpZ2h0ICsgdGhpcy5ib3JkZXJQYWRkaW5nICogMikgKyAncHgnKVxuICAgICAgICAgICAgLmNzcygndG9wJywgKHRvcCAtIHRoaXMuYm9yZGVyUGFkZGluZykgKyAncHgnKVxuICAgICAgICAgICAgLmNzcygnbGVmdCcsIChsZWZ0IC0gdGhpcy5ib3JkZXJQYWRkaW5nIC0gdGhpcy5ib3JkZXJXaWR0aCkgKyAncHgnKTtcbiAgICAgICAgdGhpcy5zaGllbGRPdmVybGF5LmNzcygndG9wJywgdG9wICsgJ3B4JykgLy8gdXNlZCB0byBwcmV2ZW50IHNlbGVjdGlvbiBvZiBpbnZsYWlkIGVsZW1lbnRzIChpZnJhbWVzKVxuICAgICAgICAgICAgLmNzcygnbGVmdCcsIGxlZnQgKyAncHgnKTtcbiAgICAgICAgaWYgKHRhcmdldEVsZW0udGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaWZyYW1lJykgeyAvLyB3ZSBleHBhbmQgdGhlIHNoaWVsZCBvdmVyIHRoZSBkaXNzYWxvd2VkIGVsZW1lbnRzXG4gICAgICAgICAgICB0aGlzLnNoaWVsZE92ZXJsYXkuY3NzKCd3aWR0aCcsIHdpZHRoICsgJ3B4JylcbiAgICAgICAgICAgICAgICAuY3NzKCdoZWlnaHQnLCBoZWlnaHQgKyAncHgnKTtcbiAgICAgICAgICAgIHRoaXMuc2hpZWxkT3ZlcmxheS5vZmYoXCJjbGlja1wiKTtcbiAgICAgICAgICAgIHRoaXMuc2hpZWxkT3ZlcmxheS5jbGljayhmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNoaWVsZE92ZXJsYXkub2ZmKFwiY2xpY2tcIik7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLndpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYXZpZ2F0ZSA9IGNvbmZpcm0oXCJZb3UgaGF2ZSBzZWxlY3RlZCBjb250ZW50IHdpdGhpbiBhbiBpZnJhbWUgdGhhdCBjYW4ndCBjdXJyZW50bHkgYmUgc2VsZWN0ZWQuIFdvdWxkIHlvdSBsaWtlIHRvIHRyeSB0byBnb3RvIHRoZSB1cmw/XFxuKEN1cnJlbnQgc2VsZWN0aW9ucyB3aWxsIGJlIGxvc3QgaWYgeW91IGNsaWNrICdPSycpXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmF2aWdhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50VVJMID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWVTcmMgPSB0YXJnZXRFbGVtLnNyYztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBnb3RvIHdpZGdldCB3aXRoIGZyYW1lIHNyY1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hyb21lLnJ1bnRpbWUuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJjaGFuZ2VfdXJsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBjdXJyZW50VVJMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogZnJhbWVTcmMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZGV4OiBfdGhpcy53aW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhbGVydChcIk1hZ2ljIGJ1dHRvbiBjYW5ub3QgYmUgcGxhY2VkIGhlcmUsIGFzIHRoaXMgaXMgYSB3aW5kb3cgZ2V0dGluZyBjb250ZW50IGZyb20gYSBkaWZmZXJlbnQgd2Vic2l0ZS4gUGxlYXNlIHNlbGVjdCBhbm90aGVyIGFyZWEgb2YgdGhlIHBhZ2VcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNoaWVsZE92ZXJsYXkuY3NzKCd3aWR0aCcsIDAgKyAncHgnKVxuICAgICAgICAgICAgICAgIC5jc3MoJ2hlaWdodCcsIDAgKyAncHgnKTtcbiAgICAgICAgICAgIHRoaXMuc2hpZWxkT3ZlcmxheS5vZmYoXCJjbGlja1wiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIGEgd2F5IHRvIHRhcmdldCBjbGlja3Mgb24gdGhlc2UgYm9yZGVyIGVsZW1lbnRzIHRvIGRpcmVjdCB0byB0aGUgZWxlbWVudCBiZW5lYXRoXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gbW9kaWZ5IHRoZSBjb2xvcnMgaWYgd2UgYXJlIHJlbW92aW5nIGEgc2VsZWN0aW9uXG4gICAgICAgIHZhciByZW1vdmluZ1NlbGVjdGlvbiA9ICQodGFyZ2V0RWxlbSkuaXMoXCIuYXhpb20tc2VsLXN1Z2dlc3RlZC1cIiArIHRoaXMuYWN0aXZlU2VsZWN0b3JJbmRleCArIFwiLCAuYXhpb20tc2VsLXNlbGVjdGVkLVwiICsgdGhpcy5hY3RpdmVTZWxlY3RvckluZGV4KTtcbiAgICAgICAgaWYgKHJlbW92aW5nU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAkKFwiLmF4aW9tLWJvcmRlci1oaWdobGlnaHRcIikuZWFjaChmdW5jdGlvbiAoaW5kZXgsIGVsKSB7XG4gICAgICAgICAgICAgICAgZWwuc3R5bGUuc2V0UHJvcGVydHkoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwicmdiKDI0NSwgNTgsIDU4KVwiLCBcImltcG9ydGFudFwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgJChcIi5heGlvbS1ib3JkZXItaGlnaGxpZ2h0XCIpLmVhY2goZnVuY3Rpb24gKGluZGV4LCBlbCkge1xuICAgICAgICAgICAgICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KFwiYmFja2dyb3VuZC1jb2xvclwiLCBcIiNGRkFCMDBcIiwgXCJpbXBvcnRhbnRcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pZnJhbWVFbGVtZW50ICYmICF0aGlzLmlmcmFtZVN1cHBvcnRFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpZXcuY2hpbGRyZW4oJ3AnKS50ZXh0KCdFbmFibGUgaWZyYW1lIHN1cHBvcnQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcmV2aWV3ID0gdGhpcy5zY3JhcGVIZWxwZXIuZ2V0RGF0YSh0YXJnZXRFbGVtLCB0aGlzLnJlc3VsdFR5cGUpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdWx0VHlwZSA9PT0gJ3RleHRDb250ZW50Jykge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gdGFyZ2V0RWxlbVsnaW5uZXJUZXh0J107XG4gICAgICAgICAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlldyA9IHRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aWV3ID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldmlldyA9IChwcmV2aWV3KSA/IHByZXZpZXcgOiAnJztcbiAgICAgICAgICAgIHByZXZpZXcgPSAocHJldmlldy5sZW5ndGggPiAyNSkgPyBwcmV2aWV3LnN1YnN0cigwLCAyNSkgKyAnLi4uJyA6IHByZXZpZXc7XG4gICAgICAgICAgICB0aGlzLnByZXZpZXcuY2hpbGRyZW4oJ3AnKS50ZXh0KHByZXZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hvd0JvcmRlcigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBqdXN0IGRlYmFycmluZyB0aGUgY2hyb21lIGV4dGVuc2lvbiBpdGVtcywgd2UgY2FuIG1ha2UgdGhpcyBtb3JlIGNvb2xcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtZW50XG4gICAgICovXG4gICAgQm9yZGVySGlnaGxpZ2h0LnByb3RvdHlwZS5zZWxlY3RhYmxlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImJvZHlcIiB8fCBqUXVlcnkoZWxlbWVudCkuaGFzQ2xhc3MoJ2F4aW9tLXNlbGVjdG9yLWlnbm9yZScpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBCb3JkZXJIaWdobGlnaHQucHJvdG90eXBlLm1vdXNlb3ZlckhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgIGlmICh0aGlzLnJlc3VsdFR5cGUgPT09ICdsaW5rJykge1xuICAgICAgICAgICAgd2hpbGUgKHRhcmdldC5wYXJlbnRFbGVtZW50ICYmICEvXFxTLy50ZXN0KHRoaXMuc2NyYXBlSGVscGVyLmdldERhdGEodGFyZ2V0LCB0aGlzLnJlc3VsdFR5cGUpKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGFibGUodGFyZ2V0KSAmJiBlLnRhcmdldCAhPT0gdGhpcy5zaGllbGRPdmVybGF5LmdldCgwKSkge1xuICAgICAgICAgICAgdGhpcy5tYWtlQm9yZGVycyh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCb3JkZXJIaWdobGlnaHQucHJvdG90eXBlLm1vdXNlTGVhdmVIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUudGFyZ2V0ID09PSB0aGlzLmRvYy5ib2R5IHx8IGUudGFyZ2V0ID09PSB0aGlzLmRvYy5ib2R5LnBhcmVudE5vZGUgfHwgZS5yZWxhdGVkVGFyZ2V0ID09PSB0aGlzLnNoaWVsZE92ZXJsYXkuZ2V0KDApKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVCb3JkZXIoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgQm9yZGVySGlnaGxpZ2h0LnByb3RvdHlwZS5zZXRJZnJhbWVTdXBwb3J0RW5hYmxlZCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdGhpcy5pZnJhbWVTdXBwb3J0RW5hYmxlZCA9IHZhbDtcbiAgICB9O1xuICAgIHJldHVybiBCb3JkZXJIaWdobGlnaHQ7XG59KCkpO1xuZXhwb3J0cy5Cb3JkZXJIaWdobGlnaHQgPSBCb3JkZXJIaWdobGlnaHQ7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///818\n")},820:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\nvar math_namespaceObject = {};\n__webpack_require__.r(math_namespaceObject);\n__webpack_require__.d(math_namespaceObject, "min", function() { return min; });\n__webpack_require__.d(math_namespaceObject, "max", function() { return max; });\n\n// CONCATENATED MODULE: ./node_modules/diff-match-patch-typescript/dist/es/constants/index.js\n/**\n * Define some regex patterns for matching boundaries.\n *\n * Ported by [xiaochao.k@gmail.com](https://github.com/nonoroazoro)\n */\nvar NON_ALPHA_NUMERIC_REGEX = /[^a-zA-Z0-9]/;\nvar WHITESPACE_REGEX = /\\s/;\nvar LINEBREAK_REGEX = /[\\r\\n]/;\nvar BLANKLINE_END_REGEX = /\\n\\r?\\n$/;\nvar BLANKLINE_START_REGEX = /^\\r?\\n\\r?\\n/;\n\n// CONCATENATED MODULE: ./node_modules/diff-match-patch-typescript/dist/es/types/DiffOperation.js\n/**\n * Represents the operations of a `Diff`.\n *\n * The data structure representing a `Diff` is an array of tuples:\n * [[DIFF_DELETE, \'Hello\'], [DIFF_INSERT, \'Goodbye\'], [DIFF_EQUAL, \' world.\']]\n * which means: delete \'Hello\', add \'Goodbye\' and keep \' world.\'\n *\n * Ported by [xiaochao.k@gmail.com](https://github.com/nonoroazoro)\n */\nvar DiffOperation;\n(function (DiffOperation) {\n    DiffOperation[DiffOperation["DIFF_DELETE"] = -1] = "DIFF_DELETE";\n    DiffOperation[DiffOperation["DIFF_INSERT"] = 1] = "DIFF_INSERT";\n    DiffOperation[DiffOperation["DIFF_EQUAL"] = 0] = "DIFF_EQUAL";\n})(DiffOperation || (DiffOperation = {}));\n\n// CONCATENATED MODULE: ./node_modules/diff-match-patch-typescript/dist/es/types/index.js\n\n\n// CONCATENATED MODULE: ./node_modules/diff-match-patch-typescript/dist/es/utils/math.js\n/**\n * Returns the smaller number.\n */\nfunction min(a, b) {\n    return a < b ? a : b;\n}\n/**\n * Returns the larger number.\n */\nfunction max(a, b) {\n    return a > b ? a : b;\n}\n\n// CONCATENATED MODULE: ./node_modules/diff-match-patch-typescript/dist/es/utils/index.js\n\nvar math = math_namespaceObject;\n\n// CONCATENATED MODULE: ./node_modules/diff-match-patch-typescript/dist/es/core/PatchObject.js\n\n/**\n * Class representing one patch operation.\n *\n * Ported by [xiaochao.k@gmail.com](https://github.com/nonoroazoro)\n */\nvar PatchObject_PatchObject = /** @class */ (function () {\n    function PatchObject() {\n        this.diffs = [];\n        this.start1 = 0;\n        this.start2 = 0;\n        this.length1 = 0;\n        this.length2 = 0;\n    }\n    /**\n     * Emulate GNU diff format.\n     * Header: @@ -382,8 +481,9 @@\n     * Indices are printed as 1-based, not 0-based.\n     *\n     * @returns {string} The GNU diff string.\n     */\n    PatchObject.prototype.toString = function () {\n        var coords1;\n        var coords2;\n        if (this.length1 === 0) {\n            coords1 = this.start1 + ",0";\n        }\n        else if (this.length1 === 1) {\n            coords1 = this.start1 + 1;\n        }\n        else {\n            coords1 = (this.start1 + 1) + "," + this.length1;\n        }\n        if (this.length2 === 0) {\n            coords2 = this.start2 + ",0";\n        }\n        else if (this.length2 === 1) {\n            coords2 = this.start2 + 1;\n        }\n        else {\n            coords2 = (this.start2 + 1) + "," + this.length2;\n        }\n        var text = ["@@ -" + coords1 + " +" + coords2 + " @@\\n"];\n        var op;\n        // Escape the body of the patch with %xx notation.\n        for (var x = 0; x < this.diffs.length; x++) {\n            switch (this.diffs[x][0]) {\n                case DiffOperation.DIFF_INSERT:\n                    op = "+";\n                    break;\n                case DiffOperation.DIFF_DELETE:\n                    op = "-";\n                    break;\n                case DiffOperation.DIFF_EQUAL:\n                    op = " ";\n                    break;\n            }\n            text[x + 1] = op + encodeURI(this.diffs[x][1]) + "\\n";\n        }\n        return text.join("").replace(/%20/g, " ");\n    };\n    return PatchObject;\n}());\n\n\n// CONCATENATED MODULE: ./node_modules/diff-match-patch-typescript/dist/es/core/DiffMatchPatch.js\n\n\n\n\n/**\n * Diff Match and Patch\n * Copyright 2018 The diff-match-patch Authors.\n *\n * https://github.com/google/diff-match-patch\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Computes the difference between two texts to create a patch.\n * Applies the patch onto another text, allowing for errors.\n * @author fraser@google.com (Neil Fraser)\n *\n * Ported by [xiaochao.k@gmail.com](https://github.com/nonoroazoro)\n */\n/**\n * Class containing the diff, match and patch methods.\n */\nvar DiffMatchPatch_DiffMatchPatch = /** @class */ (function () {\n    function DiffMatchPatch() {\n        // Defaults.\n        // Redefine these in your program to override the defaults.\n        /**\n         * Number of seconds to map a diff before giving up (0 for infinity).\n         */\n        this.diffTimeout = 1.0;\n        /**\n         * Cost of an empty edit operation in terms of edit characters.\n         */\n        this.diffEditCost = 4;\n        /**\n         * At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n         */\n        this.matchThreshold = 0.5;\n        /**\n         * How far to search for a match (0 = exact location, 1000+ = broad match).\n         * A match this many characters away from the expected location will add\n         * 1.0 to the score (0.0 is a perfect match).\n         */\n        this.matchDistance = 1000;\n        /**\n         * When deleting a large block of text (over ~64 characters), how close do\n         * the contents have to be to match the expected contents. (0.0 = perfection,\n         * 1.0 = very loose). Note that Match_Threshold controls how closely the\n         * end points of a delete need to match.\n         */\n        this.patchDeleteThreshold = 0.5;\n        /**\n         * Chunk size for context length.\n         */\n        this.patchMargin = 4;\n        /**\n         * The number of bits in an int.\n         */\n        this.matchMaxBits = 32;\n        //#endregion PATCH FUNCTIONS (private)\n    }\n    //#region DIFF FUNCTIONS (public)\n    /**\n     * Find the differences between two texts. Simplifies the problem by stripping\n     * any common prefix or suffix off the texts before diffing.\n     *\n     * @param {string} text1 Old string to be diffed.\n     * @param {string} text2 New string to be diffed.\n     * @param {boolean} [optChecklines] Optional speedup flag. If present and false,\n     * then don\'t run a line-level diff first to identify the changed areas.\n     * Defaults to true, which does a faster, slightly less optimal diff.\n     * @param {number} [optDeadline] Optional time when the diff should be complete\n     * by. Used internally for recursive calls. Users should set DiffTimeout\n     * instead.\n     * @returns {Diff[]} Array of diff tuples.\n     */\n    DiffMatchPatch.prototype.diff_main = function (text1, text2, optChecklines, optDeadline) {\n        // Set a deadline by which time the diff must be complete.\n        if (typeof optDeadline === "undefined") {\n            if (this.diffTimeout <= 0) {\n                optDeadline = Number.MAX_VALUE;\n            }\n            else {\n                optDeadline = Date.now() + this.diffTimeout * 1000;\n            }\n        }\n        var deadline = optDeadline;\n        // Check for null inputs.\n        if (text1 == null || text2 == null) {\n            throw new Error("Null input. (diff_main)");\n        }\n        // Check for equality (speedup).\n        if (text1 === text2) {\n            if (text1) {\n                return [[DiffOperation.DIFF_EQUAL, text1]];\n            }\n            return [];\n        }\n        if (typeof optChecklines === "undefined") {\n            optChecklines = true;\n        }\n        var checklines = optChecklines;\n        // Trim off common prefix (speedup).\n        var commonlength = this.diff_commonPrefix(text1, text2);\n        var commonprefix = text1.substring(0, commonlength);\n        text1 = text1.substring(commonlength);\n        text2 = text2.substring(commonlength);\n        // Trim off common suffix (speedup).\n        commonlength = this.diff_commonSuffix(text1, text2);\n        var commonsuffix = text1.substring(text1.length - commonlength);\n        text1 = text1.substring(0, text1.length - commonlength);\n        text2 = text2.substring(0, text2.length - commonlength);\n        // Compute the diff on the middle block.\n        var diffs = this.diff_compute_(text1, text2, checklines, deadline);\n        // Restore the prefix and suffix.\n        if (commonprefix) {\n            diffs.unshift([DiffOperation.DIFF_EQUAL, commonprefix]);\n        }\n        if (commonsuffix) {\n            diffs.push([DiffOperation.DIFF_EQUAL, commonsuffix]);\n        }\n        this.diff_cleanupMerge(diffs);\n        return diffs;\n    };\n    /**\n     * Determine the common prefix of two strings.\n     *\n     * @param {string} text1 First string.\n     * @param {string} text2 Second string.\n     * @returns {number} The number of characters common to the start of each string.\n     */\n    DiffMatchPatch.prototype.diff_commonPrefix = function (text1, text2) {\n        // Quick check for common null cases.\n        if (!text1 ||\n            !text2 ||\n            text1.charAt(0) !== text2.charAt(0)) {\n            return 0;\n        }\n        // Binary search.\n        // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n        var pointermin = 0;\n        var pointermax = math.min(text1.length, text2.length);\n        var pointermid = pointermax;\n        var pointerstart = 0;\n        while (pointermin < pointermid) {\n            if (text1.substring(pointerstart, pointermid) ===\n                text2.substring(pointerstart, pointermid)) {\n                pointermin = pointermid;\n                pointerstart = pointermin;\n            }\n            else {\n                pointermax = pointermid;\n            }\n            pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n        }\n        return pointermid;\n    };\n    /**\n     * Determine the common suffix of two strings.\n     *\n     * @param {string} text1 First string.\n     * @param {string} text2 Second string.\n     * @returns {number} The number of characters common to the end of each string.\n     */\n    DiffMatchPatch.prototype.diff_commonSuffix = function (text1, text2) {\n        // Quick check for common null cases.\n        if (!text1 ||\n            !text2 ||\n            text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1)) {\n            return 0;\n        }\n        // Binary search.\n        // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n        var pointermin = 0;\n        var pointermax = math.min(text1.length, text2.length);\n        var pointermid = pointermax;\n        var pointerend = 0;\n        while (pointermin < pointermid) {\n            if (text1.substring(text1.length - pointermid, text1.length - pointerend) ===\n                text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n                pointermin = pointermid;\n                pointerend = pointermin;\n            }\n            else {\n                pointermax = pointermid;\n            }\n            pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n        }\n        return pointermid;\n    };\n    /**\n     * Reduce the number of edits by eliminating semantically trivial equalities.\n     *\n     * @param {Diff[]} diffs Array of diff tuples.\n     */\n    DiffMatchPatch.prototype.diff_cleanupSemantic = function (diffs) {\n        var changes = false;\n        var equalities = []; // Stack of indices where equalities are found.\n        var equalitiesLength = 0; // Keeping our own length var is faster in JS.\n        var lastEquality = null;\n        // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n        var pointer = 0; // Index of current position.\n        // Number of characters that changed prior to the equality.\n        var lengthInsertions1 = 0;\n        var lengthDeletions1 = 0;\n        // Number of characters that changed after the equality.\n        var lengthInsertions2 = 0;\n        var lengthDeletions2 = 0;\n        while (pointer < diffs.length) {\n            if (diffs[pointer][0] === DiffOperation.DIFF_EQUAL) {\n                // Equality found.\n                equalities[equalitiesLength++] = pointer;\n                lengthInsertions1 = lengthInsertions2;\n                lengthDeletions1 = lengthDeletions2;\n                lengthInsertions2 = 0;\n                lengthDeletions2 = 0;\n                lastEquality = diffs[pointer][1];\n            }\n            else {\n                // An insertion or deletion.\n                if (diffs[pointer][0] === DiffOperation.DIFF_INSERT) {\n                    lengthInsertions2 += diffs[pointer][1].length;\n                }\n                else {\n                    lengthDeletions2 += diffs[pointer][1].length;\n                }\n                // Eliminate an equality that is smaller or equal to the edits on both\n                // sides of it.\n                if (lastEquality &&\n                    (lastEquality.length <= math.max(lengthInsertions1, lengthDeletions1)) &&\n                    (lastEquality.length <= math.max(lengthInsertions2, lengthDeletions2))) {\n                    // Duplicate record.\n                    diffs.splice(equalities[equalitiesLength - 1], 0, [DiffOperation.DIFF_DELETE, lastEquality]);\n                    // Change second copy to insert.\n                    diffs[equalities[equalitiesLength - 1] + 1][0] = DiffOperation.DIFF_INSERT;\n                    // Throw away the equality we just deleted.\n                    equalitiesLength--;\n                    // Throw away the previous equality (it needs to be reevaluated).\n                    equalitiesLength--;\n                    pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n                    lengthInsertions1 = 0; // Reset the counters.\n                    lengthDeletions1 = 0;\n                    lengthInsertions2 = 0;\n                    lengthDeletions2 = 0;\n                    lastEquality = null;\n                    changes = true;\n                }\n            }\n            pointer++;\n        }\n        // Normalize the diff.\n        if (changes) {\n            this.diff_cleanupMerge(diffs);\n        }\n        this.diff_cleanupSemanticLossless(diffs);\n        // Find any overlaps between deletions and insertions.\n        // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n        //   -> <del>abc</del>xxx<ins>def</ins>\n        // e.g: <del>xxxabc</del><ins>defxxx</ins>\n        //   -> <ins>def</ins>xxx<del>abc</del>\n        // Only extract an overlap if it is as big as the edit ahead or behind it.\n        pointer = 1;\n        while (pointer < diffs.length) {\n            if (diffs[pointer - 1][0] === DiffOperation.DIFF_DELETE &&\n                diffs[pointer][0] === DiffOperation.DIFF_INSERT) {\n                var deletion = diffs[pointer - 1][1];\n                var insertion = diffs[pointer][1];\n                var overlapLength1 = this.diff_commonOverlap_(deletion, insertion);\n                var overlapLength2 = this.diff_commonOverlap_(insertion, deletion);\n                if (overlapLength1 >= overlapLength2) {\n                    if (overlapLength1 >= deletion.length / 2 ||\n                        overlapLength1 >= insertion.length / 2) {\n                        // Overlap found. Insert an equality and trim the surrounding edits.\n                        diffs.splice(pointer, 0, [DiffOperation.DIFF_EQUAL, insertion.substring(0, overlapLength1)]);\n                        diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1);\n                        diffs[pointer + 1][1] = insertion.substring(overlapLength1);\n                        pointer++;\n                    }\n                }\n                else {\n                    if (overlapLength2 >= deletion.length / 2 ||\n                        overlapLength2 >= insertion.length / 2) {\n                        // Reverse overlap found.\n                        // Insert an equality and swap and trim the surrounding edits.\n                        diffs.splice(pointer, 0, [DiffOperation.DIFF_EQUAL, deletion.substring(0, overlapLength2)]);\n                        diffs[pointer - 1][0] = DiffOperation.DIFF_INSERT;\n                        diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2);\n                        diffs[pointer + 1][0] = DiffOperation.DIFF_DELETE;\n                        diffs[pointer + 1][1] = deletion.substring(overlapLength2);\n                        pointer++;\n                    }\n                }\n                pointer++;\n            }\n            pointer++;\n        }\n    };\n    /**\n     * Look for single edits surrounded on both sides by equalities\n     * which can be shifted sideways to align the edit to a word boundary.\n     * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n     *\n     * @param {Diff[]} diffs Array of diff tuples.\n     */\n    DiffMatchPatch.prototype.diff_cleanupSemanticLossless = function (diffs) {\n        var pointer = 1;\n        // Intentionally ignore the first and last element (don\'t need checking).\n        while (pointer < diffs.length - 1) {\n            if (diffs[pointer - 1][0] === DiffOperation.DIFF_EQUAL &&\n                diffs[pointer + 1][0] === DiffOperation.DIFF_EQUAL) {\n                // This is a single edit surrounded by equalities.\n                var equality1 = diffs[pointer - 1][1];\n                var edit = diffs[pointer][1];\n                var equality2 = diffs[pointer + 1][1];\n                // First, shift the edit as far left as possible.\n                var commonOffset = this.diff_commonSuffix(equality1, edit);\n                if (commonOffset) {\n                    var commonString = edit.substring(edit.length - commonOffset);\n                    equality1 = equality1.substring(0, equality1.length - commonOffset);\n                    edit = commonString + edit.substring(0, edit.length - commonOffset);\n                    equality2 = commonString + equality2;\n                }\n                // Second, step character by character right, looking for the best fit.\n                var bestEquality1 = equality1;\n                var bestEdit = edit;\n                var bestEquality2 = equality2;\n                var bestScore = this.diff_cleanupSemanticScore_(equality1, edit)\n                    + this.diff_cleanupSemanticScore_(edit, equality2);\n                while (edit.charAt(0) === equality2.charAt(0)) {\n                    equality1 += edit.charAt(0);\n                    edit = edit.substring(1) + equality2.charAt(0);\n                    equality2 = equality2.substring(1);\n                    var score = this.diff_cleanupSemanticScore_(equality1, edit)\n                        + this.diff_cleanupSemanticScore_(edit, equality2);\n                    // The >= encourages trailing rather than leading whitespace on edits.\n                    if (score >= bestScore) {\n                        bestScore = score;\n                        bestEquality1 = equality1;\n                        bestEdit = edit;\n                        bestEquality2 = equality2;\n                    }\n                }\n                if (diffs[pointer - 1][1] !== bestEquality1) {\n                    // We have an improvement, save it back to the diff.\n                    if (bestEquality1) {\n                        diffs[pointer - 1][1] = bestEquality1;\n                    }\n                    else {\n                        diffs.splice(pointer - 1, 1);\n                        pointer--;\n                    }\n                    diffs[pointer][1] = bestEdit;\n                    if (bestEquality2) {\n                        diffs[pointer + 1][1] = bestEquality2;\n                    }\n                    else {\n                        diffs.splice(pointer + 1, 1);\n                        pointer--;\n                    }\n                }\n            }\n            pointer++;\n        }\n    };\n    /**\n     * Reduce the number of edits by eliminating operationally trivial equalities.\n     *\n     * @param {Diff[]} diffs Array of diff tuples.\n     */\n    DiffMatchPatch.prototype.diff_cleanupEfficiency = function (diffs) {\n        var changes = false;\n        var equalities = []; // Stack of indices where equalities are found.\n        var equalitiesLength = 0; // Keeping our own length var is faster in JS.\n        var lastEquality = null;\n        // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n        var pointer = 0; // Index of current position.\n        // Is there an insertion operation before the last equality.\n        var preIns = false;\n        // Is there a deletion operation before the last equality.\n        var preDel = false;\n        // Is there an insertion operation after the last equality.\n        var postIns = false;\n        // Is there a deletion operation after the last equality.\n        var postDel = false;\n        while (pointer < diffs.length) {\n            if (diffs[pointer][0] === DiffOperation.DIFF_EQUAL) {\n                // Equality found.\n                if (diffs[pointer][1].length < this.diffEditCost &&\n                    (postIns || postDel)) {\n                    // Candidate found.\n                    equalities[equalitiesLength++] = pointer;\n                    preIns = postIns;\n                    preDel = postDel;\n                    lastEquality = diffs[pointer][1];\n                }\n                else {\n                    // Not a candidate, and can never become one.\n                    equalitiesLength = 0;\n                    lastEquality = null;\n                }\n                postIns = postDel = false;\n            }\n            else {\n                // An insertion or deletion.\n                if (diffs[pointer][0] === DiffOperation.DIFF_DELETE) {\n                    postDel = true;\n                }\n                else {\n                    postIns = true;\n                }\n                /*\n                 * Five types to be split:\n                 * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n                 * <ins>A</ins>X<ins>C</ins><del>D</del>\n                 * <ins>A</ins><del>B</del>X<ins>C</ins>\n                 * <ins>A</del>X<ins>C</ins><del>D</del>\n                 * <ins>A</ins><del>B</del>X<del>C</del>\n                 */\n                if (lastEquality &&\n                    ((preIns && preDel && postIns && postDel) ||\n                        ((lastEquality.length < this.diffEditCost / 2) &&\n                            (Number(preIns) + Number(preDel) + Number(postIns) + Number(postDel)) === 3))) {\n                    // Duplicate record.\n                    diffs.splice(equalities[equalitiesLength - 1], 0, [DiffOperation.DIFF_DELETE, lastEquality]);\n                    // Change second copy to insert.\n                    diffs[equalities[equalitiesLength - 1] + 1][0] = DiffOperation.DIFF_INSERT;\n                    equalitiesLength--; // Throw away the equality we just deleted;\n                    lastEquality = null;\n                    if (preIns && preDel) {\n                        // No changes made which could affect previous entry, keep going.\n                        postIns = postDel = true;\n                        equalitiesLength = 0;\n                    }\n                    else {\n                        equalitiesLength--; // Throw away the previous equality.\n                        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n                        postIns = postDel = false;\n                    }\n                    changes = true;\n                }\n            }\n            pointer++;\n        }\n        if (changes) {\n            this.diff_cleanupMerge(diffs);\n        }\n    };\n    /**\n     * Reorder and merge like edit sections. Merge equalities.\n     * Any edit section can move as long as it doesn\'t cross an equality.\n     *\n     * @param {Diff[]} diffs Array of diff tuples.\n     */\n    DiffMatchPatch.prototype.diff_cleanupMerge = function (diffs) {\n        // Add a dummy entry at the end.\n        diffs.push([DiffOperation.DIFF_EQUAL, ""]);\n        var pointer = 0;\n        var countDelete = 0;\n        var countInsert = 0;\n        var textDelete = "";\n        var textInsert = "";\n        var commonlength;\n        while (pointer < diffs.length) {\n            switch (diffs[pointer][0]) {\n                case DiffOperation.DIFF_INSERT:\n                    countInsert++;\n                    textInsert += diffs[pointer][1];\n                    pointer++;\n                    break;\n                case DiffOperation.DIFF_DELETE:\n                    countDelete++;\n                    textDelete += diffs[pointer][1];\n                    pointer++;\n                    break;\n                case DiffOperation.DIFF_EQUAL:\n                    // Upon reaching an equality, check for prior redundancies.\n                    if (countDelete + countInsert > 1) {\n                        if (countDelete !== 0 && countInsert !== 0) {\n                            // Factor out any common prefixes.\n                            commonlength = this.diff_commonPrefix(textInsert, textDelete);\n                            if (commonlength !== 0) {\n                                if ((pointer - countDelete - countInsert) > 0 &&\n                                    (diffs[pointer - countDelete - countInsert - 1][0]\n                                        === DiffOperation.DIFF_EQUAL)) {\n                                    diffs[pointer - countDelete - countInsert - 1][1]\n                                        += textInsert.substring(0, commonlength);\n                                }\n                                else {\n                                    diffs.splice(0, 0, [DiffOperation.DIFF_EQUAL, textInsert.substring(0, commonlength)]);\n                                    pointer++;\n                                }\n                                textInsert = textInsert.substring(commonlength);\n                                textDelete = textDelete.substring(commonlength);\n                            }\n                            // Factor out any common suffixes.\n                            commonlength = this.diff_commonSuffix(textInsert, textDelete);\n                            if (commonlength !== 0) {\n                                diffs[pointer][1] = textInsert.substring(textInsert.length\n                                    - commonlength) + diffs[pointer][1];\n                                textInsert = textInsert.substring(0, textInsert.length - commonlength);\n                                textDelete = textDelete.substring(0, textDelete.length - commonlength);\n                            }\n                        }\n                        // Delete the offending records and add the merged ones.\n                        pointer -= countDelete + countInsert;\n                        diffs.splice(pointer, countDelete + countInsert);\n                        if (textDelete.length) {\n                            diffs.splice(pointer, 0, [DiffOperation.DIFF_DELETE, textDelete]);\n                            pointer++;\n                        }\n                        if (textInsert.length) {\n                            diffs.splice(pointer, 0, [DiffOperation.DIFF_INSERT, textInsert]);\n                            pointer++;\n                        }\n                        pointer++;\n                    }\n                    else if (pointer !== 0 && diffs[pointer - 1][0] === DiffOperation.DIFF_EQUAL) {\n                        // Merge this equality with the previous one.\n                        diffs[pointer - 1][1] += diffs[pointer][1];\n                        diffs.splice(pointer, 1);\n                    }\n                    else {\n                        pointer++;\n                    }\n                    countInsert = 0;\n                    countDelete = 0;\n                    textDelete = "";\n                    textInsert = "";\n                    break;\n            }\n        }\n        if (diffs[diffs.length - 1][1] === "") {\n            diffs.pop(); // Remove the dummy entry at the end.\n        }\n        // Second pass: look for single edits surrounded on both sides by equalities\n        // which can be shifted sideways to eliminate an equality.\n        // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n        var changes = false;\n        pointer = 1;\n        // Intentionally ignore the first and last element (don\'t need checking).\n        while (pointer < diffs.length - 1) {\n            if (diffs[pointer - 1][0] === DiffOperation.DIFF_EQUAL &&\n                diffs[pointer + 1][0] === DiffOperation.DIFF_EQUAL) {\n                // This is a single edit surrounded by equalities.\n                if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length)\n                    === diffs[pointer - 1][1]) {\n                    // Shift the edit over the previous equality.\n                    diffs[pointer][1] = diffs[pointer - 1][1]\n                        + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);\n                    diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n                    diffs.splice(pointer - 1, 1);\n                    changes = true;\n                }\n                else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length)\n                    === diffs[pointer + 1][1]) {\n                    // Shift the edit over the next equality.\n                    diffs[pointer - 1][1] += diffs[pointer + 1][1];\n                    diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length)\n                        + diffs[pointer + 1][1];\n                    diffs.splice(pointer + 1, 1);\n                    changes = true;\n                }\n            }\n            pointer++;\n        }\n        // If shifts were made, the diff needs reordering and another shift sweep.\n        if (changes) {\n            this.diff_cleanupMerge(diffs);\n        }\n    };\n    /**\n     * loc is a location in text1, compute and return the equivalent location in\n     * text2.\n     * e.g. \'The cat\' vs \'The big cat\', 1->1, 5->8\n     *\n     * @param {Diff[]} diffs Array of diff tuples.\n     * @param {number} loc Location within text1.\n     * @returns {number} Location within text2.\n     */\n    DiffMatchPatch.prototype.diff_xIndex = function (diffs, loc) {\n        var chars1 = 0;\n        var chars2 = 0;\n        var lastChars1 = 0;\n        var lastChars2 = 0;\n        var x;\n        for (x = 0; x < diffs.length; x++) {\n            if (diffs[x][0] !== DiffOperation.DIFF_INSERT) {\n                // Equality or deletion.\n                chars1 += diffs[x][1].length;\n            }\n            if (diffs[x][0] !== DiffOperation.DIFF_DELETE) {\n                // Equality or insertion.\n                chars2 += diffs[x][1].length;\n            }\n            if (chars1 > loc) {\n                // Overshot the location.\n                break;\n            }\n            lastChars1 = chars1;\n            lastChars2 = chars2;\n        }\n        // Was the location was deleted?\n        if (diffs.length !== x &&\n            diffs[x][0] === DiffOperation.DIFF_DELETE) {\n            return lastChars2;\n        }\n        // Add the remaining character length.\n        return lastChars2 + (loc - lastChars1);\n    };\n    /**\n     * Convert a diff array into a pretty HTML report.\n     *\n     * @param {Diff[]>} diffs Array of diff tuples.\n     * @returns {string} HTML representation.\n     */\n    DiffMatchPatch.prototype.diff_prettyHtml = function (diffs) {\n        var html = [];\n        var patternAMP = /&/g;\n        var patternLT = /</g;\n        var patternGT = />/g;\n        var patternPARA = /\\n/g;\n        for (var x = 0; x < diffs.length; x++) {\n            var op = diffs[x][0]; // Operation (insert, delete, equal)\n            var data = diffs[x][1]; // Text of change.\n            var text = data.replace(patternAMP, "&amp;")\n                .replace(patternLT, "&lt;")\n                .replace(patternGT, "&gt;")\n                .replace(patternPARA, "&para;<br>");\n            switch (op) {\n                case DiffOperation.DIFF_INSERT:\n                    html[x] = \'<ins style="background:#e6ffe6;">\' + text + "</ins>";\n                    break;\n                case DiffOperation.DIFF_DELETE:\n                    html[x] = \'<del style="background:#ffe6e6;">\' + text + "</del>";\n                    break;\n                case DiffOperation.DIFF_EQUAL:\n                    html[x] = "<span>" + text + "</span>";\n                    break;\n            }\n        }\n        return html.join("");\n    };\n    /**\n     * Compute and return the source text (all equalities and deletions).\n     *\n     * @param {Diff[]} diffs Array of diff tuples.\n     * @returns {string} Source text.\n     */\n    DiffMatchPatch.prototype.diff_text1 = function (diffs) {\n        var text = [];\n        for (var x = 0; x < diffs.length; x++) {\n            if (diffs[x][0] !== DiffOperation.DIFF_INSERT) {\n                text[x] = diffs[x][1];\n            }\n        }\n        return text.join("");\n    };\n    /**\n     * Compute and return the destination text (all equalities and insertions).\n     *\n     * @param {Diff[]} diffs Array of diff tuples.\n     * @returns {string} Destination text.\n     */\n    DiffMatchPatch.prototype.diff_text2 = function (diffs) {\n        var text = [];\n        for (var x = 0; x < diffs.length; x++) {\n            if (diffs[x][0] !== DiffOperation.DIFF_DELETE) {\n                text[x] = diffs[x][1];\n            }\n        }\n        return text.join("");\n    };\n    /**\n     * Compute the Levenshtein distance; the number of inserted, deleted or\n     * substituted characters.\n     *\n     * @param {Diff[]} diffs Array of diff tuples.\n     * @returns {number} Number of changes.\n     */\n    DiffMatchPatch.prototype.diff_levenshtein = function (diffs) {\n        var levenshtein = 0;\n        var insertions = 0;\n        var deletions = 0;\n        for (var x = 0; x < diffs.length; x++) {\n            var op = diffs[x][0];\n            var data = diffs[x][1];\n            switch (op) {\n                case DiffOperation.DIFF_INSERT:\n                    insertions += data.length;\n                    break;\n                case DiffOperation.DIFF_DELETE:\n                    deletions += data.length;\n                    break;\n                case DiffOperation.DIFF_EQUAL:\n                    // A deletion and an insertion is one substitution.\n                    levenshtein += math.max(insertions, deletions);\n                    insertions = 0;\n                    deletions = 0;\n                    break;\n            }\n        }\n        levenshtein += math.max(insertions, deletions);\n        return levenshtein;\n    };\n    /**\n     * Crush the diff into an encoded string which describes the operations\n     * required to transform text1 into text2.\n     * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert \'ing\'.\n     * Operations are tab-separated. Inserted text is escaped using %xx notation.\n     *\n     * @param {Diff[]} diffs Array of diff tuples.\n     * @returns {string} Delta text.\n     */\n    DiffMatchPatch.prototype.diff_toDelta = function (diffs) {\n        var text = [];\n        for (var x = 0; x < diffs.length; x++) {\n            switch (diffs[x][0]) {\n                case DiffOperation.DIFF_INSERT:\n                    text[x] = "+" + encodeURI(diffs[x][1]);\n                    break;\n                case DiffOperation.DIFF_DELETE:\n                    text[x] = "-" + diffs[x][1].length;\n                    break;\n                case DiffOperation.DIFF_EQUAL:\n                    text[x] = "=" + diffs[x][1].length;\n                    break;\n            }\n        }\n        return text.join("\\t").replace(/%20/g, " ");\n    };\n    /**\n     * Given the original text1, and an encoded string which describes the\n     * operations required to transform text1 into text2, compute the full diff.\n     *\n     * @param {string} text1 Source string for the diff.\n     * @param {string} delta Delta text.\n     * @returns {Diff[]} Array of diff tuples.\n     * @throws {Error} If invalid input.\n     */\n    DiffMatchPatch.prototype.diff_fromDelta = function (text1, delta) {\n        var diffs = [];\n        var diffsLength = 0; // Keeping our own length var is faster in JS.\n        var pointer = 0; // Cursor in text1\n        var tokens = delta.split(/\\t/g);\n        for (var x = 0; x < tokens.length; x++) {\n            // Each token begins with a one character parameter which specifies the\n            // operation of this token (delete, insert, equality).\n            var param = tokens[x].substring(1);\n            switch (tokens[x].charAt(0)) {\n                case "+":\n                    try {\n                        diffs[diffsLength++] = [DiffOperation.DIFF_INSERT, decodeURI(param)];\n                    }\n                    catch (ex) {\n                        // Malformed URI sequence.\n                        throw new Error("Illegal escape in diff_fromDelta: " + param);\n                    }\n                    break;\n                case "-":\n                // Fall through.\n                case "=":\n                    var n = parseInt(param, 10);\n                    if (isNaN(n) || n < 0) {\n                        throw new Error("Invalid number in diff_fromDelta: " + param);\n                    }\n                    var text = text1.substring(pointer, pointer += n);\n                    if (tokens[x].charAt(0) === "=") {\n                        diffs[diffsLength++] = [DiffOperation.DIFF_EQUAL, text];\n                    }\n                    else {\n                        diffs[diffsLength++] = [DiffOperation.DIFF_DELETE, text];\n                    }\n                    break;\n                default:\n                    // Blank tokens are ok (from a trailing \\t).\n                    // Anything else is an error.\n                    if (tokens[x]) {\n                        throw new Error("Invalid diff operation in diff_fromDelta: " + tokens[x]);\n                    }\n            }\n        }\n        if (pointer !== text1.length) {\n            throw new Error("Delta length (" + pointer + ") does not equal source text length ("\n                + text1.length + ")");\n        }\n        return diffs;\n    };\n    //#endregion DIFF FUNCTIONS (public)\n    //#region MATCH FUNCTIONS (public)\n    /**\n     * Locate the best instance of \'pattern\' in \'text\' near \'loc\'.\n     *\n     * @param {string} text The text to search.\n     * @param {string} pattern The pattern to search for.\n     * @param {number} loc The location to search around.\n     * @returns {number} Best match index or -1.\n     */\n    DiffMatchPatch.prototype.match_main = function (text, pattern, loc) {\n        // Check for null inputs.\n        if (text == null || pattern == null || loc == null) {\n            throw new Error("Null input. (match_main)");\n        }\n        loc = math.max(0, math.min(loc, text.length));\n        if (text === pattern) {\n            // Shortcut (potentially not guaranteed by the algorithm)\n            return 0;\n        }\n        else if (!text.length) {\n            // Nothing to match.\n            return -1;\n        }\n        else if (text.substring(loc, loc + pattern.length) === pattern) {\n            // Perfect match at the perfect spot!  (Includes case of null pattern)\n            return loc;\n        }\n        else {\n            // Do a fuzzy compare.\n            return this.match_bitap_(text, pattern, loc);\n        }\n    };\n    //#endregion MATCH FUNCTIONS (public)\n    //#region PATCH FUNCTIONS (public)\n    /**\n     * Compute a list of patches to turn text1 into text2.\n     * Use diffs if provided, otherwise compute it ourselves.\n     * There are four ways to call this function, depending on what data is\n     * available to the caller:\n     * Method 1:\n     * a = text1, b = text2\n     * Method 2:\n     * a = diffs\n     * Method 3 (optimal):\n     * a = text1, b = diffs\n     * Method 4 (deprecated, use method 3):\n     * a = text1, b = text2, c = diffs\n     *\n     * @param {(string|Diff[])} a text1 (methods 1,3,4) or\n     * Array of diff tuples for text1 to text2 (method 2).\n     * @param {(string|Diff[])} [optB] text2 (methods 1,4) or\n     * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).\n     * @param {(string|Diff[])} [optC] Array of diff tuples\n     * for text1 to text2 (method 4) or undefined (methods 1,2,3).\n     * @returns {PatchObject[]} Array of Patch objects.\n     */\n    DiffMatchPatch.prototype.patch_make = function (a, optB, optC) {\n        var text1;\n        var diffs;\n        if (typeof a === "string" &&\n            typeof optB === "string" &&\n            typeof optC === "undefined") {\n            // Method 1: text1, text2\n            // Compute diffs from text1 and text2.\n            text1 = a;\n            diffs = this.diff_main(text1, optB, true);\n            if (diffs.length > 2) {\n                this.diff_cleanupSemantic(diffs);\n                this.diff_cleanupEfficiency(diffs);\n            }\n        }\n        else if (a &&\n            typeof a === "object" &&\n            typeof optB === "undefined" &&\n            typeof optC === "undefined") {\n            // Method 2: diffs\n            // Compute text1 from diffs.\n            diffs = a;\n            text1 = this.diff_text1(diffs);\n        }\n        else if (typeof a === "string" &&\n            optB &&\n            typeof optB === "object" &&\n            typeof optC === "undefined") {\n            // Method 3: text1, diffs\n            text1 = a;\n            diffs = optB;\n        }\n        else if (typeof a === "string" &&\n            typeof optB === "string" &&\n            optC &&\n            typeof optC === "object") {\n            // Method 4: text1, text2, diffs\n            // text2 is not used.\n            text1 = a;\n            diffs = optC;\n        }\n        else {\n            throw new Error("Unknown call format to patch_make");\n        }\n        if (diffs.length === 0) {\n            return []; // Get rid of the null case.\n        }\n        var patches = [];\n        var patch = new PatchObject_PatchObject();\n        var patchDiffLength = 0; // Keeping our own length var is faster in JS.\n        var charCount1 = 0; // Number of characters into the text1 string.\n        var charCount2 = 0; // Number of characters into the text2 string.\n        // Start with text1 (prepatch_text) and apply the diffs until we arrive at\n        // text2 (postpatch_text). We recreate the patches one by one to determine\n        // context info.\n        var prepatchText = text1;\n        var postpatchText = text1;\n        for (var x = 0; x < diffs.length; x++) {\n            var diffType = diffs[x][0];\n            var diffText = diffs[x][1];\n            if (!patchDiffLength && diffType !== DiffOperation.DIFF_EQUAL) {\n                // A new patch starts here.\n                patch.start1 = charCount1;\n                patch.start2 = charCount2;\n            }\n            switch (diffType) {\n                case DiffOperation.DIFF_INSERT:\n                    patch.diffs[patchDiffLength++] = diffs[x];\n                    patch.length2 += diffText.length;\n                    postpatchText = postpatchText.substring(0, charCount2)\n                        + diffText + postpatchText.substring(charCount2);\n                    break;\n                case DiffOperation.DIFF_DELETE:\n                    patch.length1 += diffText.length;\n                    patch.diffs[patchDiffLength++] = diffs[x];\n                    postpatchText = postpatchText.substring(0, charCount2)\n                        + postpatchText.substring(charCount2 + diffText.length);\n                    break;\n                case DiffOperation.DIFF_EQUAL:\n                    if (diffText.length <= 2 * this.patchMargin &&\n                        patchDiffLength &&\n                        diffs.length !== x + 1) {\n                        // Small equality inside a patch.\n                        patch.diffs[patchDiffLength++] = diffs[x];\n                        patch.length1 += diffText.length;\n                        patch.length2 += diffText.length;\n                    }\n                    else if (diffText.length >= 2 * this.patchMargin) {\n                        // Time for a new patch.\n                        if (patchDiffLength) {\n                            this.patch_addContext_(patch, prepatchText);\n                            patches.push(patch);\n                            patch = new PatchObject_PatchObject();\n                            patchDiffLength = 0;\n                            // Unlike Unidiff, our patch lists have a rolling context.\n                            // https://github.com/google/diff-match-patch/wiki/Unidiff\n                            // Update prepatch text & pos to reflect the application of the\n                            // just completed patch.\n                            prepatchText = postpatchText;\n                            charCount1 = charCount2;\n                        }\n                    }\n                    break;\n            }\n            // Update the current character count.\n            if (diffType !== DiffOperation.DIFF_INSERT) {\n                charCount1 += diffText.length;\n            }\n            if (diffType !== DiffOperation.DIFF_DELETE) {\n                charCount2 += diffText.length;\n            }\n        }\n        // Pick up the leftover patch if not empty.\n        if (patchDiffLength) {\n            this.patch_addContext_(patch, prepatchText);\n            patches.push(patch);\n        }\n        return patches;\n    };\n    /**\n     * Given an array of patches, return another array that is identical.\n     *\n     * @param {PatchObject[]>} patches Array of Patch objects.\n     * @returns {PatchObject[]} Array of Patch objects.\n     */\n    DiffMatchPatch.prototype.patch_deepCopy = function (patches) {\n        // Making deep copies is hard in JavaScript.\n        var patchesCopy = [];\n        for (var x = 0; x < patches.length; x++) {\n            var patch = patches[x];\n            var patchCopy = new PatchObject_PatchObject();\n            for (var y = 0; y < patch.diffs.length; y++) {\n                patchCopy.diffs[y] = [patch.diffs[y][0], patch.diffs[y][1]];\n            }\n            patchCopy.start1 = patch.start1;\n            patchCopy.start2 = patch.start2;\n            patchCopy.length1 = patch.length1;\n            patchCopy.length2 = patch.length2;\n            patchesCopy[x] = patchCopy;\n        }\n        return patchesCopy;\n    };\n    /**\n     * Merge a set of patches onto the text. Return a patched text, as well\n     * as a list of true/false values indicating which patches were applied.\n     *\n     * @param {PatchObject[]} patches Array of Patch objects.\n     * @param {string} text Old text.\n     * @returns {PatchApplyArray} Two element Array, containing the\n     * new text and an array of boolean values.\n     */\n    DiffMatchPatch.prototype.patch_apply = function (patches, text) {\n        if (patches.length === 0) {\n            return [text, []];\n        }\n        // Deep copy the patches so that no changes are made to originals.\n        patches = this.patch_deepCopy(patches);\n        var nullPadding = this.patch_addPadding(patches);\n        text = nullPadding + text + nullPadding;\n        this.patch_splitMax(patches);\n        // delta keeps track of the offset between the expected and actual location\n        // of the previous patch. If there are patches expected at positions 10 and\n        // 20, but the first patch was found at 12, delta is 2 and the second patch\n        // has an effective expected position of 22.\n        var delta = 0;\n        var results = [];\n        for (var x = 0; x < patches.length; x++) {\n            var expectedLoc = patches[x].start2 + delta;\n            var text1 = this.diff_text1(patches[x].diffs);\n            var startLoc = void 0;\n            var endLoc = -1;\n            if (text1.length > this.matchMaxBits) {\n                // patch_splitMax will only provide an oversized pattern in the case of\n                // a monster delete.\n                startLoc = this.match_main(text, text1.substring(0, this.matchMaxBits), expectedLoc);\n                if (startLoc !== -1) {\n                    endLoc = this.match_main(text, text1.substring(text1.length - this.matchMaxBits), expectedLoc + text1.length - this.matchMaxBits);\n                    if (endLoc === -1 || startLoc >= endLoc) {\n                        // Can\'t find valid trailing context. Drop this patch.\n                        startLoc = -1;\n                    }\n                }\n            }\n            else {\n                startLoc = this.match_main(text, text1, expectedLoc);\n            }\n            if (startLoc === -1) {\n                // No match found. :(\n                results[x] = false;\n                // Subtract the delta for this failed patch from subsequent patches.\n                delta -= patches[x].length2 - patches[x].length1;\n            }\n            else {\n                // Found a match. :)\n                results[x] = true;\n                delta = startLoc - expectedLoc;\n                var text2 = void 0;\n                if (endLoc === -1) {\n                    text2 = text.substring(startLoc, startLoc + text1.length);\n                }\n                else {\n                    text2 = text.substring(startLoc, endLoc + this.matchMaxBits);\n                }\n                if (text1 === text2) {\n                    // Perfect match, just shove the replacement text in.\n                    text = text.substring(0, startLoc)\n                        + this.diff_text2(patches[x].diffs)\n                        + text.substring(startLoc + text1.length);\n                }\n                else {\n                    // Imperfect match. Run a diff to get a framework of equivalent\n                    // indices.\n                    var diffs = this.diff_main(text1, text2, false);\n                    if (text1.length > this.matchMaxBits &&\n                        this.diff_levenshtein(diffs) / text1.length > this.patchDeleteThreshold) {\n                        // The end points match, but the content is unacceptably bad.\n                        results[x] = false;\n                    }\n                    else {\n                        this.diff_cleanupSemanticLossless(diffs);\n                        var index1 = 0;\n                        var index2 = 0;\n                        for (var y = 0; y < patches[x].diffs.length; y++) {\n                            var mod = patches[x].diffs[y];\n                            if (mod[0] !== DiffOperation.DIFF_EQUAL) {\n                                index2 = this.diff_xIndex(diffs, index1);\n                            }\n                            if (mod[0] === DiffOperation.DIFF_INSERT) {\n                                // Insertion\n                                text = text.substring(0, startLoc + index2) + mod[1]\n                                    + text.substring(startLoc + index2);\n                            }\n                            else if (mod[0] === DiffOperation.DIFF_DELETE) {\n                                // Deletion\n                                text = text.substring(0, startLoc + index2)\n                                    + text.substring(startLoc\n                                        + this.diff_xIndex(diffs, index1 + mod[1].length));\n                            }\n                            if (mod[0] !== DiffOperation.DIFF_DELETE) {\n                                index1 += mod[1].length;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // Strip the padding off.\n        text = text.substring(nullPadding.length, text.length - nullPadding.length);\n        return [text, results];\n    };\n    /**\n     * Add some padding on text start and end so that edges can match something.\n     * Intended to be called only from within patch_apply.\n     *\n     * @param {PatchObject[]} patches Array of Patch objects.\n     * @returns {string} The padding string added to each side.\n     */\n    DiffMatchPatch.prototype.patch_addPadding = function (patches) {\n        var paddingLength = this.patchMargin;\n        var nullPadding = "";\n        for (var x = 1; x <= paddingLength; x++) {\n            nullPadding += String.fromCharCode(x);\n        }\n        // Bump all the patches forward.\n        for (var x = 0; x < patches.length; x++) {\n            patches[x].start1 += paddingLength;\n            patches[x].start2 += paddingLength;\n        }\n        // Add some padding on start of first diff.\n        var patch = patches[0];\n        var diffs = patch.diffs;\n        if (diffs.length === 0 || diffs[0][0] !== DiffOperation.DIFF_EQUAL) {\n            // Add nullPadding equality.\n            diffs.unshift([DiffOperation.DIFF_EQUAL, nullPadding]);\n            patch.start1 -= paddingLength; // Should be 0.\n            patch.start2 -= paddingLength; // Should be 0.\n            patch.length1 += paddingLength;\n            patch.length2 += paddingLength;\n        }\n        else if (paddingLength > diffs[0][1].length) {\n            // Grow first equality.\n            var extraLength = paddingLength - diffs[0][1].length;\n            diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];\n            patch.start1 -= extraLength;\n            patch.start2 -= extraLength;\n            patch.length1 += extraLength;\n            patch.length2 += extraLength;\n        }\n        // Add some padding on end of last diff.\n        patch = patches[patches.length - 1];\n        diffs = patch.diffs;\n        if (diffs.length === 0 || diffs[diffs.length - 1][0] !== DiffOperation.DIFF_EQUAL) {\n            // Add nullPadding equality.\n            diffs.push([DiffOperation.DIFF_EQUAL, nullPadding]);\n            patch.length1 += paddingLength;\n            patch.length2 += paddingLength;\n        }\n        else if (paddingLength > diffs[diffs.length - 1][1].length) {\n            // Grow last equality.\n            var extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n            diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);\n            patch.length1 += extraLength;\n            patch.length2 += extraLength;\n        }\n        return nullPadding;\n    };\n    /**\n     * Look through the patches and break up any which are longer than the maximum\n     * limit of the match algorithm.\n     * Intended to be called only from within patch_apply.\n     *\n     * @param {PatchObject[]} patches Array of Patch objects.\n     */\n    DiffMatchPatch.prototype.patch_splitMax = function (patches) {\n        var patchSize = this.matchMaxBits;\n        for (var x = 0; x < patches.length; x++) {\n            if (patches[x].length1 <= patchSize) {\n                continue;\n            }\n            var bigpatch = patches[x];\n            // Remove the big old patch.\n            patches.splice(x--, 1);\n            var start1 = bigpatch.start1;\n            var start2 = bigpatch.start2;\n            var precontext = "";\n            while (bigpatch.diffs.length !== 0) {\n                // Create one of several smaller patches.\n                var patch = new PatchObject_PatchObject();\n                var empty = true;\n                patch.start1 = start1 - precontext.length;\n                patch.start2 = start2 - precontext.length;\n                if (precontext !== "") {\n                    patch.length1 = patch.length2 = precontext.length;\n                    patch.diffs.push([DiffOperation.DIFF_EQUAL, precontext]);\n                }\n                while (bigpatch.diffs.length !== 0 &&\n                    patch.length1 < patchSize - this.patchMargin) {\n                    var diffType = bigpatch.diffs[0][0];\n                    var diffText = bigpatch.diffs[0][1];\n                    if (diffType === DiffOperation.DIFF_INSERT) {\n                        // Insertions are harmless.\n                        patch.length2 += diffText.length;\n                        start2 += diffText.length;\n                        patch.diffs.push(bigpatch.diffs.shift());\n                        empty = false;\n                    }\n                    else if (diffType === DiffOperation.DIFF_DELETE &&\n                        patch.diffs.length === 1 &&\n                        patch.diffs[0][0] === DiffOperation.DIFF_EQUAL &&\n                        diffText.length > 2 * patchSize) {\n                        // This is a large deletion. Let it pass in one chunk.\n                        patch.length1 += diffText.length;\n                        start1 += diffText.length;\n                        empty = false;\n                        patch.diffs.push([diffType, diffText]);\n                        bigpatch.diffs.shift();\n                    }\n                    else {\n                        // Deletion or equality. Only take as much as we can stomach.\n                        diffText = diffText.substring(0, patchSize - patch.length1 - this.patchMargin);\n                        patch.length1 += diffText.length;\n                        start1 += diffText.length;\n                        if (diffType === DiffOperation.DIFF_EQUAL) {\n                            patch.length2 += diffText.length;\n                            start2 += diffText.length;\n                        }\n                        else {\n                            empty = false;\n                        }\n                        patch.diffs.push([diffType, diffText]);\n                        if (diffText === bigpatch.diffs[0][1]) {\n                            bigpatch.diffs.shift();\n                        }\n                        else {\n                            bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diffText.length);\n                        }\n                    }\n                }\n                // Compute the head context for the next patch.\n                precontext = this.diff_text2(patch.diffs);\n                precontext = precontext.substring(precontext.length - this.patchMargin);\n                // Append the end context for this patch.\n                var postcontext = this.diff_text1(bigpatch.diffs).substring(0, this.patchMargin);\n                if (postcontext !== "") {\n                    patch.length1 += postcontext.length;\n                    patch.length2 += postcontext.length;\n                    if (patch.diffs.length !== 0 &&\n                        patch.diffs[patch.diffs.length - 1][0] === DiffOperation.DIFF_EQUAL) {\n                        patch.diffs[patch.diffs.length - 1][1] += postcontext;\n                    }\n                    else {\n                        patch.diffs.push([DiffOperation.DIFF_EQUAL, postcontext]);\n                    }\n                }\n                if (!empty) {\n                    patches.splice(++x, 0, patch);\n                }\n            }\n        }\n    };\n    /**\n     * Take a list of patches and return a textual representation.\n     *\n     * @param {PatchObject[]} patches Array of Patch objects.\n     * @returns {string} Text representation of patches.\n     */\n    DiffMatchPatch.prototype.patch_toText = function (patches) {\n        var text = [];\n        for (var x = 0; x < patches.length; x++) {\n            text[x] = patches[x];\n        }\n        return text.join("");\n    };\n    /**\n     * Parse a textual representation of patches and return a list of Patch objects.\n     *\n     * @param {string} textline Text representation of patches.\n     * @returns {PatchObject[]} Array of Patch objects.\n     * @throws {Error} If invalid input.\n     */\n    DiffMatchPatch.prototype.patch_fromText = function (textline) {\n        var patches = [];\n        if (!textline) {\n            return patches;\n        }\n        var text = textline.split("\\n");\n        var textPointer = 0;\n        var patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\n        while (textPointer < text.length) {\n            var m = text[textPointer].match(patchHeader);\n            if (!m) {\n                throw new Error("Invalid patch string: " + text[textPointer]);\n            }\n            var patch = new PatchObject_PatchObject();\n            patches.push(patch);\n            patch.start1 = parseInt(m[1], 10);\n            if (m[2] === "") {\n                patch.start1--;\n                patch.length1 = 1;\n            }\n            else if (m[2] === "0") {\n                patch.length1 = 0;\n            }\n            else {\n                patch.start1--;\n                patch.length1 = parseInt(m[2], 10);\n            }\n            patch.start2 = parseInt(m[3], 10);\n            if (m[4] === "") {\n                patch.start2--;\n                patch.length2 = 1;\n            }\n            else if (m[4] === "0") {\n                patch.length2 = 0;\n            }\n            else {\n                patch.start2--;\n                patch.length2 = parseInt(m[4], 10);\n            }\n            textPointer++;\n            var sign = void 0;\n            var line = void 0;\n            var rawLine = void 0;\n            while (textPointer < text.length) {\n                sign = text[textPointer].charAt(0);\n                rawLine = text[textPointer].substring(1);\n                try {\n                    line = decodeURI(rawLine);\n                }\n                catch (ex) {\n                    // Malformed URI sequence.\n                    throw new Error("Illegal escape in patch_fromText: " + rawLine);\n                }\n                if (sign === "-") {\n                    // Deletion.\n                    patch.diffs.push([DiffOperation.DIFF_DELETE, line]);\n                }\n                else if (sign === "+") {\n                    // Insertion.\n                    patch.diffs.push([DiffOperation.DIFF_INSERT, line]);\n                }\n                else if (sign === " ") {\n                    // Minor equality.\n                    patch.diffs.push([DiffOperation.DIFF_EQUAL, line]);\n                }\n                else if (sign === "@") {\n                    // Start of next patch.\n                    break;\n                }\n                else if (sign === "") {\n                    // Blank line?  Whatever.\n                }\n                else {\n                    // WTF?\n                    throw new Error(\'Invalid patch mode "\' + sign + \'" in: \' + line);\n                }\n                textPointer++;\n            }\n        }\n        return patches;\n    };\n    //#endregion PATCH FUNCTIONS (public)\n    //#region DIFF FUNCTIONS (private)\n    /**\n     * Find the differences between two texts. Assumes that the texts do not\n     * have any common prefix or suffix.\n     *\n     * @private\n     * @param {string} text1 Old string to be diffed.\n     * @param {string} text2 New string to be diffed.\n     * @param {boolean} checklines Speedup flag. If false, then don\'t run a\n     * line-level diff first to identify the changed areas.\n     * If true, then run a faster, slightly less optimal diff.\n     * @param {number} deadline Time when the diff should be complete by.\n     * @returns {Diff[]} Array of diff tuples.\n     */\n    DiffMatchPatch.prototype.diff_compute_ = function (text1, text2, checklines, deadline) {\n        var diffs;\n        if (!text1) {\n            // Just add some text (speedup).\n            return [[DiffOperation.DIFF_INSERT, text2]];\n        }\n        if (!text2) {\n            // Just delete some text (speedup).\n            return [[DiffOperation.DIFF_DELETE, text1]];\n        }\n        var longtext = text1.length > text2.length ? text1 : text2;\n        var shorttext = text1.length > text2.length ? text2 : text1;\n        var i = longtext.indexOf(shorttext);\n        if (i !== -1) {\n            // Shorter text is inside the longer text (speedup).\n            diffs = [\n                [DiffOperation.DIFF_INSERT, longtext.substring(0, i)],\n                [DiffOperation.DIFF_EQUAL, shorttext],\n                [DiffOperation.DIFF_INSERT, longtext.substring(i + shorttext.length)]\n            ];\n            // Swap insertions for deletions if diff is reversed.\n            if (text1.length > text2.length) {\n                diffs[0][0] = DiffOperation.DIFF_DELETE;\n                diffs[2][0] = DiffOperation.DIFF_DELETE;\n            }\n            return diffs;\n        }\n        if (shorttext.length === 1) {\n            // Single character string.\n            // After the previous speedup, the character can\'t be an equality.\n            return [\n                [DiffOperation.DIFF_DELETE, text1],\n                [DiffOperation.DIFF_INSERT, text2]\n            ];\n        }\n        // Check to see if the problem can be split in two.\n        var hm = this.diff_halfMatch_(text1, text2);\n        if (hm) {\n            // A half-match was found, sort out the return data.\n            var text1A = hm[0];\n            var text1B = hm[1];\n            var text2A = hm[2];\n            var text2B = hm[3];\n            var midCommon = hm[4];\n            // Send both pairs off for separate processing.\n            var diffsA = this.diff_main(text1A, text2A, checklines, deadline);\n            var diffsB = this.diff_main(text1B, text2B, checklines, deadline);\n            // Merge the results.\n            return diffsA.concat([[DiffOperation.DIFF_EQUAL, midCommon]], diffsB);\n        }\n        if (checklines && text1.length > 100 && text2.length > 100) {\n            return this.diff_lineMode_(text1, text2, deadline);\n        }\n        return this.diff_bisect_(text1, text2, deadline);\n    };\n    /**\n     * Do a quick line-level diff on both strings, then re-diff the parts for\n     * greater accuracy.\n     * This speedup can produce non-minimal diffs.\n     *\n     * @private\n     * @param {string} text1 Old string to be diffed.\n     * @param {string} text2 New string to be diffed.\n     * @param {number} deadline Time when the diff should be complete by.\n     * @returns {Diff[]} Array of diff tuples.\n     */\n    DiffMatchPatch.prototype.diff_lineMode_ = function (text1, text2, deadline) {\n        // Scan the text on a line-by-line basis first.\n        var a = this.diff_linesToChars_(text1, text2);\n        text1 = a.chars1;\n        text2 = a.chars2;\n        var linearray = a.lineArray;\n        var diffs = this.diff_main(text1, text2, false, deadline);\n        // Convert the diff back to original text.\n        this.diff_charsToLines_(diffs, linearray);\n        // Eliminate freak matches (e.g. blank lines)\n        this.diff_cleanupSemantic(diffs);\n        // Re-diff any replacement blocks, this time character-by-character.\n        // Add a dummy entry at the end.\n        diffs.push([DiffOperation.DIFF_EQUAL, ""]);\n        var pointer = 0;\n        var countDelete = 0;\n        var countInsert = 0;\n        var textDelete = "";\n        var textInsert = "";\n        while (pointer < diffs.length) {\n            switch (diffs[pointer][0]) {\n                case DiffOperation.DIFF_INSERT:\n                    countInsert++;\n                    textInsert += diffs[pointer][1];\n                    break;\n                case DiffOperation.DIFF_DELETE:\n                    countDelete++;\n                    textDelete += diffs[pointer][1];\n                    break;\n                case DiffOperation.DIFF_EQUAL:\n                    // Upon reaching an equality, check for prior redundancies.\n                    if (countDelete >= 1 && countInsert >= 1) {\n                        // Delete the offending records and add the merged ones.\n                        diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert);\n                        pointer = pointer - countDelete - countInsert;\n                        var subDiff = this.diff_main(textDelete, textInsert, false, deadline);\n                        for (var j = subDiff.length - 1; j >= 0; j--) {\n                            diffs.splice(pointer, 0, subDiff[j]);\n                        }\n                        pointer = pointer + subDiff.length;\n                    }\n                    countInsert = 0;\n                    countDelete = 0;\n                    textDelete = "";\n                    textInsert = "";\n                    break;\n            }\n            pointer++;\n        }\n        // Remove the dummy entry at the end.\n        diffs.pop();\n        return diffs;\n    };\n    /**\n     * Find the \'middle snake\' of a diff, split the problem in two\n     * and return the recursively constructed diff.\n     * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n     *\n     * @private\n     * @param {string} text1 Old string to be diffed.\n     * @param {string} text2 New string to be diffed.\n     * @param {number} deadline Time at which to bail if not yet complete.\n     * @returns {Diff[]} Array of diff tuples.\n     */\n    DiffMatchPatch.prototype.diff_bisect_ = function (text1, text2, deadline) {\n        // Cache the text lengths to prevent multiple calls.\n        var text1Length = text1.length;\n        var text2Length = text2.length;\n        var maxD = Math.ceil((text1Length + text2Length) / 2);\n        var vOffset = maxD;\n        var vLength = 2 * maxD;\n        var v1 = new Array(vLength);\n        var v2 = new Array(vLength);\n        // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n        // integers and undefined.\n        for (var x = 0; x < vLength; x++) {\n            v1[x] = -1;\n            v2[x] = -1;\n        }\n        v1[vOffset + 1] = 0;\n        v2[vOffset + 1] = 0;\n        var delta = text1Length - text2Length;\n        // If the total number of characters is odd, then the front path will collide\n        // with the reverse path.\n        var front = (delta % 2 !== 0);\n        // Offsets for start and end of k loop.\n        // Prevents mapping of space beyond the grid.\n        var k1Start = 0;\n        var k1End = 0;\n        var k2Start = 0;\n        var k2End = 0;\n        for (var d = 0; d < maxD; d++) {\n            // Bail out if deadline is reached.\n            if (Date.now() > deadline) {\n                break;\n            }\n            // Walk the front path one step.\n            for (var k1 = -d + k1Start; k1 <= d - k1End; k1 += 2) {\n                var k1Offset = vOffset + k1;\n                var x1 = void 0;\n                if (k1 === -d || (k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1])) {\n                    x1 = v1[k1Offset + 1];\n                }\n                else {\n                    x1 = v1[k1Offset - 1] + 1;\n                }\n                var y1 = x1 - k1;\n                while (x1 < text1Length\n                    && y1 < text2Length\n                    && text1.charAt(x1) === text2.charAt(y1)) {\n                    x1++;\n                    y1++;\n                }\n                v1[k1Offset] = x1;\n                if (x1 > text1Length) {\n                    // Ran off the right of the graph.\n                    k1End += 2;\n                }\n                else if (y1 > text2Length) {\n                    // Ran off the bottom of the graph.\n                    k1Start += 2;\n                }\n                else if (front) {\n                    var k2Offset = vOffset + delta - k1;\n                    if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {\n                        // Mirror x2 onto top-left coordinate system.\n                        var x2 = text1Length - v2[k2Offset];\n                        if (x1 >= x2) {\n                            // Overlap detected.\n                            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n                        }\n                    }\n                }\n            }\n            // Walk the reverse path one step.\n            for (var k2 = -d + k2Start; k2 <= d - k2End; k2 += 2) {\n                var k2Offset = vOffset + k2;\n                var x2 = void 0;\n                if (k2 === -d || (k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1])) {\n                    x2 = v2[k2Offset + 1];\n                }\n                else {\n                    x2 = v2[k2Offset - 1] + 1;\n                }\n                var y2 = x2 - k2;\n                while (x2 < text1Length\n                    && y2 < text2Length\n                    && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1)) {\n                    x2++;\n                    y2++;\n                }\n                v2[k2Offset] = x2;\n                if (x2 > text1Length) {\n                    // Ran off the left of the graph.\n                    k2End += 2;\n                }\n                else if (y2 > text2Length) {\n                    // Ran off the top of the graph.\n                    k2Start += 2;\n                }\n                else if (!front) {\n                    var k1Offset = vOffset + delta - k2;\n                    if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {\n                        var x1 = v1[k1Offset];\n                        var y1 = vOffset + x1 - k1Offset;\n                        // Mirror x2 onto top-left coordinate system.\n                        x2 = text1Length - x2;\n                        if (x1 >= x2) {\n                            // Overlap detected.\n                            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n                        }\n                    }\n                }\n            }\n        }\n        // Diff took too long and hit the deadline or\n        // number of diffs equals number of characters, no commonality at all.\n        return [\n            [DiffOperation.DIFF_DELETE, text1],\n            [DiffOperation.DIFF_INSERT, text2]\n        ];\n    };\n    /**\n     * Given the location of the \'middle snake\', split the diff in two parts\n     * and recurse.\n     *\n     * @private\n     * @param {string} text1 Old string to be diffed.\n     * @param {string} text2 New string to be diffed.\n     * @param {number} x Index of split point in text1.\n     * @param {number} y Index of split point in text2.\n     * @param {number} deadline Time at which to bail if not yet complete.\n     * @returns {Diff[]} Array of diff tuples.\n     */\n    DiffMatchPatch.prototype.diff_bisectSplit_ = function (text1, text2, x, y, deadline) {\n        var text1A = text1.substring(0, x);\n        var text2A = text2.substring(0, y);\n        var text1B = text1.substring(x);\n        var text2B = text2.substring(y);\n        // Compute both diffs serially.\n        var diffsA = this.diff_main(text1A, text2A, false, deadline);\n        var diffsB = this.diff_main(text1B, text2B, false, deadline);\n        return diffsA.concat(diffsB);\n    };\n    /**\n     * Split two texts into an array of strings. Reduce the texts to a string of\n     * hashes where each Unicode character represents one line.\n     *\n     * @private\n     * @param {string} text1 First string.\n     * @param {string} text2 Second string.\n     * @returns {{chars1: string, chars2: string, lineArray: string[]}}\n     * An object containing the encoded text1, the encoded text2 and\n     * the array of unique strings.\n     * The zeroth element of the array of unique strings is intentionally blank.\n     */\n    DiffMatchPatch.prototype.diff_linesToChars_ = function (text1, text2) {\n        var lineArray = []; // e.g. lineArray[4] == \'Hello\\n\'\n        var lineHash = {}; // e.g. lineHash[\'Hello\\n\'] == 4\n        // \'\\x00\' is a valid character, but various debuggers don\'t like it.\n        // So we\'ll insert a junk entry to avoid generating a null character.\n        lineArray[0] = "";\n        // Allocate 2/3rds of the space for text1, the rest for text2.\n        var chars1 = this.diff_linesToCharsMunge_(text1, lineArray, lineHash, 40000);\n        var chars2 = this.diff_linesToCharsMunge_(text2, lineArray, lineHash, 65535);\n        return { chars1: chars1, chars2: chars2, lineArray: lineArray };\n    };\n    /**\n     * Split a text into an array of strings. Reduce the texts to a string of\n     * hashes where each Unicode character represents one line.\n     * Modifies linearray and linehash through being a closure.\n     *\n     * @private\n     * @param {string} text String to encode.\n     * @param {string[]} lineArray Array of unique strings.\n     * @param {Record<string, number>} lineHash Line-hash pairs.\n     * @param {number} maxLines\n     * @returns {string} Encoded string.\n     */\n    DiffMatchPatch.prototype.diff_linesToCharsMunge_ = function (text, lineArray, lineHash, maxLines) {\n        var chars = "";\n        // Walk the text, pulling out a substring for each line.\n        // text.split(\'\\n\') would would temporarily double our memory footprint.\n        // Modifying text would create many large strings to garbage collect.\n        var lineStart = 0;\n        var lineEnd = -1;\n        // Keeping our own length variable is faster than looking it up.\n        var lineArrayLength = lineArray.length;\n        while (lineEnd < text.length - 1) {\n            lineEnd = text.indexOf("\\n", lineStart);\n            if (lineEnd === -1) {\n                lineEnd = text.length - 1;\n            }\n            var line = text.substring(lineStart, lineEnd + 1);\n            if (lineHash.hasOwnProperty\n                ? lineHash.hasOwnProperty(line)\n                : (lineHash[line] !== undefined)) {\n                chars += String.fromCharCode(lineHash[line]);\n            }\n            else {\n                if (lineArrayLength === maxLines) {\n                    // Bail out at 65535 because\n                    // String.fromCharCode(65536) == String.fromCharCode(0)\n                    line = text.substring(lineStart);\n                    lineEnd = text.length;\n                }\n                chars += String.fromCharCode(lineArrayLength);\n                lineHash[line] = lineArrayLength;\n                lineArray[lineArrayLength++] = line;\n            }\n            lineStart = lineEnd + 1;\n        }\n        return chars;\n    };\n    /**\n     * Rehydrate the text in a diff from a string of line hashes to real lines of\n     * text.\n     *\n     * @private\n     * @param {Diff[]} diffs Array of diff tuples.\n     * @param {string[]} lineArray Array of unique strings.\n     */\n    DiffMatchPatch.prototype.diff_charsToLines_ = function (diffs, lineArray) {\n        for (var i = 0; i < diffs.length; i++) {\n            var chars = diffs[i][1];\n            var text = [];\n            for (var j = 0; j < chars.length; j++) {\n                text[j] = lineArray[chars.charCodeAt(j)];\n            }\n            diffs[i][1] = text.join("");\n        }\n    };\n    /**\n     * Determine if the suffix of one string is the prefix of another.\n     *\n     * @private\n     * @param {string} text1 First string.\n     * @param {string} text2 Second string.\n     * @returns {number} The number of characters common to the end of the first\n     * string and the start of the second string.\n     */\n    DiffMatchPatch.prototype.diff_commonOverlap_ = function (text1, text2) {\n        // Cache the text lengths to prevent multiple calls.\n        var text1Length = text1.length;\n        var text2Length = text2.length;\n        // Eliminate the null case.\n        if (text1Length === 0 || text2Length === 0) {\n            return 0;\n        }\n        // Truncate the longer string.\n        if (text1Length > text2Length) {\n            text1 = text1.substring(text1Length - text2Length);\n        }\n        else if (text1Length < text2Length) {\n            text2 = text2.substring(0, text1Length);\n        }\n        var textLength = math.min(text1Length, text2Length);\n        // Quick check for the worst case.\n        if (text1 === text2) {\n            return textLength;\n        }\n        // Start by looking for a single character match\n        // and increase length until no match is found.\n        // Performance analysis: https://neil.fraser.name/news/2010/11/04/\n        var best = 0;\n        var length = 1;\n        while (true) {\n            var pattern = text1.substring(textLength - length);\n            var found = text2.indexOf(pattern);\n            if (found === -1) {\n                return best;\n            }\n            length += found;\n            if (found === 0 ||\n                text1.substring(textLength - length) === text2.substring(0, length)) {\n                best = length;\n                length++;\n            }\n        }\n    };\n    /**\n     * Do the two texts share a substring which is at least half the length of the\n     * longer text?\n     * This speedup can produce non-minimal diffs.\n     *\n     * @private\n     * @param {string} text1 First string.\n     * @param {string} text2 Second string.\n     * @returns {(HalfMatchArray | null)} Five element Array, containing the prefix of\n     * text1, the suffix of text1, the prefix of text2, the suffix of\n     * text2 and the common middle. Or null if there was no match.\n     */\n    DiffMatchPatch.prototype.diff_halfMatch_ = function (text1, text2) {\n        if (this.diffTimeout <= 0) {\n            // Don\'t risk returning a non-optimal diff if we have unlimited time.\n            return null;\n        }\n        var longtext = text1.length > text2.length ? text1 : text2;\n        var shorttext = text1.length > text2.length ? text2 : text1;\n        if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n            return null; // Pointless.\n        }\n        // First check if the second quarter is the seed for a half-match.\n        var hm1 = this.diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));\n        // Check again based on the third quarter.\n        var hm2 = this.diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));\n        var hm;\n        if (!hm1 && !hm2) {\n            return null;\n        }\n        else if (!hm2) {\n            hm = hm1;\n        }\n        else if (!hm1) {\n            hm = hm2;\n        }\n        else {\n            // Both matched. Select the longest.\n            hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n        }\n        // A half-match was found, sort out the return data.\n        var text1A;\n        var text1B;\n        var text2A;\n        var text2B;\n        var midCommon = hm[4];\n        if (text1.length > text2.length) {\n            text1A = hm[0];\n            text1B = hm[1];\n            text2A = hm[2];\n            text2B = hm[3];\n        }\n        else {\n            text2A = hm[0];\n            text2B = hm[1];\n            text1A = hm[2];\n            text1B = hm[3];\n        }\n        return [text1A, text1B, text2A, text2B, midCommon];\n    };\n    /**\n     * Does a substring of shorttext exist within longtext such that the substring\n     * is at least half the length of longtext?\n     * Closure, but does not reference any external variables.\n     *\n     * @private\n     * @param {string} longtext Longer string.\n     * @param {string} shorttext Shorter string.\n     * @param {number} i Start index of quarter length substring within longtext.\n     * @returns {(HalfMatchArray | null)} Five element Array, containing the prefix of\n     * longtext, the suffix of longtext, the prefix of shorttext, the suffix\n     * of shorttext and the common middle. Or null if there was no match.\n     */\n    DiffMatchPatch.prototype.diff_halfMatchI_ = function (longtext, shorttext, i) {\n        // Start with a 1/4 length substring at position i as a seed.\n        var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n        var bestCommon = "";\n        var bestLongtextA;\n        var bestLongtextB;\n        var bestShorttextA;\n        var bestShorttextB;\n        // Initial.\n        var j = shorttext.indexOf(seed, 0);\n        while (j !== -1) {\n            var prefixLength = this.diff_commonPrefix(longtext.substring(i), shorttext.substring(j));\n            var suffixLength = this.diff_commonSuffix(longtext.substring(0, i), shorttext.substring(0, j));\n            if (bestCommon.length < suffixLength + prefixLength) {\n                bestCommon = shorttext.substring(j - suffixLength, j)\n                    + shorttext.substring(j, j + prefixLength);\n                bestLongtextA = longtext.substring(0, i - suffixLength);\n                bestLongtextB = longtext.substring(i + prefixLength);\n                bestShorttextA = shorttext.substring(0, j - suffixLength);\n                bestShorttextB = shorttext.substring(j + prefixLength);\n            }\n            // Step.\n            j = shorttext.indexOf(seed, j + 1);\n        }\n        if (bestCommon.length * 2 >= longtext.length) {\n            return [\n                bestLongtextA,\n                bestLongtextB,\n                bestShorttextA,\n                bestShorttextB,\n                bestCommon\n            ];\n        }\n        return null;\n    };\n    /**\n     * Given two strings, compute a score representing whether the internal\n     * boundary falls on logical boundaries.\n     * Scores range from 6 (best) to 0 (worst).\n     * Closure, but does not reference any external variables.\n     *\n     * @private\n     * @param {string} one First string.\n     * @param {string} two Second string.\n     * @returns {number} The score.\n     */\n    DiffMatchPatch.prototype.diff_cleanupSemanticScore_ = function (one, two) {\n        if (!one || !two) {\n            // Edges are the best.\n            return 6;\n        }\n        // Each port of this function behaves slightly differently due to\n        // subtle differences in each language\'s definition of things like\n        // \'whitespace\'. Since this function\'s purpose is largely cosmetic,\n        // the choice has been made to use each language\'s native features\n        // rather than force total conformity.\n        var char1 = one.charAt(one.length - 1);\n        var char2 = two.charAt(0);\n        var nonAlphaNumeric1 = char1.match(NON_ALPHA_NUMERIC_REGEX);\n        var nonAlphaNumeric2 = char2.match(NON_ALPHA_NUMERIC_REGEX);\n        var whitespace1 = nonAlphaNumeric1 && char1.match(WHITESPACE_REGEX);\n        var whitespace2 = nonAlphaNumeric2 && char2.match(WHITESPACE_REGEX);\n        var lineBreak1 = whitespace1 && char1.match(LINEBREAK_REGEX);\n        var lineBreak2 = whitespace2 && char2.match(LINEBREAK_REGEX);\n        var blankLine1 = lineBreak1 && one.match(BLANKLINE_END_REGEX);\n        var blankLine2 = lineBreak2 && two.match(BLANKLINE_START_REGEX);\n        if (blankLine1 || blankLine2) {\n            // Five points for blank lines.\n            return 5;\n        }\n        else if (lineBreak1 || lineBreak2) {\n            // Four points for line breaks.\n            return 4;\n        }\n        else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n            // Three points for end of sentences.\n            return 3;\n        }\n        else if (whitespace1 || whitespace2) {\n            // Two points for whitespace.\n            return 2;\n        }\n        else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n            // One point for non-alphanumeric.\n            return 1;\n        }\n        return 0;\n    };\n    //#endregion DIFF FUNCTIONS (private)\n    //#region MATCH FUNCTIONS (private)\n    /**\n     * Locate the best instance of \'pattern\' in \'text\' near \'loc\' using the\n     * Bitap algorithm.\n     *\n     * @private\n     * @param {string} text The text to search.\n     * @param {string} pattern The pattern to search for.\n     * @param {number} loc The location to search around.\n     * @returns {number} Best match index or -1.\n     */\n    DiffMatchPatch.prototype.match_bitap_ = function (text, pattern, loc) {\n        if (pattern.length > this.matchMaxBits) {\n            throw new Error("Pattern too long for this browser");\n        }\n        // Initialize the alphabet.\n        var s = this.match_alphabet_(pattern);\n        // Highest score beyond which we give up.\n        var scoreThreshold = this.matchThreshold;\n        // Is there a nearby exact match? (speedup)\n        var bestLoc = text.indexOf(pattern, loc);\n        if (bestLoc !== -1) {\n            scoreThreshold = math.min(this.match_bitapScore_(0, bestLoc, pattern, loc), scoreThreshold);\n            // What about in the other direction? (speedup)\n            bestLoc = text.lastIndexOf(pattern, loc + pattern.length);\n            if (bestLoc !== -1) {\n                scoreThreshold = math.min(this.match_bitapScore_(0, bestLoc, pattern, loc), scoreThreshold);\n            }\n        }\n        // Initialize the bit arrays.\n        var matchmask = 1 << (pattern.length - 1);\n        bestLoc = -1;\n        var binMin;\n        var binMid;\n        var binMax = pattern.length + text.length;\n        var lastRD;\n        for (var d = 0; d < pattern.length; d++) {\n            // Scan for the best match; each iteration allows for one more error.\n            // Run a binary search to determine how far from \'loc\' we can stray at this\n            // error level.\n            binMin = 0;\n            binMid = binMax;\n            while (binMin < binMid) {\n                if (this.match_bitapScore_(d, loc + binMid, pattern, loc) <= scoreThreshold) {\n                    binMin = binMid;\n                }\n                else {\n                    binMax = binMid;\n                }\n                binMid = Math.floor((binMax - binMin) / 2 + binMin);\n            }\n            // Use the result from this iteration as the maximum for the next.\n            binMax = binMid;\n            var start = math.max(1, loc - binMid + 1);\n            var finish = math.min(loc + binMid, text.length) + pattern.length;\n            var rd = Array(finish + 2);\n            rd[finish + 1] = (1 << d) - 1;\n            for (var j = finish; j >= start; j--) {\n                // The alphabet (s) is a sparse hash, so the following line generates\n                // warnings.\n                var charMatch = s[text.charAt(j - 1)];\n                if (d === 0) {\n                    // First pass: exact match.\n                    rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;\n                }\n                else {\n                    // Subsequent passes: fuzzy match.\n                    rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |\n                        (((lastRD[j + 1] | lastRD[j]) << 1) | 1) |\n                        lastRD[j + 1];\n                }\n                if (rd[j] & matchmask) {\n                    var score = this.match_bitapScore_(d, j - 1, pattern, loc);\n                    // This match will almost certainly be better than any existing match.\n                    // But check anyway.\n                    if (score <= scoreThreshold) {\n                        // Told you so.\n                        scoreThreshold = score;\n                        bestLoc = j - 1;\n                        if (bestLoc > loc) {\n                            // When passing loc, don\'t exceed our current distance from loc.\n                            start = math.max(1, 2 * loc - bestLoc);\n                        }\n                        else {\n                            // Already passed loc, downhill from here on in.\n                            break;\n                        }\n                    }\n                }\n            }\n            // No hope for a (better) match at greater error levels.\n            if (this.match_bitapScore_(d + 1, loc, pattern, loc) > scoreThreshold) {\n                break;\n            }\n            lastRD = rd;\n        }\n        return bestLoc;\n    };\n    /**\n     * Compute and return the score for a match with e errors and x location.\n     * Accesses loc and pattern through being a closure.\n     *\n     * @private\n     * @param {number} e Number of errors in match.\n     * @param {number} x Location of match.\n     * @param {string} pattern The pattern to search for.\n     * @param {number} loc The location to search around.\n     * @returns {number} Overall score for match (0.0 = good, 1.0 = bad).\n     */\n    DiffMatchPatch.prototype.match_bitapScore_ = function (e, x, pattern, loc) {\n        var accuracy = e / pattern.length;\n        var proximity = Math.abs(loc - x);\n        if (!this.matchDistance) {\n            // Dodge divide by zero error.\n            return proximity ? 1.0 : accuracy;\n        }\n        return accuracy + (proximity / this.matchDistance);\n    };\n    /**\n     * Initialize the alphabet for the Bitap algorithm.\n     *\n     * @private\n     * @param {string} pattern The text to encode.\n     * @returns {Record<string, number>} Hash of character locations.\n     */\n    DiffMatchPatch.prototype.match_alphabet_ = function (pattern) {\n        var s = {};\n        for (var i = 0; i < pattern.length; i++) {\n            s[pattern.charAt(i)] = 0;\n        }\n        for (var i = 0; i < pattern.length; i++) {\n            s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);\n        }\n        return s;\n    };\n    //#endregion MATCH FUNCTIONS (private)\n    //#region PATCH FUNCTIONS (private)\n    /**\n     * Increase the context until it is unique,\n     * but don\'t let the pattern expand beyond Match_MaxBits.\n     *\n     * @private\n     * @param {PatchObject} patch The patch to grow.\n     * @param {string} text Source text.\n     */\n    DiffMatchPatch.prototype.patch_addContext_ = function (patch, text) {\n        if (text.length === 0) {\n            return;\n        }\n        if (patch.start2 == null) {\n            throw Error("patch not initialized");\n        }\n        var pattern = text.substring(patch.start2, patch.start2 + patch.length1);\n        var padding = 0;\n        // Look for the first and last matches of pattern in text. If two different\n        // matches are found, increase the pattern length.\n        while (text.indexOf(pattern) !== text.lastIndexOf(pattern) &&\n            pattern.length < (this.matchMaxBits - this.patchMargin - this.patchMargin)) {\n            padding += this.patchMargin;\n            pattern = text.substring(patch.start2 - padding, patch.start2 + patch.length1 + padding);\n        }\n        // Add one chunk for good luck.\n        padding += this.patchMargin;\n        // Add the prefix.\n        var prefix = text.substring(patch.start2 - padding, patch.start2);\n        if (prefix) {\n            patch.diffs.unshift([DiffOperation.DIFF_EQUAL, prefix]);\n        }\n        // Add the suffix.\n        var suffix = text.substring(patch.start2 + patch.length1, patch.start2 + patch.length1 + padding);\n        if (suffix) {\n            patch.diffs.push([DiffOperation.DIFF_EQUAL, suffix]);\n        }\n        // Roll back the start points.\n        patch.start1 -= prefix.length;\n        patch.start2 -= prefix.length;\n        // Extend the lengths.\n        patch.length1 += prefix.length + suffix.length;\n        patch.length2 += prefix.length + suffix.length;\n    };\n    return DiffMatchPatch;\n}());\n\n\n// CONCATENATED MODULE: ./node_modules/diff-match-patch-typescript/dist/es/core/index.js\n\n\n\n// CONCATENATED MODULE: ./node_modules/diff-match-patch-typescript/dist/es/index.js\n/* concated harmony reexport DiffMatchPatch */__webpack_require__.d(__webpack_exports__, "DiffMatchPatch", function() { return DiffMatchPatch_DiffMatchPatch; });\n/* concated harmony reexport PatchObject */__webpack_require__.d(__webpack_exports__, "PatchObject", function() { return PatchObject_PatchObject; });\n/* concated harmony reexport DiffOperation */__webpack_require__.d(__webpack_exports__, "DiffOperation", function() { return DiffOperation; });\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODIwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RpZmYtbWF0Y2gtcGF0Y2gtdHlwZXNjcmlwdC9kaXN0L2VzL2NvbnN0YW50cy9pbmRleC5qcz9hMDAwIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWZmLW1hdGNoLXBhdGNoLXR5cGVzY3JpcHQvZGlzdC9lcy90eXBlcy9EaWZmT3BlcmF0aW9uLmpzPzdiOGMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RpZmYtbWF0Y2gtcGF0Y2gtdHlwZXNjcmlwdC9kaXN0L2VzL3R5cGVzL2luZGV4LmpzP2RiYzUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RpZmYtbWF0Y2gtcGF0Y2gtdHlwZXNjcmlwdC9kaXN0L2VzL3V0aWxzL21hdGguanM/YjY2YiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlmZi1tYXRjaC1wYXRjaC10eXBlc2NyaXB0L2Rpc3QvZXMvdXRpbHMvaW5kZXguanM/NzQ3NCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlmZi1tYXRjaC1wYXRjaC10eXBlc2NyaXB0L2Rpc3QvZXMvY29yZS9QYXRjaE9iamVjdC5qcz82NWFmIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWZmLW1hdGNoLXBhdGNoLXR5cGVzY3JpcHQvZGlzdC9lcy9jb3JlL0RpZmZNYXRjaFBhdGNoLmpzPzliZjgiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RpZmYtbWF0Y2gtcGF0Y2gtdHlwZXNjcmlwdC9kaXN0L2VzL2NvcmUvaW5kZXguanM/NjZhZiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlmZi1tYXRjaC1wYXRjaC10eXBlc2NyaXB0L2Rpc3QvZXMvaW5kZXguanM/ZGYzMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIERlZmluZSBzb21lIHJlZ2V4IHBhdHRlcm5zIGZvciBtYXRjaGluZyBib3VuZGFyaWVzLlxuICpcbiAqIFBvcnRlZCBieSBbeGlhb2NoYW8ua0BnbWFpbC5jb21dKGh0dHBzOi8vZ2l0aHViLmNvbS9ub25vcm9hem9ybylcbiAqL1xuZXhwb3J0IHZhciBOT05fQUxQSEFfTlVNRVJJQ19SRUdFWCA9IC9bXmEtekEtWjAtOV0vO1xuZXhwb3J0IHZhciBXSElURVNQQUNFX1JFR0VYID0gL1xccy87XG5leHBvcnQgdmFyIExJTkVCUkVBS19SRUdFWCA9IC9bXFxyXFxuXS87XG5leHBvcnQgdmFyIEJMQU5LTElORV9FTkRfUkVHRVggPSAvXFxuXFxyP1xcbiQvO1xuZXhwb3J0IHZhciBCTEFOS0xJTkVfU1RBUlRfUkVHRVggPSAvXlxccj9cXG5cXHI/XFxuLztcbiIsIi8qKlxuICogUmVwcmVzZW50cyB0aGUgb3BlcmF0aW9ucyBvZiBhIGBEaWZmYC5cbiAqXG4gKiBUaGUgZGF0YSBzdHJ1Y3R1cmUgcmVwcmVzZW50aW5nIGEgYERpZmZgIGlzIGFuIGFycmF5IG9mIHR1cGxlczpcbiAqIFtbRElGRl9ERUxFVEUsICdIZWxsbyddLCBbRElGRl9JTlNFUlQsICdHb29kYnllJ10sIFtESUZGX0VRVUFMLCAnIHdvcmxkLiddXVxuICogd2hpY2ggbWVhbnM6IGRlbGV0ZSAnSGVsbG8nLCBhZGQgJ0dvb2RieWUnIGFuZCBrZWVwICcgd29ybGQuJ1xuICpcbiAqIFBvcnRlZCBieSBbeGlhb2NoYW8ua0BnbWFpbC5jb21dKGh0dHBzOi8vZ2l0aHViLmNvbS9ub25vcm9hem9ybylcbiAqL1xuZXhwb3J0IHZhciBEaWZmT3BlcmF0aW9uO1xuKGZ1bmN0aW9uIChEaWZmT3BlcmF0aW9uKSB7XG4gICAgRGlmZk9wZXJhdGlvbltEaWZmT3BlcmF0aW9uW1wiRElGRl9ERUxFVEVcIl0gPSAtMV0gPSBcIkRJRkZfREVMRVRFXCI7XG4gICAgRGlmZk9wZXJhdGlvbltEaWZmT3BlcmF0aW9uW1wiRElGRl9JTlNFUlRcIl0gPSAxXSA9IFwiRElGRl9JTlNFUlRcIjtcbiAgICBEaWZmT3BlcmF0aW9uW0RpZmZPcGVyYXRpb25bXCJESUZGX0VRVUFMXCJdID0gMF0gPSBcIkRJRkZfRVFVQUxcIjtcbn0pKERpZmZPcGVyYXRpb24gfHwgKERpZmZPcGVyYXRpb24gPSB7fSkpO1xuIiwiZXhwb3J0ICogZnJvbSBcIi4vRGlmZk9wZXJhdGlvblwiO1xuIiwiLyoqXG4gKiBSZXR1cm5zIHRoZSBzbWFsbGVyIG51bWJlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1pbihhLCBiKSB7XG4gICAgcmV0dXJuIGEgPCBiID8gYSA6IGI7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGxhcmdlciBudW1iZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXgoYSwgYikge1xuICAgIHJldHVybiBhID4gYiA/IGEgOiBiO1xufVxuIiwiaW1wb3J0ICogYXMgbSBmcm9tIFwiLi9tYXRoXCI7XG5leHBvcnQgdmFyIG1hdGggPSBtO1xuIiwiaW1wb3J0IHsgRGlmZk9wZXJhdGlvbiB9IGZyb20gXCIuLi90eXBlc1wiO1xuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgb25lIHBhdGNoIG9wZXJhdGlvbi5cbiAqXG4gKiBQb3J0ZWQgYnkgW3hpYW9jaGFvLmtAZ21haWwuY29tXShodHRwczovL2dpdGh1Yi5jb20vbm9ub3JvYXpvcm8pXG4gKi9cbnZhciBQYXRjaE9iamVjdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXRjaE9iamVjdCgpIHtcbiAgICAgICAgdGhpcy5kaWZmcyA9IFtdO1xuICAgICAgICB0aGlzLnN0YXJ0MSA9IDA7XG4gICAgICAgIHRoaXMuc3RhcnQyID0gMDtcbiAgICAgICAgdGhpcy5sZW5ndGgxID0gMDtcbiAgICAgICAgdGhpcy5sZW5ndGgyID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW11bGF0ZSBHTlUgZGlmZiBmb3JtYXQuXG4gICAgICogSGVhZGVyOiBAQCAtMzgyLDggKzQ4MSw5IEBAXG4gICAgICogSW5kaWNlcyBhcmUgcHJpbnRlZCBhcyAxLWJhc2VkLCBub3QgMC1iYXNlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBHTlUgZGlmZiBzdHJpbmcuXG4gICAgICovXG4gICAgUGF0Y2hPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29vcmRzMTtcbiAgICAgICAgdmFyIGNvb3JkczI7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICAgIGNvb3JkczEgPSB0aGlzLnN0YXJ0MSArIFwiLDBcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICAgIGNvb3JkczEgPSB0aGlzLnN0YXJ0MSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb29yZHMxID0gKHRoaXMuc3RhcnQxICsgMSkgKyBcIixcIiArIHRoaXMubGVuZ3RoMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICBjb29yZHMyID0gdGhpcy5zdGFydDIgKyBcIiwwXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5sZW5ndGgyID09PSAxKSB7XG4gICAgICAgICAgICBjb29yZHMyID0gdGhpcy5zdGFydDIgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29vcmRzMiA9ICh0aGlzLnN0YXJ0MiArIDEpICsgXCIsXCIgKyB0aGlzLmxlbmd0aDI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRleHQgPSBbXCJAQCAtXCIgKyBjb29yZHMxICsgXCIgK1wiICsgY29vcmRzMiArIFwiIEBAXFxuXCJdO1xuICAgICAgICB2YXIgb3A7XG4gICAgICAgIC8vIEVzY2FwZSB0aGUgYm9keSBvZiB0aGUgcGF0Y2ggd2l0aCAleHggbm90YXRpb24uXG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdGhpcy5kaWZmcy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRpZmZzW3hdWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBEaWZmT3BlcmF0aW9uLkRJRkZfSU5TRVJUOlxuICAgICAgICAgICAgICAgICAgICBvcCA9IFwiK1wiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIERpZmZPcGVyYXRpb24uRElGRl9ERUxFVEU6XG4gICAgICAgICAgICAgICAgICAgIG9wID0gXCItXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRGlmZk9wZXJhdGlvbi5ESUZGX0VRVUFMOlxuICAgICAgICAgICAgICAgICAgICBvcCA9IFwiIFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHRbeCArIDFdID0gb3AgKyBlbmNvZGVVUkkodGhpcy5kaWZmc1t4XVsxXSkgKyBcIlxcblwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0LmpvaW4oXCJcIikucmVwbGFjZSgvJTIwL2csIFwiIFwiKTtcbiAgICB9O1xuICAgIHJldHVybiBQYXRjaE9iamVjdDtcbn0oKSk7XG5leHBvcnQgeyBQYXRjaE9iamVjdCB9O1xuIiwiaW1wb3J0IHsgQkxBTktMSU5FX0VORF9SRUdFWCwgQkxBTktMSU5FX1NUQVJUX1JFR0VYLCBMSU5FQlJFQUtfUkVHRVgsIE5PTl9BTFBIQV9OVU1FUklDX1JFR0VYLCBXSElURVNQQUNFX1JFR0VYIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgRGlmZk9wZXJhdGlvbiB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHsgbWF0aCB9IGZyb20gXCIuLi91dGlsc1wiO1xuaW1wb3J0IHsgUGF0Y2hPYmplY3QgfSBmcm9tIFwiLi9QYXRjaE9iamVjdFwiO1xuLyoqXG4gKiBEaWZmIE1hdGNoIGFuZCBQYXRjaFxuICogQ29weXJpZ2h0IDIwMTggVGhlIGRpZmYtbWF0Y2gtcGF0Y2ggQXV0aG9ycy5cbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2RpZmYtbWF0Y2gtcGF0Y2hcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENvbXB1dGVzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIHRleHRzIHRvIGNyZWF0ZSBhIHBhdGNoLlxuICogQXBwbGllcyB0aGUgcGF0Y2ggb250byBhbm90aGVyIHRleHQsIGFsbG93aW5nIGZvciBlcnJvcnMuXG4gKiBAYXV0aG9yIGZyYXNlckBnb29nbGUuY29tIChOZWlsIEZyYXNlcilcbiAqXG4gKiBQb3J0ZWQgYnkgW3hpYW9jaGFvLmtAZ21haWwuY29tXShodHRwczovL2dpdGh1Yi5jb20vbm9ub3JvYXpvcm8pXG4gKi9cbi8qKlxuICogQ2xhc3MgY29udGFpbmluZyB0aGUgZGlmZiwgbWF0Y2ggYW5kIHBhdGNoIG1ldGhvZHMuXG4gKi9cbnZhciBEaWZmTWF0Y2hQYXRjaCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEaWZmTWF0Y2hQYXRjaCgpIHtcbiAgICAgICAgLy8gRGVmYXVsdHMuXG4gICAgICAgIC8vIFJlZGVmaW5lIHRoZXNlIGluIHlvdXIgcHJvZ3JhbSB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOdW1iZXIgb2Ygc2Vjb25kcyB0byBtYXAgYSBkaWZmIGJlZm9yZSBnaXZpbmcgdXAgKDAgZm9yIGluZmluaXR5KS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlmZlRpbWVvdXQgPSAxLjA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb3N0IG9mIGFuIGVtcHR5IGVkaXQgb3BlcmF0aW9uIGluIHRlcm1zIG9mIGVkaXQgY2hhcmFjdGVycy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlmZkVkaXRDb3N0ID0gNDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0IHdoYXQgcG9pbnQgaXMgbm8gbWF0Y2ggZGVjbGFyZWQgKDAuMCA9IHBlcmZlY3Rpb24sIDEuMCA9IHZlcnkgbG9vc2UpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXRjaFRocmVzaG9sZCA9IDAuNTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvdyBmYXIgdG8gc2VhcmNoIGZvciBhIG1hdGNoICgwID0gZXhhY3QgbG9jYXRpb24sIDEwMDArID0gYnJvYWQgbWF0Y2gpLlxuICAgICAgICAgKiBBIG1hdGNoIHRoaXMgbWFueSBjaGFyYWN0ZXJzIGF3YXkgZnJvbSB0aGUgZXhwZWN0ZWQgbG9jYXRpb24gd2lsbCBhZGRcbiAgICAgICAgICogMS4wIHRvIHRoZSBzY29yZSAoMC4wIGlzIGEgcGVyZmVjdCBtYXRjaCkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hdGNoRGlzdGFuY2UgPSAxMDAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBkZWxldGluZyBhIGxhcmdlIGJsb2NrIG9mIHRleHQgKG92ZXIgfjY0IGNoYXJhY3RlcnMpLCBob3cgY2xvc2UgZG9cbiAgICAgICAgICogdGhlIGNvbnRlbnRzIGhhdmUgdG8gYmUgdG8gbWF0Y2ggdGhlIGV4cGVjdGVkIGNvbnRlbnRzLiAoMC4wID0gcGVyZmVjdGlvbixcbiAgICAgICAgICogMS4wID0gdmVyeSBsb29zZSkuIE5vdGUgdGhhdCBNYXRjaF9UaHJlc2hvbGQgY29udHJvbHMgaG93IGNsb3NlbHkgdGhlXG4gICAgICAgICAqIGVuZCBwb2ludHMgb2YgYSBkZWxldGUgbmVlZCB0byBtYXRjaC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGF0Y2hEZWxldGVUaHJlc2hvbGQgPSAwLjU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaHVuayBzaXplIGZvciBjb250ZXh0IGxlbmd0aC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGF0Y2hNYXJnaW4gPSA0O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBiaXRzIGluIGFuIGludC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWF0Y2hNYXhCaXRzID0gMzI7XG4gICAgICAgIC8vI2VuZHJlZ2lvbiBQQVRDSCBGVU5DVElPTlMgKHByaXZhdGUpXG4gICAgfVxuICAgIC8vI3JlZ2lvbiBESUZGIEZVTkNUSU9OUyAocHVibGljKVxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gdHdvIHRleHRzLiBTaW1wbGlmaWVzIHRoZSBwcm9ibGVtIGJ5IHN0cmlwcGluZ1xuICAgICAqIGFueSBjb21tb24gcHJlZml4IG9yIHN1ZmZpeCBvZmYgdGhlIHRleHRzIGJlZm9yZSBkaWZmaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIE9sZCBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBOZXcgc3RyaW5nIHRvIGJlIGRpZmZlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRDaGVja2xpbmVzXSBPcHRpb25hbCBzcGVlZHVwIGZsYWcuIElmIHByZXNlbnQgYW5kIGZhbHNlLFxuICAgICAqIHRoZW4gZG9uJ3QgcnVuIGEgbGluZS1sZXZlbCBkaWZmIGZpcnN0IHRvIGlkZW50aWZ5IHRoZSBjaGFuZ2VkIGFyZWFzLlxuICAgICAqIERlZmF1bHRzIHRvIHRydWUsIHdoaWNoIGRvZXMgYSBmYXN0ZXIsIHNsaWdodGx5IGxlc3Mgb3B0aW1hbCBkaWZmLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0RGVhZGxpbmVdIE9wdGlvbmFsIHRpbWUgd2hlbiB0aGUgZGlmZiBzaG91bGQgYmUgY29tcGxldGVcbiAgICAgKiBieS4gVXNlZCBpbnRlcm5hbGx5IGZvciByZWN1cnNpdmUgY2FsbHMuIFVzZXJzIHNob3VsZCBzZXQgRGlmZlRpbWVvdXRcbiAgICAgKiBpbnN0ZWFkLlxuICAgICAqIEByZXR1cm5zIHtEaWZmW119IEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICAgICAqL1xuICAgIERpZmZNYXRjaFBhdGNoLnByb3RvdHlwZS5kaWZmX21haW4gPSBmdW5jdGlvbiAodGV4dDEsIHRleHQyLCBvcHRDaGVja2xpbmVzLCBvcHREZWFkbGluZSkge1xuICAgICAgICAvLyBTZXQgYSBkZWFkbGluZSBieSB3aGljaCB0aW1lIHRoZSBkaWZmIG11c3QgYmUgY29tcGxldGUuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0RGVhZGxpbmUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpZmZUaW1lb3V0IDw9IDApIHtcbiAgICAgICAgICAgICAgICBvcHREZWFkbGluZSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHREZWFkbGluZSA9IERhdGUubm93KCkgKyB0aGlzLmRpZmZUaW1lb3V0ICogMTAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVhZGxpbmUgPSBvcHREZWFkbGluZTtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIG51bGwgaW5wdXRzLlxuICAgICAgICBpZiAodGV4dDEgPT0gbnVsbCB8fCB0ZXh0MiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOdWxsIGlucHV0LiAoZGlmZl9tYWluKVwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBmb3IgZXF1YWxpdHkgKHNwZWVkdXApLlxuICAgICAgICBpZiAodGV4dDEgPT09IHRleHQyKSB7XG4gICAgICAgICAgICBpZiAodGV4dDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1tEaWZmT3BlcmF0aW9uLkRJRkZfRVFVQUwsIHRleHQxXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRDaGVja2xpbmVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBvcHRDaGVja2xpbmVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hlY2tsaW5lcyA9IG9wdENoZWNrbGluZXM7XG4gICAgICAgIC8vIFRyaW0gb2ZmIGNvbW1vbiBwcmVmaXggKHNwZWVkdXApLlxuICAgICAgICB2YXIgY29tbW9ubGVuZ3RoID0gdGhpcy5kaWZmX2NvbW1vblByZWZpeCh0ZXh0MSwgdGV4dDIpO1xuICAgICAgICB2YXIgY29tbW9ucHJlZml4ID0gdGV4dDEuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCk7XG4gICAgICAgIHRleHQxID0gdGV4dDEuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XG4gICAgICAgIHRleHQyID0gdGV4dDIuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XG4gICAgICAgIC8vIFRyaW0gb2ZmIGNvbW1vbiBzdWZmaXggKHNwZWVkdXApLlxuICAgICAgICBjb21tb25sZW5ndGggPSB0aGlzLmRpZmZfY29tbW9uU3VmZml4KHRleHQxLCB0ZXh0Mik7XG4gICAgICAgIHZhciBjb21tb25zdWZmaXggPSB0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcoMCwgdGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgdGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgdGV4dDIubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZGlmZiBvbiB0aGUgbWlkZGxlIGJsb2NrLlxuICAgICAgICB2YXIgZGlmZnMgPSB0aGlzLmRpZmZfY29tcHV0ZV8odGV4dDEsIHRleHQyLCBjaGVja2xpbmVzLCBkZWFkbGluZSk7XG4gICAgICAgIC8vIFJlc3RvcmUgdGhlIHByZWZpeCBhbmQgc3VmZml4LlxuICAgICAgICBpZiAoY29tbW9ucHJlZml4KSB7XG4gICAgICAgICAgICBkaWZmcy51bnNoaWZ0KFtEaWZmT3BlcmF0aW9uLkRJRkZfRVFVQUwsIGNvbW1vbnByZWZpeF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21tb25zdWZmaXgpIHtcbiAgICAgICAgICAgIGRpZmZzLnB1c2goW0RpZmZPcGVyYXRpb24uRElGRl9FUVVBTCwgY29tbW9uc3VmZml4XSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaWZmX2NsZWFudXBNZXJnZShkaWZmcyk7XG4gICAgICAgIHJldHVybiBkaWZmcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgY29tbW9uIHByZWZpeCBvZiB0d28gc3RyaW5ncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBGaXJzdCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIFNlY29uZCBzdHJpbmcuXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvbW1vbiB0byB0aGUgc3RhcnQgb2YgZWFjaCBzdHJpbmcuXG4gICAgICovXG4gICAgRGlmZk1hdGNoUGF0Y2gucHJvdG90eXBlLmRpZmZfY29tbW9uUHJlZml4ID0gZnVuY3Rpb24gKHRleHQxLCB0ZXh0Mikge1xuICAgICAgICAvLyBRdWljayBjaGVjayBmb3IgY29tbW9uIG51bGwgY2FzZXMuXG4gICAgICAgIGlmICghdGV4dDEgfHxcbiAgICAgICAgICAgICF0ZXh0MiB8fFxuICAgICAgICAgICAgdGV4dDEuY2hhckF0KDApICE9PSB0ZXh0Mi5jaGFyQXQoMCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJpbmFyeSBzZWFyY2guXG4gICAgICAgIC8vIFBlcmZvcm1hbmNlIGFuYWx5c2lzOiBodHRwczovL25laWwuZnJhc2VyLm5hbWUvbmV3cy8yMDA3LzEwLzA5L1xuICAgICAgICB2YXIgcG9pbnRlcm1pbiA9IDA7XG4gICAgICAgIHZhciBwb2ludGVybWF4ID0gbWF0aC5taW4odGV4dDEubGVuZ3RoLCB0ZXh0Mi5sZW5ndGgpO1xuICAgICAgICB2YXIgcG9pbnRlcm1pZCA9IHBvaW50ZXJtYXg7XG4gICAgICAgIHZhciBwb2ludGVyc3RhcnQgPSAwO1xuICAgICAgICB3aGlsZSAocG9pbnRlcm1pbiA8IHBvaW50ZXJtaWQpIHtcbiAgICAgICAgICAgIGlmICh0ZXh0MS5zdWJzdHJpbmcocG9pbnRlcnN0YXJ0LCBwb2ludGVybWlkKSA9PT1cbiAgICAgICAgICAgICAgICB0ZXh0Mi5zdWJzdHJpbmcocG9pbnRlcnN0YXJ0LCBwb2ludGVybWlkKSkge1xuICAgICAgICAgICAgICAgIHBvaW50ZXJtaW4gPSBwb2ludGVybWlkO1xuICAgICAgICAgICAgICAgIHBvaW50ZXJzdGFydCA9IHBvaW50ZXJtaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb2ludGVybWF4ID0gcG9pbnRlcm1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50ZXJtaWQgPSBNYXRoLmZsb29yKChwb2ludGVybWF4IC0gcG9pbnRlcm1pbikgLyAyICsgcG9pbnRlcm1pbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50ZXJtaWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIGNvbW1vbiBzdWZmaXggb2YgdHdvIHN0cmluZ3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBTZWNvbmQgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb21tb24gdG8gdGhlIGVuZCBvZiBlYWNoIHN0cmluZy5cbiAgICAgKi9cbiAgICBEaWZmTWF0Y2hQYXRjaC5wcm90b3R5cGUuZGlmZl9jb21tb25TdWZmaXggPSBmdW5jdGlvbiAodGV4dDEsIHRleHQyKSB7XG4gICAgICAgIC8vIFF1aWNrIGNoZWNrIGZvciBjb21tb24gbnVsbCBjYXNlcy5cbiAgICAgICAgaWYgKCF0ZXh0MSB8fFxuICAgICAgICAgICAgIXRleHQyIHx8XG4gICAgICAgICAgICB0ZXh0MS5jaGFyQXQodGV4dDEubGVuZ3RoIC0gMSkgIT09IHRleHQyLmNoYXJBdCh0ZXh0Mi5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmluYXJ5IHNlYXJjaC5cbiAgICAgICAgLy8gUGVyZm9ybWFuY2UgYW5hbHlzaXM6IGh0dHBzOi8vbmVpbC5mcmFzZXIubmFtZS9uZXdzLzIwMDcvMTAvMDkvXG4gICAgICAgIHZhciBwb2ludGVybWluID0gMDtcbiAgICAgICAgdmFyIHBvaW50ZXJtYXggPSBtYXRoLm1pbih0ZXh0MS5sZW5ndGgsIHRleHQyLmxlbmd0aCk7XG4gICAgICAgIHZhciBwb2ludGVybWlkID0gcG9pbnRlcm1heDtcbiAgICAgICAgdmFyIHBvaW50ZXJlbmQgPSAwO1xuICAgICAgICB3aGlsZSAocG9pbnRlcm1pbiA8IHBvaW50ZXJtaWQpIHtcbiAgICAgICAgICAgIGlmICh0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gcG9pbnRlcm1pZCwgdGV4dDEubGVuZ3RoIC0gcG9pbnRlcmVuZCkgPT09XG4gICAgICAgICAgICAgICAgdGV4dDIuc3Vic3RyaW5nKHRleHQyLmxlbmd0aCAtIHBvaW50ZXJtaWQsIHRleHQyLmxlbmd0aCAtIHBvaW50ZXJlbmQpKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRlcm1pbiA9IHBvaW50ZXJtaWQ7XG4gICAgICAgICAgICAgICAgcG9pbnRlcmVuZCA9IHBvaW50ZXJtaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb2ludGVybWF4ID0gcG9pbnRlcm1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50ZXJtaWQgPSBNYXRoLmZsb29yKChwb2ludGVybWF4IC0gcG9pbnRlcm1pbikgLyAyICsgcG9pbnRlcm1pbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50ZXJtaWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWR1Y2UgdGhlIG51bWJlciBvZiBlZGl0cyBieSBlbGltaW5hdGluZyBzZW1hbnRpY2FsbHkgdHJpdmlhbCBlcXVhbGl0aWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtEaWZmW119IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICAgICAqL1xuICAgIERpZmZNYXRjaFBhdGNoLnByb3RvdHlwZS5kaWZmX2NsZWFudXBTZW1hbnRpYyA9IGZ1bmN0aW9uIChkaWZmcykge1xuICAgICAgICB2YXIgY2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICB2YXIgZXF1YWxpdGllcyA9IFtdOyAvLyBTdGFjayBvZiBpbmRpY2VzIHdoZXJlIGVxdWFsaXRpZXMgYXJlIGZvdW5kLlxuICAgICAgICB2YXIgZXF1YWxpdGllc0xlbmd0aCA9IDA7IC8vIEtlZXBpbmcgb3VyIG93biBsZW5ndGggdmFyIGlzIGZhc3RlciBpbiBKUy5cbiAgICAgICAgdmFyIGxhc3RFcXVhbGl0eSA9IG51bGw7XG4gICAgICAgIC8vIEFsd2F5cyBlcXVhbCB0byBkaWZmc1tlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXV1bMV1cbiAgICAgICAgdmFyIHBvaW50ZXIgPSAwOyAvLyBJbmRleCBvZiBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IGNoYW5nZWQgcHJpb3IgdG8gdGhlIGVxdWFsaXR5LlxuICAgICAgICB2YXIgbGVuZ3RoSW5zZXJ0aW9uczEgPSAwO1xuICAgICAgICB2YXIgbGVuZ3RoRGVsZXRpb25zMSA9IDA7XG4gICAgICAgIC8vIE51bWJlciBvZiBjaGFyYWN0ZXJzIHRoYXQgY2hhbmdlZCBhZnRlciB0aGUgZXF1YWxpdHkuXG4gICAgICAgIHZhciBsZW5ndGhJbnNlcnRpb25zMiA9IDA7XG4gICAgICAgIHZhciBsZW5ndGhEZWxldGlvbnMyID0gMDtcbiAgICAgICAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChkaWZmc1twb2ludGVyXVswXSA9PT0gRGlmZk9wZXJhdGlvbi5ESUZGX0VRVUFMKSB7XG4gICAgICAgICAgICAgICAgLy8gRXF1YWxpdHkgZm91bmQuXG4gICAgICAgICAgICAgICAgZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoKytdID0gcG9pbnRlcjtcbiAgICAgICAgICAgICAgICBsZW5ndGhJbnNlcnRpb25zMSA9IGxlbmd0aEluc2VydGlvbnMyO1xuICAgICAgICAgICAgICAgIGxlbmd0aERlbGV0aW9uczEgPSBsZW5ndGhEZWxldGlvbnMyO1xuICAgICAgICAgICAgICAgIGxlbmd0aEluc2VydGlvbnMyID0gMDtcbiAgICAgICAgICAgICAgICBsZW5ndGhEZWxldGlvbnMyID0gMDtcbiAgICAgICAgICAgICAgICBsYXN0RXF1YWxpdHkgPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFuIGluc2VydGlvbiBvciBkZWxldGlvbi5cbiAgICAgICAgICAgICAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMF0gPT09IERpZmZPcGVyYXRpb24uRElGRl9JTlNFUlQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoSW5zZXJ0aW9uczIgKz0gZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoRGVsZXRpb25zMiArPSBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEVsaW1pbmF0ZSBhbiBlcXVhbGl0eSB0aGF0IGlzIHNtYWxsZXIgb3IgZXF1YWwgdG8gdGhlIGVkaXRzIG9uIGJvdGhcbiAgICAgICAgICAgICAgICAvLyBzaWRlcyBvZiBpdC5cbiAgICAgICAgICAgICAgICBpZiAobGFzdEVxdWFsaXR5ICYmXG4gICAgICAgICAgICAgICAgICAgIChsYXN0RXF1YWxpdHkubGVuZ3RoIDw9IG1hdGgubWF4KGxlbmd0aEluc2VydGlvbnMxLCBsZW5ndGhEZWxldGlvbnMxKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGxhc3RFcXVhbGl0eS5sZW5ndGggPD0gbWF0aC5tYXgobGVuZ3RoSW5zZXJ0aW9uczIsIGxlbmd0aERlbGV0aW9uczIpKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBEdXBsaWNhdGUgcmVjb3JkLlxuICAgICAgICAgICAgICAgICAgICBkaWZmcy5zcGxpY2UoZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0sIDAsIFtEaWZmT3BlcmF0aW9uLkRJRkZfREVMRVRFLCBsYXN0RXF1YWxpdHldKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hhbmdlIHNlY29uZCBjb3B5IHRvIGluc2VydC5cbiAgICAgICAgICAgICAgICAgICAgZGlmZnNbZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gKyAxXVswXSA9IERpZmZPcGVyYXRpb24uRElGRl9JTlNFUlQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRocm93IGF3YXkgdGhlIGVxdWFsaXR5IHdlIGp1c3QgZGVsZXRlZC5cbiAgICAgICAgICAgICAgICAgICAgZXF1YWxpdGllc0xlbmd0aC0tO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaHJvdyBhd2F5IHRoZSBwcmV2aW91cyBlcXVhbGl0eSAoaXQgbmVlZHMgdG8gYmUgcmVldmFsdWF0ZWQpLlxuICAgICAgICAgICAgICAgICAgICBlcXVhbGl0aWVzTGVuZ3RoLS07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXIgPSBlcXVhbGl0aWVzTGVuZ3RoID4gMCA/IGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdIDogLTE7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aEluc2VydGlvbnMxID0gMDsgLy8gUmVzZXQgdGhlIGNvdW50ZXJzLlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGhEZWxldGlvbnMxID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoSW5zZXJ0aW9uczIgPSAwO1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGhEZWxldGlvbnMyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEVxdWFsaXR5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgZGlmZi5cbiAgICAgICAgaWYgKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZGlmZl9jbGVhbnVwTWVyZ2UoZGlmZnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlmZl9jbGVhbnVwU2VtYW50aWNMb3NzbGVzcyhkaWZmcyk7XG4gICAgICAgIC8vIEZpbmQgYW55IG92ZXJsYXBzIGJldHdlZW4gZGVsZXRpb25zIGFuZCBpbnNlcnRpb25zLlxuICAgICAgICAvLyBlLmc6IDxkZWw+YWJjeHh4PC9kZWw+PGlucz54eHhkZWY8L2lucz5cbiAgICAgICAgLy8gICAtPiA8ZGVsPmFiYzwvZGVsPnh4eDxpbnM+ZGVmPC9pbnM+XG4gICAgICAgIC8vIGUuZzogPGRlbD54eHhhYmM8L2RlbD48aW5zPmRlZnh4eDwvaW5zPlxuICAgICAgICAvLyAgIC0+IDxpbnM+ZGVmPC9pbnM+eHh4PGRlbD5hYmM8L2RlbD5cbiAgICAgICAgLy8gT25seSBleHRyYWN0IGFuIG92ZXJsYXAgaWYgaXQgaXMgYXMgYmlnIGFzIHRoZSBlZGl0IGFoZWFkIG9yIGJlaGluZCBpdC5cbiAgICAgICAgcG9pbnRlciA9IDE7XG4gICAgICAgIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoZGlmZnNbcG9pbnRlciAtIDFdWzBdID09PSBEaWZmT3BlcmF0aW9uLkRJRkZfREVMRVRFICYmXG4gICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlcl1bMF0gPT09IERpZmZPcGVyYXRpb24uRElGRl9JTlNFUlQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVsZXRpb24gPSBkaWZmc1twb2ludGVyIC0gMV1bMV07XG4gICAgICAgICAgICAgICAgdmFyIGluc2VydGlvbiA9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICAgICAgICAgIHZhciBvdmVybGFwTGVuZ3RoMSA9IHRoaXMuZGlmZl9jb21tb25PdmVybGFwXyhkZWxldGlvbiwgaW5zZXJ0aW9uKTtcbiAgICAgICAgICAgICAgICB2YXIgb3ZlcmxhcExlbmd0aDIgPSB0aGlzLmRpZmZfY29tbW9uT3ZlcmxhcF8oaW5zZXJ0aW9uLCBkZWxldGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXBMZW5ndGgxID49IG92ZXJsYXBMZW5ndGgyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVybGFwTGVuZ3RoMSA+PSBkZWxldGlvbi5sZW5ndGggLyAyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGFwTGVuZ3RoMSA+PSBpbnNlcnRpb24ubGVuZ3RoIC8gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3ZlcmxhcCBmb3VuZC4gSW5zZXJ0IGFuIGVxdWFsaXR5IGFuZCB0cmltIHRoZSBzdXJyb3VuZGluZyBlZGl0cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBbRGlmZk9wZXJhdGlvbi5ESUZGX0VRVUFMLCBpbnNlcnRpb24uc3Vic3RyaW5nKDAsIG92ZXJsYXBMZW5ndGgxKV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdID0gZGVsZXRpb24uc3Vic3RyaW5nKDAsIGRlbGV0aW9uLmxlbmd0aCAtIG92ZXJsYXBMZW5ndGgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGluc2VydGlvbi5zdWJzdHJpbmcob3ZlcmxhcExlbmd0aDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcmxhcExlbmd0aDIgPj0gZGVsZXRpb24ubGVuZ3RoIC8gMiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcExlbmd0aDIgPj0gaW5zZXJ0aW9uLmxlbmd0aCAvIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldmVyc2Ugb3ZlcmxhcCBmb3VuZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluc2VydCBhbiBlcXVhbGl0eSBhbmQgc3dhcCBhbmQgdHJpbSB0aGUgc3Vycm91bmRpbmcgZWRpdHMuXG4gICAgICAgICAgICAgICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgW0RpZmZPcGVyYXRpb24uRElGRl9FUVVBTCwgZGVsZXRpb24uc3Vic3RyaW5nKDAsIG92ZXJsYXBMZW5ndGgyKV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzBdID0gRGlmZk9wZXJhdGlvbi5ESUZGX0lOU0VSVDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSA9IGluc2VydGlvbi5zdWJzdHJpbmcoMCwgaW5zZXJ0aW9uLmxlbmd0aCAtIG92ZXJsYXBMZW5ndGgyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVswXSA9IERpZmZPcGVyYXRpb24uRElGRl9ERUxFVEU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV0gPSBkZWxldGlvbi5zdWJzdHJpbmcob3ZlcmxhcExlbmd0aDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9vayBmb3Igc2luZ2xlIGVkaXRzIHN1cnJvdW5kZWQgb24gYm90aCBzaWRlcyBieSBlcXVhbGl0aWVzXG4gICAgICogd2hpY2ggY2FuIGJlIHNoaWZ0ZWQgc2lkZXdheXMgdG8gYWxpZ24gdGhlIGVkaXQgdG8gYSB3b3JkIGJvdW5kYXJ5LlxuICAgICAqIGUuZzogVGhlIGM8aW5zPmF0IGM8L2lucz5hbWUuIC0+IFRoZSA8aW5zPmNhdCA8L2lucz5jYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtEaWZmW119IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICAgICAqL1xuICAgIERpZmZNYXRjaFBhdGNoLnByb3RvdHlwZS5kaWZmX2NsZWFudXBTZW1hbnRpY0xvc3NsZXNzID0gZnVuY3Rpb24gKGRpZmZzKSB7XG4gICAgICAgIHZhciBwb2ludGVyID0gMTtcbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBpZ25vcmUgdGhlIGZpcnN0IGFuZCBsYXN0IGVsZW1lbnQgKGRvbid0IG5lZWQgY2hlY2tpbmcpLlxuICAgICAgICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGlmIChkaWZmc1twb2ludGVyIC0gMV1bMF0gPT09IERpZmZPcGVyYXRpb24uRElGRl9FUVVBTCAmJlxuICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVswXSA9PT0gRGlmZk9wZXJhdGlvbi5ESUZGX0VRVUFMKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHNpbmdsZSBlZGl0IHN1cnJvdW5kZWQgYnkgZXF1YWxpdGllcy5cbiAgICAgICAgICAgICAgICB2YXIgZXF1YWxpdHkxID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdO1xuICAgICAgICAgICAgICAgIHZhciBlZGl0ID0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgICAgICAgICAgdmFyIGVxdWFsaXR5MiA9IGRpZmZzW3BvaW50ZXIgKyAxXVsxXTtcbiAgICAgICAgICAgICAgICAvLyBGaXJzdCwgc2hpZnQgdGhlIGVkaXQgYXMgZmFyIGxlZnQgYXMgcG9zc2libGUuXG4gICAgICAgICAgICAgICAgdmFyIGNvbW1vbk9mZnNldCA9IHRoaXMuZGlmZl9jb21tb25TdWZmaXgoZXF1YWxpdHkxLCBlZGl0KTtcbiAgICAgICAgICAgICAgICBpZiAoY29tbW9uT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21tb25TdHJpbmcgPSBlZGl0LnN1YnN0cmluZyhlZGl0Lmxlbmd0aCAtIGNvbW1vbk9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGVxdWFsaXR5MSA9IGVxdWFsaXR5MS5zdWJzdHJpbmcoMCwgZXF1YWxpdHkxLmxlbmd0aCAtIGNvbW1vbk9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGVkaXQgPSBjb21tb25TdHJpbmcgKyBlZGl0LnN1YnN0cmluZygwLCBlZGl0Lmxlbmd0aCAtIGNvbW1vbk9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGVxdWFsaXR5MiA9IGNvbW1vblN0cmluZyArIGVxdWFsaXR5MjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2Vjb25kLCBzdGVwIGNoYXJhY3RlciBieSBjaGFyYWN0ZXIgcmlnaHQsIGxvb2tpbmcgZm9yIHRoZSBiZXN0IGZpdC5cbiAgICAgICAgICAgICAgICB2YXIgYmVzdEVxdWFsaXR5MSA9IGVxdWFsaXR5MTtcbiAgICAgICAgICAgICAgICB2YXIgYmVzdEVkaXQgPSBlZGl0O1xuICAgICAgICAgICAgICAgIHZhciBiZXN0RXF1YWxpdHkyID0gZXF1YWxpdHkyO1xuICAgICAgICAgICAgICAgIHZhciBiZXN0U2NvcmUgPSB0aGlzLmRpZmZfY2xlYW51cFNlbWFudGljU2NvcmVfKGVxdWFsaXR5MSwgZWRpdClcbiAgICAgICAgICAgICAgICAgICAgKyB0aGlzLmRpZmZfY2xlYW51cFNlbWFudGljU2NvcmVfKGVkaXQsIGVxdWFsaXR5Mik7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGVkaXQuY2hhckF0KDApID09PSBlcXVhbGl0eTIuY2hhckF0KDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGVxdWFsaXR5MSArPSBlZGl0LmNoYXJBdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgZWRpdCA9IGVkaXQuc3Vic3RyaW5nKDEpICsgZXF1YWxpdHkyLmNoYXJBdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgZXF1YWxpdHkyID0gZXF1YWxpdHkyLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjb3JlID0gdGhpcy5kaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlXyhlcXVhbGl0eTEsIGVkaXQpXG4gICAgICAgICAgICAgICAgICAgICAgICArIHRoaXMuZGlmZl9jbGVhbnVwU2VtYW50aWNTY29yZV8oZWRpdCwgZXF1YWxpdHkyKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlID49IGVuY291cmFnZXMgdHJhaWxpbmcgcmF0aGVyIHRoYW4gbGVhZGluZyB3aGl0ZXNwYWNlIG9uIGVkaXRzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcmUgPj0gYmVzdFNjb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0U2NvcmUgPSBzY29yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RFcXVhbGl0eTEgPSBlcXVhbGl0eTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0RWRpdCA9IGVkaXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0RXF1YWxpdHkyID0gZXF1YWxpdHkyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkaWZmc1twb2ludGVyIC0gMV1bMV0gIT09IGJlc3RFcXVhbGl0eTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhbiBpbXByb3ZlbWVudCwgc2F2ZSBpdCBiYWNrIHRvIHRoZSBkaWZmLlxuICAgICAgICAgICAgICAgICAgICBpZiAoYmVzdEVxdWFsaXR5MSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdID0gYmVzdEVxdWFsaXR5MTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gMSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0gPSBiZXN0RWRpdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlc3RFcXVhbGl0eTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGJlc3RFcXVhbGl0eTI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciArIDEsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlci0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWR1Y2UgdGhlIG51bWJlciBvZiBlZGl0cyBieSBlbGltaW5hdGluZyBvcGVyYXRpb25hbGx5IHRyaXZpYWwgZXF1YWxpdGllcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RGlmZltdfSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAgICAgKi9cbiAgICBEaWZmTWF0Y2hQYXRjaC5wcm90b3R5cGUuZGlmZl9jbGVhbnVwRWZmaWNpZW5jeSA9IGZ1bmN0aW9uIChkaWZmcykge1xuICAgICAgICB2YXIgY2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICB2YXIgZXF1YWxpdGllcyA9IFtdOyAvLyBTdGFjayBvZiBpbmRpY2VzIHdoZXJlIGVxdWFsaXRpZXMgYXJlIGZvdW5kLlxuICAgICAgICB2YXIgZXF1YWxpdGllc0xlbmd0aCA9IDA7IC8vIEtlZXBpbmcgb3VyIG93biBsZW5ndGggdmFyIGlzIGZhc3RlciBpbiBKUy5cbiAgICAgICAgdmFyIGxhc3RFcXVhbGl0eSA9IG51bGw7XG4gICAgICAgIC8vIEFsd2F5cyBlcXVhbCB0byBkaWZmc1tlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXV1bMV1cbiAgICAgICAgdmFyIHBvaW50ZXIgPSAwOyAvLyBJbmRleCBvZiBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICAvLyBJcyB0aGVyZSBhbiBpbnNlcnRpb24gb3BlcmF0aW9uIGJlZm9yZSB0aGUgbGFzdCBlcXVhbGl0eS5cbiAgICAgICAgdmFyIHByZUlucyA9IGZhbHNlO1xuICAgICAgICAvLyBJcyB0aGVyZSBhIGRlbGV0aW9uIG9wZXJhdGlvbiBiZWZvcmUgdGhlIGxhc3QgZXF1YWxpdHkuXG4gICAgICAgIHZhciBwcmVEZWwgPSBmYWxzZTtcbiAgICAgICAgLy8gSXMgdGhlcmUgYW4gaW5zZXJ0aW9uIG9wZXJhdGlvbiBhZnRlciB0aGUgbGFzdCBlcXVhbGl0eS5cbiAgICAgICAgdmFyIHBvc3RJbnMgPSBmYWxzZTtcbiAgICAgICAgLy8gSXMgdGhlcmUgYSBkZWxldGlvbiBvcGVyYXRpb24gYWZ0ZXIgdGhlIGxhc3QgZXF1YWxpdHkuXG4gICAgICAgIHZhciBwb3N0RGVsID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMF0gPT09IERpZmZPcGVyYXRpb24uRElGRl9FUVVBTCkge1xuICAgICAgICAgICAgICAgIC8vIEVxdWFsaXR5IGZvdW5kLlxuICAgICAgICAgICAgICAgIGlmIChkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggPCB0aGlzLmRpZmZFZGl0Q29zdCAmJlxuICAgICAgICAgICAgICAgICAgICAocG9zdElucyB8fCBwb3N0RGVsKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDYW5kaWRhdGUgZm91bmQuXG4gICAgICAgICAgICAgICAgICAgIGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCsrXSA9IHBvaW50ZXI7XG4gICAgICAgICAgICAgICAgICAgIHByZUlucyA9IHBvc3RJbnM7XG4gICAgICAgICAgICAgICAgICAgIHByZURlbCA9IHBvc3REZWw7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RFcXVhbGl0eSA9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgY2FuZGlkYXRlLCBhbmQgY2FuIG5ldmVyIGJlY29tZSBvbmUuXG4gICAgICAgICAgICAgICAgICAgIGVxdWFsaXRpZXNMZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICBsYXN0RXF1YWxpdHkgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3N0SW5zID0gcG9zdERlbCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQW4gaW5zZXJ0aW9uIG9yIGRlbGV0aW9uLlxuICAgICAgICAgICAgICAgIGlmIChkaWZmc1twb2ludGVyXVswXSA9PT0gRGlmZk9wZXJhdGlvbi5ESUZGX0RFTEVURSkge1xuICAgICAgICAgICAgICAgICAgICBwb3N0RGVsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc3RJbnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIEZpdmUgdHlwZXMgdG8gYmUgc3BsaXQ6XG4gICAgICAgICAgICAgICAgICogPGlucz5BPC9pbnM+PGRlbD5CPC9kZWw+WFk8aW5zPkM8L2lucz48ZGVsPkQ8L2RlbD5cbiAgICAgICAgICAgICAgICAgKiA8aW5zPkE8L2lucz5YPGlucz5DPC9pbnM+PGRlbD5EPC9kZWw+XG4gICAgICAgICAgICAgICAgICogPGlucz5BPC9pbnM+PGRlbD5CPC9kZWw+WDxpbnM+QzwvaW5zPlxuICAgICAgICAgICAgICAgICAqIDxpbnM+QTwvZGVsPlg8aW5zPkM8L2lucz48ZGVsPkQ8L2RlbD5cbiAgICAgICAgICAgICAgICAgKiA8aW5zPkE8L2lucz48ZGVsPkI8L2RlbD5YPGRlbD5DPC9kZWw+XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RFcXVhbGl0eSAmJlxuICAgICAgICAgICAgICAgICAgICAoKHByZUlucyAmJiBwcmVEZWwgJiYgcG9zdElucyAmJiBwb3N0RGVsKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKChsYXN0RXF1YWxpdHkubGVuZ3RoIDwgdGhpcy5kaWZmRWRpdENvc3QgLyAyKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChOdW1iZXIocHJlSW5zKSArIE51bWJlcihwcmVEZWwpICsgTnVtYmVyKHBvc3RJbnMpICsgTnVtYmVyKHBvc3REZWwpKSA9PT0gMykpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIER1cGxpY2F0ZSByZWNvcmQuXG4gICAgICAgICAgICAgICAgICAgIGRpZmZzLnNwbGljZShlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSwgMCwgW0RpZmZPcGVyYXRpb24uRElGRl9ERUxFVEUsIGxhc3RFcXVhbGl0eV0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGFuZ2Ugc2Vjb25kIGNvcHkgdG8gaW5zZXJ0LlxuICAgICAgICAgICAgICAgICAgICBkaWZmc1tlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSArIDFdWzBdID0gRGlmZk9wZXJhdGlvbi5ESUZGX0lOU0VSVDtcbiAgICAgICAgICAgICAgICAgICAgZXF1YWxpdGllc0xlbmd0aC0tOyAvLyBUaHJvdyBhd2F5IHRoZSBlcXVhbGl0eSB3ZSBqdXN0IGRlbGV0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RFcXVhbGl0eSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVJbnMgJiYgcHJlRGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBjaGFuZ2VzIG1hZGUgd2hpY2ggY291bGQgYWZmZWN0IHByZXZpb3VzIGVudHJ5LCBrZWVwIGdvaW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdElucyA9IHBvc3REZWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXF1YWxpdGllc0xlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcXVhbGl0aWVzTGVuZ3RoLS07IC8vIFRocm93IGF3YXkgdGhlIHByZXZpb3VzIGVxdWFsaXR5LlxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlciA9IGVxdWFsaXRpZXNMZW5ndGggPiAwID8gZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RJbnMgPSBwb3N0RGVsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLmRpZmZfY2xlYW51cE1lcmdlKGRpZmZzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVvcmRlciBhbmQgbWVyZ2UgbGlrZSBlZGl0IHNlY3Rpb25zLiBNZXJnZSBlcXVhbGl0aWVzLlxuICAgICAqIEFueSBlZGl0IHNlY3Rpb24gY2FuIG1vdmUgYXMgbG9uZyBhcyBpdCBkb2Vzbid0IGNyb3NzIGFuIGVxdWFsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtEaWZmW119IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICAgICAqL1xuICAgIERpZmZNYXRjaFBhdGNoLnByb3RvdHlwZS5kaWZmX2NsZWFudXBNZXJnZSA9IGZ1bmN0aW9uIChkaWZmcykge1xuICAgICAgICAvLyBBZGQgYSBkdW1teSBlbnRyeSBhdCB0aGUgZW5kLlxuICAgICAgICBkaWZmcy5wdXNoKFtEaWZmT3BlcmF0aW9uLkRJRkZfRVFVQUwsIFwiXCJdKTtcbiAgICAgICAgdmFyIHBvaW50ZXIgPSAwO1xuICAgICAgICB2YXIgY291bnREZWxldGUgPSAwO1xuICAgICAgICB2YXIgY291bnRJbnNlcnQgPSAwO1xuICAgICAgICB2YXIgdGV4dERlbGV0ZSA9IFwiXCI7XG4gICAgICAgIHZhciB0ZXh0SW5zZXJ0ID0gXCJcIjtcbiAgICAgICAgdmFyIGNvbW1vbmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZGlmZnNbcG9pbnRlcl1bMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIERpZmZPcGVyYXRpb24uRElGRl9JTlNFUlQ6XG4gICAgICAgICAgICAgICAgICAgIGNvdW50SW5zZXJ0Kys7XG4gICAgICAgICAgICAgICAgICAgIHRleHRJbnNlcnQgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBEaWZmT3BlcmF0aW9uLkRJRkZfREVMRVRFOlxuICAgICAgICAgICAgICAgICAgICBjb3VudERlbGV0ZSsrO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0RGVsZXRlICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICAgICAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRGlmZk9wZXJhdGlvbi5ESUZGX0VRVUFMOlxuICAgICAgICAgICAgICAgICAgICAvLyBVcG9uIHJlYWNoaW5nIGFuIGVxdWFsaXR5LCBjaGVjayBmb3IgcHJpb3IgcmVkdW5kYW5jaWVzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnREZWxldGUgKyBjb3VudEluc2VydCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3VudERlbGV0ZSAhPT0gMCAmJiBjb3VudEluc2VydCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhY3RvciBvdXQgYW55IGNvbW1vbiBwcmVmaXhlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tb25sZW5ndGggPSB0aGlzLmRpZmZfY29tbW9uUHJlZml4KHRleHRJbnNlcnQsIHRleHREZWxldGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21tb25sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwb2ludGVyIC0gY291bnREZWxldGUgLSBjb3VudEluc2VydCkgPiAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGlmZnNbcG9pbnRlciAtIGNvdW50RGVsZXRlIC0gY291bnRJbnNlcnQgLSAxXVswXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID09PSBEaWZmT3BlcmF0aW9uLkRJRkZfRVFVQUwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyIC0gY291bnREZWxldGUgLSBjb3VudEluc2VydCAtIDFdWzFdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKz0gdGV4dEluc2VydC5zdWJzdHJpbmcoMCwgY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZzLnNwbGljZSgwLCAwLCBbRGlmZk9wZXJhdGlvbi5ESUZGX0VRVUFMLCB0ZXh0SW5zZXJ0LnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEluc2VydCA9IHRleHRJbnNlcnQuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHREZWxldGUgPSB0ZXh0RGVsZXRlLnN1YnN0cmluZyhjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWN0b3Igb3V0IGFueSBjb21tb24gc3VmZml4ZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbW9ubGVuZ3RoID0gdGhpcy5kaWZmX2NvbW1vblN1ZmZpeCh0ZXh0SW5zZXJ0LCB0ZXh0RGVsZXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tbW9ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID0gdGV4dEluc2VydC5zdWJzdHJpbmcodGV4dEluc2VydC5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gY29tbW9ubGVuZ3RoKSArIGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0SW5zZXJ0ID0gdGV4dEluc2VydC5zdWJzdHJpbmcoMCwgdGV4dEluc2VydC5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0RGVsZXRlID0gdGV4dERlbGV0ZS5zdWJzdHJpbmcoMCwgdGV4dERlbGV0ZS5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlbGV0ZSB0aGUgb2ZmZW5kaW5nIHJlY29yZHMgYW5kIGFkZCB0aGUgbWVyZ2VkIG9uZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyIC09IGNvdW50RGVsZXRlICsgY291bnRJbnNlcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgY291bnREZWxldGUgKyBjb3VudEluc2VydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dERlbGV0ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgW0RpZmZPcGVyYXRpb24uRElGRl9ERUxFVEUsIHRleHREZWxldGVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dEluc2VydC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgW0RpZmZPcGVyYXRpb24uRElGRl9JTlNFUlQsIHRleHRJbnNlcnRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocG9pbnRlciAhPT0gMCAmJiBkaWZmc1twb2ludGVyIC0gMV1bMF0gPT09IERpZmZPcGVyYXRpb24uRElGRl9FUVVBTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWVyZ2UgdGhpcyBlcXVhbGl0eSB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgICAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRJbnNlcnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudERlbGV0ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRleHREZWxldGUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0SW5zZXJ0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdID09PSBcIlwiKSB7XG4gICAgICAgICAgICBkaWZmcy5wb3AoKTsgLy8gUmVtb3ZlIHRoZSBkdW1teSBlbnRyeSBhdCB0aGUgZW5kLlxuICAgICAgICB9XG4gICAgICAgIC8vIFNlY29uZCBwYXNzOiBsb29rIGZvciBzaW5nbGUgZWRpdHMgc3Vycm91bmRlZCBvbiBib3RoIHNpZGVzIGJ5IGVxdWFsaXRpZXNcbiAgICAgICAgLy8gd2hpY2ggY2FuIGJlIHNoaWZ0ZWQgc2lkZXdheXMgdG8gZWxpbWluYXRlIGFuIGVxdWFsaXR5LlxuICAgICAgICAvLyBlLmc6IEE8aW5zPkJBPC9pbnM+QyAtPiA8aW5zPkFCPC9pbnM+QUNcbiAgICAgICAgdmFyIGNoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgcG9pbnRlciA9IDE7XG4gICAgICAgIC8vIEludGVudGlvbmFsbHkgaWdub3JlIHRoZSBmaXJzdCBhbmQgbGFzdCBlbGVtZW50IChkb24ndCBuZWVkIGNoZWNraW5nKS5cbiAgICAgICAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBpZiAoZGlmZnNbcG9pbnRlciAtIDFdWzBdID09PSBEaWZmT3BlcmF0aW9uLkRJRkZfRVFVQUwgJiZcbiAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMF0gPT09IERpZmZPcGVyYXRpb24uRElGRl9FUVVBTCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBzaW5nbGUgZWRpdCBzdXJyb3VuZGVkIGJ5IGVxdWFsaXRpZXMuXG4gICAgICAgICAgICAgICAgaWYgKGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZyhkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggLSBkaWZmc1twb2ludGVyIC0gMV1bMV0ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICA9PT0gZGlmZnNbcG9pbnRlciAtIDFdWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNoaWZ0IHRoZSBlZGl0IG92ZXIgdGhlIHByZXZpb3VzIGVxdWFsaXR5LlxuICAgICAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyXVsxXSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoMCwgZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIC0gZGlmZnNbcG9pbnRlciAtIDFdWzFdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArIGRpZmZzW3BvaW50ZXIgKyAxXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSAxLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZygwLCBkaWZmc1twb2ludGVyICsgMV1bMV0ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICA9PT0gZGlmZnNbcG9pbnRlciArIDFdWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNoaWZ0IHRoZSBlZGl0IG92ZXIgdGhlIG5leHQgZXF1YWxpdHkuXG4gICAgICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArPSBkaWZmc1twb2ludGVyICsgMV1bMV07XG4gICAgICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID0gZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKGRpZmZzW3BvaW50ZXIgKyAxXVsxXS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICArIGRpZmZzW3BvaW50ZXIgKyAxXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgKyAxLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHNoaWZ0cyB3ZXJlIG1hZGUsIHRoZSBkaWZmIG5lZWRzIHJlb3JkZXJpbmcgYW5kIGFub3RoZXIgc2hpZnQgc3dlZXAuXG4gICAgICAgIGlmIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLmRpZmZfY2xlYW51cE1lcmdlKGRpZmZzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogbG9jIGlzIGEgbG9jYXRpb24gaW4gdGV4dDEsIGNvbXB1dGUgYW5kIHJldHVybiB0aGUgZXF1aXZhbGVudCBsb2NhdGlvbiBpblxuICAgICAqIHRleHQyLlxuICAgICAqIGUuZy4gJ1RoZSBjYXQnIHZzICdUaGUgYmlnIGNhdCcsIDEtPjEsIDUtPjhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RGlmZltdfSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG9jIExvY2F0aW9uIHdpdGhpbiB0ZXh0MS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBMb2NhdGlvbiB3aXRoaW4gdGV4dDIuXG4gICAgICovXG4gICAgRGlmZk1hdGNoUGF0Y2gucHJvdG90eXBlLmRpZmZfeEluZGV4ID0gZnVuY3Rpb24gKGRpZmZzLCBsb2MpIHtcbiAgICAgICAgdmFyIGNoYXJzMSA9IDA7XG4gICAgICAgIHZhciBjaGFyczIgPSAwO1xuICAgICAgICB2YXIgbGFzdENoYXJzMSA9IDA7XG4gICAgICAgIHZhciBsYXN0Q2hhcnMyID0gMDtcbiAgICAgICAgdmFyIHg7XG4gICAgICAgIGZvciAoeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgaWYgKGRpZmZzW3hdWzBdICE9PSBEaWZmT3BlcmF0aW9uLkRJRkZfSU5TRVJUKSB7XG4gICAgICAgICAgICAgICAgLy8gRXF1YWxpdHkgb3IgZGVsZXRpb24uXG4gICAgICAgICAgICAgICAgY2hhcnMxICs9IGRpZmZzW3hdWzFdLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaWZmc1t4XVswXSAhPT0gRGlmZk9wZXJhdGlvbi5ESUZGX0RFTEVURSkge1xuICAgICAgICAgICAgICAgIC8vIEVxdWFsaXR5IG9yIGluc2VydGlvbi5cbiAgICAgICAgICAgICAgICBjaGFyczIgKz0gZGlmZnNbeF1bMV0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYXJzMSA+IGxvYykge1xuICAgICAgICAgICAgICAgIC8vIE92ZXJzaG90IHRoZSBsb2NhdGlvbi5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RDaGFyczEgPSBjaGFyczE7XG4gICAgICAgICAgICBsYXN0Q2hhcnMyID0gY2hhcnMyO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdhcyB0aGUgbG9jYXRpb24gd2FzIGRlbGV0ZWQ/XG4gICAgICAgIGlmIChkaWZmcy5sZW5ndGggIT09IHggJiZcbiAgICAgICAgICAgIGRpZmZzW3hdWzBdID09PSBEaWZmT3BlcmF0aW9uLkRJRkZfREVMRVRFKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFzdENoYXJzMjtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIHJlbWFpbmluZyBjaGFyYWN0ZXIgbGVuZ3RoLlxuICAgICAgICByZXR1cm4gbGFzdENoYXJzMiArIChsb2MgLSBsYXN0Q2hhcnMxKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBkaWZmIGFycmF5IGludG8gYSBwcmV0dHkgSFRNTCByZXBvcnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0RpZmZbXT59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEhUTUwgcmVwcmVzZW50YXRpb24uXG4gICAgICovXG4gICAgRGlmZk1hdGNoUGF0Y2gucHJvdG90eXBlLmRpZmZfcHJldHR5SHRtbCA9IGZ1bmN0aW9uIChkaWZmcykge1xuICAgICAgICB2YXIgaHRtbCA9IFtdO1xuICAgICAgICB2YXIgcGF0dGVybkFNUCA9IC8mL2c7XG4gICAgICAgIHZhciBwYXR0ZXJuTFQgPSAvPC9nO1xuICAgICAgICB2YXIgcGF0dGVybkdUID0gLz4vZztcbiAgICAgICAgdmFyIHBhdHRlcm5QQVJBID0gL1xcbi9nO1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICB2YXIgb3AgPSBkaWZmc1t4XVswXTsgLy8gT3BlcmF0aW9uIChpbnNlcnQsIGRlbGV0ZSwgZXF1YWwpXG4gICAgICAgICAgICB2YXIgZGF0YSA9IGRpZmZzW3hdWzFdOyAvLyBUZXh0IG9mIGNoYW5nZS5cbiAgICAgICAgICAgIHZhciB0ZXh0ID0gZGF0YS5yZXBsYWNlKHBhdHRlcm5BTVAsIFwiJmFtcDtcIilcbiAgICAgICAgICAgICAgICAucmVwbGFjZShwYXR0ZXJuTFQsIFwiJmx0O1wiKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKHBhdHRlcm5HVCwgXCImZ3Q7XCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UocGF0dGVyblBBUkEsIFwiJnBhcmE7PGJyPlwiKTtcbiAgICAgICAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgICAgICAgICBjYXNlIERpZmZPcGVyYXRpb24uRElGRl9JTlNFUlQ6XG4gICAgICAgICAgICAgICAgICAgIGh0bWxbeF0gPSAnPGlucyBzdHlsZT1cImJhY2tncm91bmQ6I2U2ZmZlNjtcIj4nICsgdGV4dCArIFwiPC9pbnM+XCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRGlmZk9wZXJhdGlvbi5ESUZGX0RFTEVURTpcbiAgICAgICAgICAgICAgICAgICAgaHRtbFt4XSA9ICc8ZGVsIHN0eWxlPVwiYmFja2dyb3VuZDojZmZlNmU2O1wiPicgKyB0ZXh0ICsgXCI8L2RlbD5cIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBEaWZmT3BlcmF0aW9uLkRJRkZfRVFVQUw6XG4gICAgICAgICAgICAgICAgICAgIGh0bWxbeF0gPSBcIjxzcGFuPlwiICsgdGV4dCArIFwiPC9zcGFuPlwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHRtbC5qb2luKFwiXCIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSBhbmQgcmV0dXJuIHRoZSBzb3VyY2UgdGV4dCAoYWxsIGVxdWFsaXRpZXMgYW5kIGRlbGV0aW9ucykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0RpZmZbXX0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gU291cmNlIHRleHQuXG4gICAgICovXG4gICAgRGlmZk1hdGNoUGF0Y2gucHJvdG90eXBlLmRpZmZfdGV4dDEgPSBmdW5jdGlvbiAoZGlmZnMpIHtcbiAgICAgICAgdmFyIHRleHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgaWYgKGRpZmZzW3hdWzBdICE9PSBEaWZmT3BlcmF0aW9uLkRJRkZfSU5TRVJUKSB7XG4gICAgICAgICAgICAgICAgdGV4dFt4XSA9IGRpZmZzW3hdWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0LmpvaW4oXCJcIik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlIGFuZCByZXR1cm4gdGhlIGRlc3RpbmF0aW9uIHRleHQgKGFsbCBlcXVhbGl0aWVzIGFuZCBpbnNlcnRpb25zKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RGlmZltdfSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBEZXN0aW5hdGlvbiB0ZXh0LlxuICAgICAqL1xuICAgIERpZmZNYXRjaFBhdGNoLnByb3RvdHlwZS5kaWZmX3RleHQyID0gZnVuY3Rpb24gKGRpZmZzKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gW107XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAgIGlmIChkaWZmc1t4XVswXSAhPT0gRGlmZk9wZXJhdGlvbi5ESUZGX0RFTEVURSkge1xuICAgICAgICAgICAgICAgIHRleHRbeF0gPSBkaWZmc1t4XVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dC5qb2luKFwiXCIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgTGV2ZW5zaHRlaW4gZGlzdGFuY2U7IHRoZSBudW1iZXIgb2YgaW5zZXJ0ZWQsIGRlbGV0ZWQgb3JcbiAgICAgKiBzdWJzdGl0dXRlZCBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtEaWZmW119IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBjaGFuZ2VzLlxuICAgICAqL1xuICAgIERpZmZNYXRjaFBhdGNoLnByb3RvdHlwZS5kaWZmX2xldmVuc2h0ZWluID0gZnVuY3Rpb24gKGRpZmZzKSB7XG4gICAgICAgIHZhciBsZXZlbnNodGVpbiA9IDA7XG4gICAgICAgIHZhciBpbnNlcnRpb25zID0gMDtcbiAgICAgICAgdmFyIGRlbGV0aW9ucyA9IDA7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAgIHZhciBvcCA9IGRpZmZzW3hdWzBdO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBkaWZmc1t4XVsxXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgICAgICAgICBjYXNlIERpZmZPcGVyYXRpb24uRElGRl9JTlNFUlQ6XG4gICAgICAgICAgICAgICAgICAgIGluc2VydGlvbnMgKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRGlmZk9wZXJhdGlvbi5ESUZGX0RFTEVURTpcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRpb25zICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIERpZmZPcGVyYXRpb24uRElGRl9FUVVBTDpcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBkZWxldGlvbiBhbmQgYW4gaW5zZXJ0aW9uIGlzIG9uZSBzdWJzdGl0dXRpb24uXG4gICAgICAgICAgICAgICAgICAgIGxldmVuc2h0ZWluICs9IG1hdGgubWF4KGluc2VydGlvbnMsIGRlbGV0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydGlvbnMgPSAwO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGlvbnMgPSAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXZlbnNodGVpbiArPSBtYXRoLm1heChpbnNlcnRpb25zLCBkZWxldGlvbnMpO1xuICAgICAgICByZXR1cm4gbGV2ZW5zaHRlaW47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcnVzaCB0aGUgZGlmZiBpbnRvIGFuIGVuY29kZWQgc3RyaW5nIHdoaWNoIGRlc2NyaWJlcyB0aGUgb3BlcmF0aW9uc1xuICAgICAqIHJlcXVpcmVkIHRvIHRyYW5zZm9ybSB0ZXh0MSBpbnRvIHRleHQyLlxuICAgICAqIEUuZy4gPTNcXHQtMlxcdCtpbmcgIC0+IEtlZXAgMyBjaGFycywgZGVsZXRlIDIgY2hhcnMsIGluc2VydCAnaW5nJy5cbiAgICAgKiBPcGVyYXRpb25zIGFyZSB0YWItc2VwYXJhdGVkLiBJbnNlcnRlZCB0ZXh0IGlzIGVzY2FwZWQgdXNpbmcgJXh4IG5vdGF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtEaWZmW119IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IERlbHRhIHRleHQuXG4gICAgICovXG4gICAgRGlmZk1hdGNoUGF0Y2gucHJvdG90eXBlLmRpZmZfdG9EZWx0YSA9IGZ1bmN0aW9uIChkaWZmcykge1xuICAgICAgICB2YXIgdGV4dCA9IFtdO1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGRpZmZzW3hdWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBEaWZmT3BlcmF0aW9uLkRJRkZfSU5TRVJUOlxuICAgICAgICAgICAgICAgICAgICB0ZXh0W3hdID0gXCIrXCIgKyBlbmNvZGVVUkkoZGlmZnNbeF1bMV0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIERpZmZPcGVyYXRpb24uRElGRl9ERUxFVEU6XG4gICAgICAgICAgICAgICAgICAgIHRleHRbeF0gPSBcIi1cIiArIGRpZmZzW3hdWzFdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBEaWZmT3BlcmF0aW9uLkRJRkZfRVFVQUw6XG4gICAgICAgICAgICAgICAgICAgIHRleHRbeF0gPSBcIj1cIiArIGRpZmZzW3hdWzFdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQuam9pbihcIlxcdFwiKS5yZXBsYWNlKC8lMjAvZywgXCIgXCIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gdGhlIG9yaWdpbmFsIHRleHQxLCBhbmQgYW4gZW5jb2RlZCBzdHJpbmcgd2hpY2ggZGVzY3JpYmVzIHRoZVxuICAgICAqIG9wZXJhdGlvbnMgcmVxdWlyZWQgdG8gdHJhbnNmb3JtIHRleHQxIGludG8gdGV4dDIsIGNvbXB1dGUgdGhlIGZ1bGwgZGlmZi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBTb3VyY2Ugc3RyaW5nIGZvciB0aGUgZGlmZi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGVsdGEgRGVsdGEgdGV4dC5cbiAgICAgKiBAcmV0dXJucyB7RGlmZltdfSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgaW52YWxpZCBpbnB1dC5cbiAgICAgKi9cbiAgICBEaWZmTWF0Y2hQYXRjaC5wcm90b3R5cGUuZGlmZl9mcm9tRGVsdGEgPSBmdW5jdGlvbiAodGV4dDEsIGRlbHRhKSB7XG4gICAgICAgIHZhciBkaWZmcyA9IFtdO1xuICAgICAgICB2YXIgZGlmZnNMZW5ndGggPSAwOyAvLyBLZWVwaW5nIG91ciBvd24gbGVuZ3RoIHZhciBpcyBmYXN0ZXIgaW4gSlMuXG4gICAgICAgIHZhciBwb2ludGVyID0gMDsgLy8gQ3Vyc29yIGluIHRleHQxXG4gICAgICAgIHZhciB0b2tlbnMgPSBkZWx0YS5zcGxpdCgvXFx0L2cpO1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHRva2Vucy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgLy8gRWFjaCB0b2tlbiBiZWdpbnMgd2l0aCBhIG9uZSBjaGFyYWN0ZXIgcGFyYW1ldGVyIHdoaWNoIHNwZWNpZmllcyB0aGVcbiAgICAgICAgICAgIC8vIG9wZXJhdGlvbiBvZiB0aGlzIHRva2VuIChkZWxldGUsIGluc2VydCwgZXF1YWxpdHkpLlxuICAgICAgICAgICAgdmFyIHBhcmFtID0gdG9rZW5zW3hdLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW5zW3hdLmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWZmc1tkaWZmc0xlbmd0aCsrXSA9IFtEaWZmT3BlcmF0aW9uLkRJRkZfSU5TRVJULCBkZWNvZGVVUkkocGFyYW0pXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hbGZvcm1lZCBVUkkgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIGVzY2FwZSBpbiBkaWZmX2Zyb21EZWx0YTogXCIgKyBwYXJhbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgICAgICAgICAvLyBGYWxsIHRocm91Z2guXG4gICAgICAgICAgICAgICAgY2FzZSBcIj1cIjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBwYXJzZUludChwYXJhbSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4obikgfHwgbiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbnVtYmVyIGluIGRpZmZfZnJvbURlbHRhOiBcIiArIHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IHRleHQxLnN1YnN0cmluZyhwb2ludGVyLCBwb2ludGVyICs9IG4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5zW3hdLmNoYXJBdCgwKSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZzW2RpZmZzTGVuZ3RoKytdID0gW0RpZmZPcGVyYXRpb24uRElGRl9FUVVBTCwgdGV4dF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWZmc1tkaWZmc0xlbmd0aCsrXSA9IFtEaWZmT3BlcmF0aW9uLkRJRkZfREVMRVRFLCB0ZXh0XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAvLyBCbGFuayB0b2tlbnMgYXJlIG9rIChmcm9tIGEgdHJhaWxpbmcgXFx0KS5cbiAgICAgICAgICAgICAgICAgICAgLy8gQW55dGhpbmcgZWxzZSBpcyBhbiBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2Vuc1t4XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkaWZmIG9wZXJhdGlvbiBpbiBkaWZmX2Zyb21EZWx0YTogXCIgKyB0b2tlbnNbeF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvaW50ZXIgIT09IHRleHQxLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVsdGEgbGVuZ3RoIChcIiArIHBvaW50ZXIgKyBcIikgZG9lcyBub3QgZXF1YWwgc291cmNlIHRleHQgbGVuZ3RoIChcIlxuICAgICAgICAgICAgICAgICsgdGV4dDEubGVuZ3RoICsgXCIpXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmcztcbiAgICB9O1xuICAgIC8vI2VuZHJlZ2lvbiBESUZGIEZVTkNUSU9OUyAocHVibGljKVxuICAgIC8vI3JlZ2lvbiBNQVRDSCBGVU5DVElPTlMgKHB1YmxpYylcbiAgICAvKipcbiAgICAgKiBMb2NhdGUgdGhlIGJlc3QgaW5zdGFuY2Ugb2YgJ3BhdHRlcm4nIGluICd0ZXh0JyBuZWFyICdsb2MnLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvYyBUaGUgbG9jYXRpb24gdG8gc2VhcmNoIGFyb3VuZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBCZXN0IG1hdGNoIGluZGV4IG9yIC0xLlxuICAgICAqL1xuICAgIERpZmZNYXRjaFBhdGNoLnByb3RvdHlwZS5tYXRjaF9tYWluID0gZnVuY3Rpb24gKHRleHQsIHBhdHRlcm4sIGxvYykge1xuICAgICAgICAvLyBDaGVjayBmb3IgbnVsbCBpbnB1dHMuXG4gICAgICAgIGlmICh0ZXh0ID09IG51bGwgfHwgcGF0dGVybiA9PSBudWxsIHx8IGxvYyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOdWxsIGlucHV0LiAobWF0Y2hfbWFpbilcIik7XG4gICAgICAgIH1cbiAgICAgICAgbG9jID0gbWF0aC5tYXgoMCwgbWF0aC5taW4obG9jLCB0ZXh0Lmxlbmd0aCkpO1xuICAgICAgICBpZiAodGV4dCA9PT0gcGF0dGVybikge1xuICAgICAgICAgICAgLy8gU2hvcnRjdXQgKHBvdGVudGlhbGx5IG5vdCBndWFyYW50ZWVkIGJ5IHRoZSBhbGdvcml0aG0pXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gbWF0Y2guXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGV4dC5zdWJzdHJpbmcobG9jLCBsb2MgKyBwYXR0ZXJuLmxlbmd0aCkgPT09IHBhdHRlcm4pIHtcbiAgICAgICAgICAgIC8vIFBlcmZlY3QgbWF0Y2ggYXQgdGhlIHBlcmZlY3Qgc3BvdCEgIChJbmNsdWRlcyBjYXNlIG9mIG51bGwgcGF0dGVybilcbiAgICAgICAgICAgIHJldHVybiBsb2M7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBEbyBhIGZ1enp5IGNvbXBhcmUuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXRjaF9iaXRhcF8odGV4dCwgcGF0dGVybiwgbG9jKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8jZW5kcmVnaW9uIE1BVENIIEZVTkNUSU9OUyAocHVibGljKVxuICAgIC8vI3JlZ2lvbiBQQVRDSCBGVU5DVElPTlMgKHB1YmxpYylcbiAgICAvKipcbiAgICAgKiBDb21wdXRlIGEgbGlzdCBvZiBwYXRjaGVzIHRvIHR1cm4gdGV4dDEgaW50byB0ZXh0Mi5cbiAgICAgKiBVc2UgZGlmZnMgaWYgcHJvdmlkZWQsIG90aGVyd2lzZSBjb21wdXRlIGl0IG91cnNlbHZlcy5cbiAgICAgKiBUaGVyZSBhcmUgZm91ciB3YXlzIHRvIGNhbGwgdGhpcyBmdW5jdGlvbiwgZGVwZW5kaW5nIG9uIHdoYXQgZGF0YSBpc1xuICAgICAqIGF2YWlsYWJsZSB0byB0aGUgY2FsbGVyOlxuICAgICAqIE1ldGhvZCAxOlxuICAgICAqIGEgPSB0ZXh0MSwgYiA9IHRleHQyXG4gICAgICogTWV0aG9kIDI6XG4gICAgICogYSA9IGRpZmZzXG4gICAgICogTWV0aG9kIDMgKG9wdGltYWwpOlxuICAgICAqIGEgPSB0ZXh0MSwgYiA9IGRpZmZzXG4gICAgICogTWV0aG9kIDQgKGRlcHJlY2F0ZWQsIHVzZSBtZXRob2QgMyk6XG4gICAgICogYSA9IHRleHQxLCBiID0gdGV4dDIsIGMgPSBkaWZmc1xuICAgICAqXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfERpZmZbXSl9IGEgdGV4dDEgKG1ldGhvZHMgMSwzLDQpIG9yXG4gICAgICogQXJyYXkgb2YgZGlmZiB0dXBsZXMgZm9yIHRleHQxIHRvIHRleHQyIChtZXRob2QgMikuXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfERpZmZbXSl9IFtvcHRCXSB0ZXh0MiAobWV0aG9kcyAxLDQpIG9yXG4gICAgICogQXJyYXkgb2YgZGlmZiB0dXBsZXMgZm9yIHRleHQxIHRvIHRleHQyIChtZXRob2QgMykgb3IgdW5kZWZpbmVkIChtZXRob2QgMikuXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfERpZmZbXSl9IFtvcHRDXSBBcnJheSBvZiBkaWZmIHR1cGxlc1xuICAgICAqIGZvciB0ZXh0MSB0byB0ZXh0MiAobWV0aG9kIDQpIG9yIHVuZGVmaW5lZCAobWV0aG9kcyAxLDIsMykuXG4gICAgICogQHJldHVybnMge1BhdGNoT2JqZWN0W119IEFycmF5IG9mIFBhdGNoIG9iamVjdHMuXG4gICAgICovXG4gICAgRGlmZk1hdGNoUGF0Y2gucHJvdG90eXBlLnBhdGNoX21ha2UgPSBmdW5jdGlvbiAoYSwgb3B0Qiwgb3B0Qykge1xuICAgICAgICB2YXIgdGV4dDE7XG4gICAgICAgIHZhciBkaWZmcztcbiAgICAgICAgaWYgKHR5cGVvZiBhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICB0eXBlb2Ygb3B0QiA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgdHlwZW9mIG9wdEMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIC8vIE1ldGhvZCAxOiB0ZXh0MSwgdGV4dDJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgZGlmZnMgZnJvbSB0ZXh0MSBhbmQgdGV4dDIuXG4gICAgICAgICAgICB0ZXh0MSA9IGE7XG4gICAgICAgICAgICBkaWZmcyA9IHRoaXMuZGlmZl9tYWluKHRleHQxLCBvcHRCLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChkaWZmcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWZmX2NsZWFudXBTZW1hbnRpYyhkaWZmcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWZmX2NsZWFudXBFZmZpY2llbmN5KGRpZmZzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhICYmXG4gICAgICAgICAgICB0eXBlb2YgYSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgdHlwZW9mIG9wdEIgPT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBvcHRDID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAvLyBNZXRob2QgMjogZGlmZnNcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGV4dDEgZnJvbSBkaWZmcy5cbiAgICAgICAgICAgIGRpZmZzID0gYTtcbiAgICAgICAgICAgIHRleHQxID0gdGhpcy5kaWZmX3RleHQxKGRpZmZzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgb3B0QiAmJlxuICAgICAgICAgICAgdHlwZW9mIG9wdEIgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBvcHRDID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAvLyBNZXRob2QgMzogdGV4dDEsIGRpZmZzXG4gICAgICAgICAgICB0ZXh0MSA9IGE7XG4gICAgICAgICAgICBkaWZmcyA9IG9wdEI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBvcHRCID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICBvcHRDICYmXG4gICAgICAgICAgICB0eXBlb2Ygb3B0QyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgLy8gTWV0aG9kIDQ6IHRleHQxLCB0ZXh0MiwgZGlmZnNcbiAgICAgICAgICAgIC8vIHRleHQyIGlzIG5vdCB1c2VkLlxuICAgICAgICAgICAgdGV4dDEgPSBhO1xuICAgICAgICAgICAgZGlmZnMgPSBvcHRDO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBjYWxsIGZvcm1hdCB0byBwYXRjaF9tYWtlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaWZmcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTsgLy8gR2V0IHJpZCBvZiB0aGUgbnVsbCBjYXNlLlxuICAgICAgICB9XG4gICAgICAgIHZhciBwYXRjaGVzID0gW107XG4gICAgICAgIHZhciBwYXRjaCA9IG5ldyBQYXRjaE9iamVjdCgpO1xuICAgICAgICB2YXIgcGF0Y2hEaWZmTGVuZ3RoID0gMDsgLy8gS2VlcGluZyBvdXIgb3duIGxlbmd0aCB2YXIgaXMgZmFzdGVyIGluIEpTLlxuICAgICAgICB2YXIgY2hhckNvdW50MSA9IDA7IC8vIE51bWJlciBvZiBjaGFyYWN0ZXJzIGludG8gdGhlIHRleHQxIHN0cmluZy5cbiAgICAgICAgdmFyIGNoYXJDb3VudDIgPSAwOyAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyBpbnRvIHRoZSB0ZXh0MiBzdHJpbmcuXG4gICAgICAgIC8vIFN0YXJ0IHdpdGggdGV4dDEgKHByZXBhdGNoX3RleHQpIGFuZCBhcHBseSB0aGUgZGlmZnMgdW50aWwgd2UgYXJyaXZlIGF0XG4gICAgICAgIC8vIHRleHQyIChwb3N0cGF0Y2hfdGV4dCkuIFdlIHJlY3JlYXRlIHRoZSBwYXRjaGVzIG9uZSBieSBvbmUgdG8gZGV0ZXJtaW5lXG4gICAgICAgIC8vIGNvbnRleHQgaW5mby5cbiAgICAgICAgdmFyIHByZXBhdGNoVGV4dCA9IHRleHQxO1xuICAgICAgICB2YXIgcG9zdHBhdGNoVGV4dCA9IHRleHQxO1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICB2YXIgZGlmZlR5cGUgPSBkaWZmc1t4XVswXTtcbiAgICAgICAgICAgIHZhciBkaWZmVGV4dCA9IGRpZmZzW3hdWzFdO1xuICAgICAgICAgICAgaWYgKCFwYXRjaERpZmZMZW5ndGggJiYgZGlmZlR5cGUgIT09IERpZmZPcGVyYXRpb24uRElGRl9FUVVBTCkge1xuICAgICAgICAgICAgICAgIC8vIEEgbmV3IHBhdGNoIHN0YXJ0cyBoZXJlLlxuICAgICAgICAgICAgICAgIHBhdGNoLnN0YXJ0MSA9IGNoYXJDb3VudDE7XG4gICAgICAgICAgICAgICAgcGF0Y2guc3RhcnQyID0gY2hhckNvdW50MjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoZGlmZlR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIERpZmZPcGVyYXRpb24uRElGRl9JTlNFUlQ6XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoRGlmZkxlbmd0aCsrXSA9IGRpZmZzW3hdO1xuICAgICAgICAgICAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcG9zdHBhdGNoVGV4dCA9IHBvc3RwYXRjaFRleHQuc3Vic3RyaW5nKDAsIGNoYXJDb3VudDIpXG4gICAgICAgICAgICAgICAgICAgICAgICArIGRpZmZUZXh0ICsgcG9zdHBhdGNoVGV4dC5zdWJzdHJpbmcoY2hhckNvdW50Mik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRGlmZk9wZXJhdGlvbi5ESUZGX0RFTEVURTpcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2gubGVuZ3RoMSArPSBkaWZmVGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoRGlmZkxlbmd0aCsrXSA9IGRpZmZzW3hdO1xuICAgICAgICAgICAgICAgICAgICBwb3N0cGF0Y2hUZXh0ID0gcG9zdHBhdGNoVGV4dC5zdWJzdHJpbmcoMCwgY2hhckNvdW50MilcbiAgICAgICAgICAgICAgICAgICAgICAgICsgcG9zdHBhdGNoVGV4dC5zdWJzdHJpbmcoY2hhckNvdW50MiArIGRpZmZUZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRGlmZk9wZXJhdGlvbi5ESUZGX0VRVUFMOlxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZlRleHQubGVuZ3RoIDw9IDIgKiB0aGlzLnBhdGNoTWFyZ2luICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaERpZmZMZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZzLmxlbmd0aCAhPT0geCArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNtYWxsIGVxdWFsaXR5IGluc2lkZSBhIHBhdGNoLlxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2guZGlmZnNbcGF0Y2hEaWZmTGVuZ3RoKytdID0gZGlmZnNbeF07XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaC5sZW5ndGgxICs9IGRpZmZUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gZGlmZlRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRpZmZUZXh0Lmxlbmd0aCA+PSAyICogdGhpcy5wYXRjaE1hcmdpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGltZSBmb3IgYSBuZXcgcGF0Y2guXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF0Y2hEaWZmTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRjaF9hZGRDb250ZXh0XyhwYXRjaCwgcHJlcGF0Y2hUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2gocGF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoID0gbmV3IFBhdGNoT2JqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2hEaWZmTGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVbmxpa2UgVW5pZGlmZiwgb3VyIHBhdGNoIGxpc3RzIGhhdmUgYSByb2xsaW5nIGNvbnRleHQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9kaWZmLW1hdGNoLXBhdGNoL3dpa2kvVW5pZGlmZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBwcmVwYXRjaCB0ZXh0ICYgcG9zIHRvIHJlZmxlY3QgdGhlIGFwcGxpY2F0aW9uIG9mIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgY29tcGxldGVkIHBhdGNoLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXBhdGNoVGV4dCA9IHBvc3RwYXRjaFRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNvdW50MSA9IGNoYXJDb3VudDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGNvdW50LlxuICAgICAgICAgICAgaWYgKGRpZmZUeXBlICE9PSBEaWZmT3BlcmF0aW9uLkRJRkZfSU5TRVJUKSB7XG4gICAgICAgICAgICAgICAgY2hhckNvdW50MSArPSBkaWZmVGV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlmZlR5cGUgIT09IERpZmZPcGVyYXRpb24uRElGRl9ERUxFVEUpIHtcbiAgICAgICAgICAgICAgICBjaGFyQ291bnQyICs9IGRpZmZUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBQaWNrIHVwIHRoZSBsZWZ0b3ZlciBwYXRjaCBpZiBub3QgZW1wdHkuXG4gICAgICAgIGlmIChwYXRjaERpZmZMZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucGF0Y2hfYWRkQ29udGV4dF8ocGF0Y2gsIHByZXBhdGNoVGV4dCk7XG4gICAgICAgICAgICBwYXRjaGVzLnB1c2gocGF0Y2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRjaGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYW4gYXJyYXkgb2YgcGF0Y2hlcywgcmV0dXJuIGFub3RoZXIgYXJyYXkgdGhhdCBpcyBpZGVudGljYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhdGNoT2JqZWN0W10+fSBwYXRjaGVzIEFycmF5IG9mIFBhdGNoIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge1BhdGNoT2JqZWN0W119IEFycmF5IG9mIFBhdGNoIG9iamVjdHMuXG4gICAgICovXG4gICAgRGlmZk1hdGNoUGF0Y2gucHJvdG90eXBlLnBhdGNoX2RlZXBDb3B5ID0gZnVuY3Rpb24gKHBhdGNoZXMpIHtcbiAgICAgICAgLy8gTWFraW5nIGRlZXAgY29waWVzIGlzIGhhcmQgaW4gSmF2YVNjcmlwdC5cbiAgICAgICAgdmFyIHBhdGNoZXNDb3B5ID0gW107XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgdmFyIHBhdGNoID0gcGF0Y2hlc1t4XTtcbiAgICAgICAgICAgIHZhciBwYXRjaENvcHkgPSBuZXcgUGF0Y2hPYmplY3QoKTtcbiAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgcGF0Y2guZGlmZnMubGVuZ3RoOyB5KyspIHtcbiAgICAgICAgICAgICAgICBwYXRjaENvcHkuZGlmZnNbeV0gPSBbcGF0Y2guZGlmZnNbeV1bMF0sIHBhdGNoLmRpZmZzW3ldWzFdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGNoQ29weS5zdGFydDEgPSBwYXRjaC5zdGFydDE7XG4gICAgICAgICAgICBwYXRjaENvcHkuc3RhcnQyID0gcGF0Y2guc3RhcnQyO1xuICAgICAgICAgICAgcGF0Y2hDb3B5Lmxlbmd0aDEgPSBwYXRjaC5sZW5ndGgxO1xuICAgICAgICAgICAgcGF0Y2hDb3B5Lmxlbmd0aDIgPSBwYXRjaC5sZW5ndGgyO1xuICAgICAgICAgICAgcGF0Y2hlc0NvcHlbeF0gPSBwYXRjaENvcHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGNoZXNDb3B5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWVyZ2UgYSBzZXQgb2YgcGF0Y2hlcyBvbnRvIHRoZSB0ZXh0LiBSZXR1cm4gYSBwYXRjaGVkIHRleHQsIGFzIHdlbGxcbiAgICAgKiBhcyBhIGxpc3Qgb2YgdHJ1ZS9mYWxzZSB2YWx1ZXMgaW5kaWNhdGluZyB3aGljaCBwYXRjaGVzIHdlcmUgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGF0Y2hPYmplY3RbXX0gcGF0Y2hlcyBBcnJheSBvZiBQYXRjaCBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IE9sZCB0ZXh0LlxuICAgICAqIEByZXR1cm5zIHtQYXRjaEFwcGx5QXJyYXl9IFR3byBlbGVtZW50IEFycmF5LCBjb250YWluaW5nIHRoZVxuICAgICAqIG5ldyB0ZXh0IGFuZCBhbiBhcnJheSBvZiBib29sZWFuIHZhbHVlcy5cbiAgICAgKi9cbiAgICBEaWZmTWF0Y2hQYXRjaC5wcm90b3R5cGUucGF0Y2hfYXBwbHkgPSBmdW5jdGlvbiAocGF0Y2hlcywgdGV4dCkge1xuICAgICAgICBpZiAocGF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbdGV4dCwgW11dO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlZXAgY29weSB0aGUgcGF0Y2hlcyBzbyB0aGF0IG5vIGNoYW5nZXMgYXJlIG1hZGUgdG8gb3JpZ2luYWxzLlxuICAgICAgICBwYXRjaGVzID0gdGhpcy5wYXRjaF9kZWVwQ29weShwYXRjaGVzKTtcbiAgICAgICAgdmFyIG51bGxQYWRkaW5nID0gdGhpcy5wYXRjaF9hZGRQYWRkaW5nKHBhdGNoZXMpO1xuICAgICAgICB0ZXh0ID0gbnVsbFBhZGRpbmcgKyB0ZXh0ICsgbnVsbFBhZGRpbmc7XG4gICAgICAgIHRoaXMucGF0Y2hfc3BsaXRNYXgocGF0Y2hlcyk7XG4gICAgICAgIC8vIGRlbHRhIGtlZXBzIHRyYWNrIG9mIHRoZSBvZmZzZXQgYmV0d2VlbiB0aGUgZXhwZWN0ZWQgYW5kIGFjdHVhbCBsb2NhdGlvblxuICAgICAgICAvLyBvZiB0aGUgcHJldmlvdXMgcGF0Y2guIElmIHRoZXJlIGFyZSBwYXRjaGVzIGV4cGVjdGVkIGF0IHBvc2l0aW9ucyAxMCBhbmRcbiAgICAgICAgLy8gMjAsIGJ1dCB0aGUgZmlyc3QgcGF0Y2ggd2FzIGZvdW5kIGF0IDEyLCBkZWx0YSBpcyAyIGFuZCB0aGUgc2Vjb25kIHBhdGNoXG4gICAgICAgIC8vIGhhcyBhbiBlZmZlY3RpdmUgZXhwZWN0ZWQgcG9zaXRpb24gb2YgMjIuXG4gICAgICAgIHZhciBkZWx0YSA9IDA7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgdmFyIGV4cGVjdGVkTG9jID0gcGF0Y2hlc1t4XS5zdGFydDIgKyBkZWx0YTtcbiAgICAgICAgICAgIHZhciB0ZXh0MSA9IHRoaXMuZGlmZl90ZXh0MShwYXRjaGVzW3hdLmRpZmZzKTtcbiAgICAgICAgICAgIHZhciBzdGFydExvYyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBlbmRMb2MgPSAtMTtcbiAgICAgICAgICAgIGlmICh0ZXh0MS5sZW5ndGggPiB0aGlzLm1hdGNoTWF4Qml0cykge1xuICAgICAgICAgICAgICAgIC8vIHBhdGNoX3NwbGl0TWF4IHdpbGwgb25seSBwcm92aWRlIGFuIG92ZXJzaXplZCBwYXR0ZXJuIGluIHRoZSBjYXNlIG9mXG4gICAgICAgICAgICAgICAgLy8gYSBtb25zdGVyIGRlbGV0ZS5cbiAgICAgICAgICAgICAgICBzdGFydExvYyA9IHRoaXMubWF0Y2hfbWFpbih0ZXh0LCB0ZXh0MS5zdWJzdHJpbmcoMCwgdGhpcy5tYXRjaE1heEJpdHMpLCBleHBlY3RlZExvYyk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0TG9jICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBlbmRMb2MgPSB0aGlzLm1hdGNoX21haW4odGV4dCwgdGV4dDEuc3Vic3RyaW5nKHRleHQxLmxlbmd0aCAtIHRoaXMubWF0Y2hNYXhCaXRzKSwgZXhwZWN0ZWRMb2MgKyB0ZXh0MS5sZW5ndGggLSB0aGlzLm1hdGNoTWF4Qml0cyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmRMb2MgPT09IC0xIHx8IHN0YXJ0TG9jID49IGVuZExvYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FuJ3QgZmluZCB2YWxpZCB0cmFpbGluZyBjb250ZXh0LiBEcm9wIHRoaXMgcGF0Y2guXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydExvYyA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnRMb2MgPSB0aGlzLm1hdGNoX21haW4odGV4dCwgdGV4dDEsIGV4cGVjdGVkTG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydExvYyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBObyBtYXRjaCBmb3VuZC4gOihcbiAgICAgICAgICAgICAgICByZXN1bHRzW3hdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgdGhlIGRlbHRhIGZvciB0aGlzIGZhaWxlZCBwYXRjaCBmcm9tIHN1YnNlcXVlbnQgcGF0Y2hlcy5cbiAgICAgICAgICAgICAgICBkZWx0YSAtPSBwYXRjaGVzW3hdLmxlbmd0aDIgLSBwYXRjaGVzW3hdLmxlbmd0aDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGb3VuZCBhIG1hdGNoLiA6KVxuICAgICAgICAgICAgICAgIHJlc3VsdHNbeF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGRlbHRhID0gc3RhcnRMb2MgLSBleHBlY3RlZExvYztcbiAgICAgICAgICAgICAgICB2YXIgdGV4dDIgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKGVuZExvYyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDIgPSB0ZXh0LnN1YnN0cmluZyhzdGFydExvYywgc3RhcnRMb2MgKyB0ZXh0MS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDIgPSB0ZXh0LnN1YnN0cmluZyhzdGFydExvYywgZW5kTG9jICsgdGhpcy5tYXRjaE1heEJpdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGV4dDEgPT09IHRleHQyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBlcmZlY3QgbWF0Y2gsIGp1c3Qgc2hvdmUgdGhlIHJlcGxhY2VtZW50IHRleHQgaW4uXG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydExvYylcbiAgICAgICAgICAgICAgICAgICAgICAgICsgdGhpcy5kaWZmX3RleHQyKHBhdGNoZXNbeF0uZGlmZnMpXG4gICAgICAgICAgICAgICAgICAgICAgICArIHRleHQuc3Vic3RyaW5nKHN0YXJ0TG9jICsgdGV4dDEubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEltcGVyZmVjdCBtYXRjaC4gUnVuIGEgZGlmZiB0byBnZXQgYSBmcmFtZXdvcmsgb2YgZXF1aXZhbGVudFxuICAgICAgICAgICAgICAgICAgICAvLyBpbmRpY2VzLlxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlmZnMgPSB0aGlzLmRpZmZfbWFpbih0ZXh0MSwgdGV4dDIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQxLmxlbmd0aCA+IHRoaXMubWF0Y2hNYXhCaXRzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpZmZfbGV2ZW5zaHRlaW4oZGlmZnMpIC8gdGV4dDEubGVuZ3RoID4gdGhpcy5wYXRjaERlbGV0ZVRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGVuZCBwb2ludHMgbWF0Y2gsIGJ1dCB0aGUgY29udGVudCBpcyB1bmFjY2VwdGFibHkgYmFkLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1t4XSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaWZmX2NsZWFudXBTZW1hbnRpY0xvc3NsZXNzKGRpZmZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleDEgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4MiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHBhdGNoZXNbeF0uZGlmZnMubGVuZ3RoOyB5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW9kID0gcGF0Y2hlc1t4XS5kaWZmc1t5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kWzBdICE9PSBEaWZmT3BlcmF0aW9uLkRJRkZfRVFVQUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgyID0gdGhpcy5kaWZmX3hJbmRleChkaWZmcywgaW5kZXgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZFswXSA9PT0gRGlmZk9wZXJhdGlvbi5ESUZGX0lOU0VSVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnNlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0TG9jICsgaW5kZXgyKSArIG1vZFsxXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyB0ZXh0LnN1YnN0cmluZyhzdGFydExvYyArIGluZGV4Mik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vZFswXSA9PT0gRGlmZk9wZXJhdGlvbi5ESUZGX0RFTEVURSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWxldGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgc3RhcnRMb2MgKyBpbmRleDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIHRleHQuc3Vic3RyaW5nKHN0YXJ0TG9jXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyB0aGlzLmRpZmZfeEluZGV4KGRpZmZzLCBpbmRleDEgKyBtb2RbMV0ubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RbMF0gIT09IERpZmZPcGVyYXRpb24uRElGRl9ERUxFVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgxICs9IG1vZFsxXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFN0cmlwIHRoZSBwYWRkaW5nIG9mZi5cbiAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKG51bGxQYWRkaW5nLmxlbmd0aCwgdGV4dC5sZW5ndGggLSBudWxsUGFkZGluZy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gW3RleHQsIHJlc3VsdHNdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIHNvbWUgcGFkZGluZyBvbiB0ZXh0IHN0YXJ0IGFuZCBlbmQgc28gdGhhdCBlZGdlcyBjYW4gbWF0Y2ggc29tZXRoaW5nLlxuICAgICAqIEludGVuZGVkIHRvIGJlIGNhbGxlZCBvbmx5IGZyb20gd2l0aGluIHBhdGNoX2FwcGx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXRjaE9iamVjdFtdfSBwYXRjaGVzIEFycmF5IG9mIFBhdGNoIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHBhZGRpbmcgc3RyaW5nIGFkZGVkIHRvIGVhY2ggc2lkZS5cbiAgICAgKi9cbiAgICBEaWZmTWF0Y2hQYXRjaC5wcm90b3R5cGUucGF0Y2hfYWRkUGFkZGluZyA9IGZ1bmN0aW9uIChwYXRjaGVzKSB7XG4gICAgICAgIHZhciBwYWRkaW5nTGVuZ3RoID0gdGhpcy5wYXRjaE1hcmdpbjtcbiAgICAgICAgdmFyIG51bGxQYWRkaW5nID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgeCA9IDE7IHggPD0gcGFkZGluZ0xlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICBudWxsUGFkZGluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1bXAgYWxsIHRoZSBwYXRjaGVzIGZvcndhcmQuXG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgcGF0Y2hlc1t4XS5zdGFydDEgKz0gcGFkZGluZ0xlbmd0aDtcbiAgICAgICAgICAgIHBhdGNoZXNbeF0uc3RhcnQyICs9IHBhZGRpbmdMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHNvbWUgcGFkZGluZyBvbiBzdGFydCBvZiBmaXJzdCBkaWZmLlxuICAgICAgICB2YXIgcGF0Y2ggPSBwYXRjaGVzWzBdO1xuICAgICAgICB2YXIgZGlmZnMgPSBwYXRjaC5kaWZmcztcbiAgICAgICAgaWYgKGRpZmZzLmxlbmd0aCA9PT0gMCB8fCBkaWZmc1swXVswXSAhPT0gRGlmZk9wZXJhdGlvbi5ESUZGX0VRVUFMKSB7XG4gICAgICAgICAgICAvLyBBZGQgbnVsbFBhZGRpbmcgZXF1YWxpdHkuXG4gICAgICAgICAgICBkaWZmcy51bnNoaWZ0KFtEaWZmT3BlcmF0aW9uLkRJRkZfRVFVQUwsIG51bGxQYWRkaW5nXSk7XG4gICAgICAgICAgICBwYXRjaC5zdGFydDEgLT0gcGFkZGluZ0xlbmd0aDsgLy8gU2hvdWxkIGJlIDAuXG4gICAgICAgICAgICBwYXRjaC5zdGFydDIgLT0gcGFkZGluZ0xlbmd0aDsgLy8gU2hvdWxkIGJlIDAuXG4gICAgICAgICAgICBwYXRjaC5sZW5ndGgxICs9IHBhZGRpbmdMZW5ndGg7XG4gICAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IHBhZGRpbmdMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFkZGluZ0xlbmd0aCA+IGRpZmZzWzBdWzFdLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gR3JvdyBmaXJzdCBlcXVhbGl0eS5cbiAgICAgICAgICAgIHZhciBleHRyYUxlbmd0aCA9IHBhZGRpbmdMZW5ndGggLSBkaWZmc1swXVsxXS5sZW5ndGg7XG4gICAgICAgICAgICBkaWZmc1swXVsxXSA9IG51bGxQYWRkaW5nLnN1YnN0cmluZyhkaWZmc1swXVsxXS5sZW5ndGgpICsgZGlmZnNbMF1bMV07XG4gICAgICAgICAgICBwYXRjaC5zdGFydDEgLT0gZXh0cmFMZW5ndGg7XG4gICAgICAgICAgICBwYXRjaC5zdGFydDIgLT0gZXh0cmFMZW5ndGg7XG4gICAgICAgICAgICBwYXRjaC5sZW5ndGgxICs9IGV4dHJhTGVuZ3RoO1xuICAgICAgICAgICAgcGF0Y2gubGVuZ3RoMiArPSBleHRyYUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgc29tZSBwYWRkaW5nIG9uIGVuZCBvZiBsYXN0IGRpZmYuXG4gICAgICAgIHBhdGNoID0gcGF0Y2hlc1twYXRjaGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICBkaWZmcyA9IHBhdGNoLmRpZmZzO1xuICAgICAgICBpZiAoZGlmZnMubGVuZ3RoID09PSAwIHx8IGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzBdICE9PSBEaWZmT3BlcmF0aW9uLkRJRkZfRVFVQUwpIHtcbiAgICAgICAgICAgIC8vIEFkZCBudWxsUGFkZGluZyBlcXVhbGl0eS5cbiAgICAgICAgICAgIGRpZmZzLnB1c2goW0RpZmZPcGVyYXRpb24uRElGRl9FUVVBTCwgbnVsbFBhZGRpbmddKTtcbiAgICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gcGFkZGluZ0xlbmd0aDtcbiAgICAgICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gcGFkZGluZ0xlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYWRkaW5nTGVuZ3RoID4gZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBHcm93IGxhc3QgZXF1YWxpdHkuXG4gICAgICAgICAgICB2YXIgZXh0cmFMZW5ndGggPSBwYWRkaW5nTGVuZ3RoIC0gZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0ubGVuZ3RoO1xuICAgICAgICAgICAgZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0gKz0gbnVsbFBhZGRpbmcuc3Vic3RyaW5nKDAsIGV4dHJhTGVuZ3RoKTtcbiAgICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gZXh0cmFMZW5ndGg7XG4gICAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGV4dHJhTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsUGFkZGluZztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvb2sgdGhyb3VnaCB0aGUgcGF0Y2hlcyBhbmQgYnJlYWsgdXAgYW55IHdoaWNoIGFyZSBsb25nZXIgdGhhbiB0aGUgbWF4aW11bVxuICAgICAqIGxpbWl0IG9mIHRoZSBtYXRjaCBhbGdvcml0aG0uXG4gICAgICogSW50ZW5kZWQgdG8gYmUgY2FsbGVkIG9ubHkgZnJvbSB3aXRoaW4gcGF0Y2hfYXBwbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhdGNoT2JqZWN0W119IHBhdGNoZXMgQXJyYXkgb2YgUGF0Y2ggb2JqZWN0cy5cbiAgICAgKi9cbiAgICBEaWZmTWF0Y2hQYXRjaC5wcm90b3R5cGUucGF0Y2hfc3BsaXRNYXggPSBmdW5jdGlvbiAocGF0Y2hlcykge1xuICAgICAgICB2YXIgcGF0Y2hTaXplID0gdGhpcy5tYXRjaE1heEJpdHM7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgaWYgKHBhdGNoZXNbeF0ubGVuZ3RoMSA8PSBwYXRjaFNpemUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBiaWdwYXRjaCA9IHBhdGNoZXNbeF07XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGJpZyBvbGQgcGF0Y2guXG4gICAgICAgICAgICBwYXRjaGVzLnNwbGljZSh4LS0sIDEpO1xuICAgICAgICAgICAgdmFyIHN0YXJ0MSA9IGJpZ3BhdGNoLnN0YXJ0MTtcbiAgICAgICAgICAgIHZhciBzdGFydDIgPSBiaWdwYXRjaC5zdGFydDI7XG4gICAgICAgICAgICB2YXIgcHJlY29udGV4dCA9IFwiXCI7XG4gICAgICAgICAgICB3aGlsZSAoYmlncGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG9uZSBvZiBzZXZlcmFsIHNtYWxsZXIgcGF0Y2hlcy5cbiAgICAgICAgICAgICAgICB2YXIgcGF0Y2ggPSBuZXcgUGF0Y2hPYmplY3QoKTtcbiAgICAgICAgICAgICAgICB2YXIgZW1wdHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHBhdGNoLnN0YXJ0MSA9IHN0YXJ0MSAtIHByZWNvbnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHBhdGNoLnN0YXJ0MiA9IHN0YXJ0MiAtIHByZWNvbnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChwcmVjb250ZXh0ICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoLmxlbmd0aDEgPSBwYXRjaC5sZW5ndGgyID0gcHJlY29udGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW0RpZmZPcGVyYXRpb24uRElGRl9FUVVBTCwgcHJlY29udGV4dF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoYmlncGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoLmxlbmd0aDEgPCBwYXRjaFNpemUgLSB0aGlzLnBhdGNoTWFyZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaWZmVHlwZSA9IGJpZ3BhdGNoLmRpZmZzWzBdWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlmZlRleHQgPSBiaWdwYXRjaC5kaWZmc1swXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpZmZUeXBlID09PSBEaWZmT3BlcmF0aW9uLkRJRkZfSU5TRVJUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnNlcnRpb25zIGFyZSBoYXJtbGVzcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gZGlmZlRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQyICs9IGRpZmZUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goYmlncGF0Y2guZGlmZnMuc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRpZmZUeXBlID09PSBEaWZmT3BlcmF0aW9uLkRJRkZfREVMRVRFICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaC5kaWZmcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoLmRpZmZzWzBdWzBdID09PSBEaWZmT3BlcmF0aW9uLkRJRkZfRVFVQUwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZUZXh0Lmxlbmd0aCA+IDIgKiBwYXRjaFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBsYXJnZSBkZWxldGlvbi4gTGV0IGl0IHBhc3MgaW4gb25lIGNodW5rLlxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2gubGVuZ3RoMSArPSBkaWZmVGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDEgKz0gZGlmZlRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW2RpZmZUeXBlLCBkaWZmVGV4dF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmlncGF0Y2guZGlmZnMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlbGV0aW9uIG9yIGVxdWFsaXR5LiBPbmx5IHRha2UgYXMgbXVjaCBhcyB3ZSBjYW4gc3RvbWFjaC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZUZXh0ID0gZGlmZlRleHQuc3Vic3RyaW5nKDAsIHBhdGNoU2l6ZSAtIHBhdGNoLmxlbmd0aDEgLSB0aGlzLnBhdGNoTWFyZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gZGlmZlRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQxICs9IGRpZmZUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaWZmVHlwZSA9PT0gRGlmZk9wZXJhdGlvbi5ESUZGX0VRVUFMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2gubGVuZ3RoMiArPSBkaWZmVGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQyICs9IGRpZmZUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtkaWZmVHlwZSwgZGlmZlRleHRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaWZmVGV4dCA9PT0gYmlncGF0Y2guZGlmZnNbMF1bMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaWdwYXRjaC5kaWZmcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmlncGF0Y2guZGlmZnNbMF1bMV0gPSBiaWdwYXRjaC5kaWZmc1swXVsxXS5zdWJzdHJpbmcoZGlmZlRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBoZWFkIGNvbnRleHQgZm9yIHRoZSBuZXh0IHBhdGNoLlxuICAgICAgICAgICAgICAgIHByZWNvbnRleHQgPSB0aGlzLmRpZmZfdGV4dDIocGF0Y2guZGlmZnMpO1xuICAgICAgICAgICAgICAgIHByZWNvbnRleHQgPSBwcmVjb250ZXh0LnN1YnN0cmluZyhwcmVjb250ZXh0Lmxlbmd0aCAtIHRoaXMucGF0Y2hNYXJnaW4pO1xuICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgZW5kIGNvbnRleHQgZm9yIHRoaXMgcGF0Y2guXG4gICAgICAgICAgICAgICAgdmFyIHBvc3Rjb250ZXh0ID0gdGhpcy5kaWZmX3RleHQxKGJpZ3BhdGNoLmRpZmZzKS5zdWJzdHJpbmcoMCwgdGhpcy5wYXRjaE1hcmdpbik7XG4gICAgICAgICAgICAgICAgaWYgKHBvc3Rjb250ZXh0ICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gcG9zdGNvbnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IHBvc3Rjb250ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGNoLmRpZmZzLmxlbmd0aCAhPT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2guZGlmZnNbcGF0Y2guZGlmZnMubGVuZ3RoIC0gMV1bMF0gPT09IERpZmZPcGVyYXRpb24uRElGRl9FUVVBTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2guZGlmZnNbcGF0Y2guZGlmZnMubGVuZ3RoIC0gMV1bMV0gKz0gcG9zdGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtEaWZmT3BlcmF0aW9uLkRJRkZfRVFVQUwsIHBvc3Rjb250ZXh0XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFlbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICBwYXRjaGVzLnNwbGljZSgrK3gsIDAsIHBhdGNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRha2UgYSBsaXN0IG9mIHBhdGNoZXMgYW5kIHJldHVybiBhIHRleHR1YWwgcmVwcmVzZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhdGNoT2JqZWN0W119IHBhdGNoZXMgQXJyYXkgb2YgUGF0Y2ggb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUZXh0IHJlcHJlc2VudGF0aW9uIG9mIHBhdGNoZXMuXG4gICAgICovXG4gICAgRGlmZk1hdGNoUGF0Y2gucHJvdG90eXBlLnBhdGNoX3RvVGV4dCA9IGZ1bmN0aW9uIChwYXRjaGVzKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gW107XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgdGV4dFt4XSA9IHBhdGNoZXNbeF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQuam9pbihcIlwiKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBhcnNlIGEgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiBwYXRjaGVzIGFuZCByZXR1cm4gYSBsaXN0IG9mIFBhdGNoIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dGxpbmUgVGV4dCByZXByZXNlbnRhdGlvbiBvZiBwYXRjaGVzLlxuICAgICAqIEByZXR1cm5zIHtQYXRjaE9iamVjdFtdfSBBcnJheSBvZiBQYXRjaCBvYmplY3RzLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpbnZhbGlkIGlucHV0LlxuICAgICAqL1xuICAgIERpZmZNYXRjaFBhdGNoLnByb3RvdHlwZS5wYXRjaF9mcm9tVGV4dCA9IGZ1bmN0aW9uICh0ZXh0bGluZSkge1xuICAgICAgICB2YXIgcGF0Y2hlcyA9IFtdO1xuICAgICAgICBpZiAoIXRleHRsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0Y2hlcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGV4dCA9IHRleHRsaW5lLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICB2YXIgdGV4dFBvaW50ZXIgPSAwO1xuICAgICAgICB2YXIgcGF0Y2hIZWFkZXIgPSAvXkBAIC0oXFxkKyksPyhcXGQqKSBcXCsoXFxkKyksPyhcXGQqKSBAQCQvO1xuICAgICAgICB3aGlsZSAodGV4dFBvaW50ZXIgPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG0gPSB0ZXh0W3RleHRQb2ludGVyXS5tYXRjaChwYXRjaEhlYWRlcik7XG4gICAgICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBhdGNoIHN0cmluZzogXCIgKyB0ZXh0W3RleHRQb2ludGVyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGF0Y2ggPSBuZXcgUGF0Y2hPYmplY3QoKTtcbiAgICAgICAgICAgIHBhdGNoZXMucHVzaChwYXRjaCk7XG4gICAgICAgICAgICBwYXRjaC5zdGFydDEgPSBwYXJzZUludChtWzFdLCAxMCk7XG4gICAgICAgICAgICBpZiAobVsyXSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIHBhdGNoLnN0YXJ0MS0tO1xuICAgICAgICAgICAgICAgIHBhdGNoLmxlbmd0aDEgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobVsyXSA9PT0gXCIwXCIpIHtcbiAgICAgICAgICAgICAgICBwYXRjaC5sZW5ndGgxID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdGNoLnN0YXJ0MS0tO1xuICAgICAgICAgICAgICAgIHBhdGNoLmxlbmd0aDEgPSBwYXJzZUludChtWzJdLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRjaC5zdGFydDIgPSBwYXJzZUludChtWzNdLCAxMCk7XG4gICAgICAgICAgICBpZiAobVs0XSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIHBhdGNoLnN0YXJ0Mi0tO1xuICAgICAgICAgICAgICAgIHBhdGNoLmxlbmd0aDIgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobVs0XSA9PT0gXCIwXCIpIHtcbiAgICAgICAgICAgICAgICBwYXRjaC5sZW5ndGgyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdGNoLnN0YXJ0Mi0tO1xuICAgICAgICAgICAgICAgIHBhdGNoLmxlbmd0aDIgPSBwYXJzZUludChtWzRdLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0UG9pbnRlcisrO1xuICAgICAgICAgICAgdmFyIHNpZ24gPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgbGluZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciByYXdMaW5lID0gdm9pZCAwO1xuICAgICAgICAgICAgd2hpbGUgKHRleHRQb2ludGVyIDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzaWduID0gdGV4dFt0ZXh0UG9pbnRlcl0uY2hhckF0KDApO1xuICAgICAgICAgICAgICAgIHJhd0xpbmUgPSB0ZXh0W3RleHRQb2ludGVyXS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IGRlY29kZVVSSShyYXdMaW5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1hbGZvcm1lZCBVUkkgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgZXNjYXBlIGluIHBhdGNoX2Zyb21UZXh0OiBcIiArIHJhd0xpbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2lnbiA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRpb24uXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW0RpZmZPcGVyYXRpb24uRElGRl9ERUxFVEUsIGxpbmVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2lnbiA9PT0gXCIrXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5zZXJ0aW9uLlxuICAgICAgICAgICAgICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtEaWZmT3BlcmF0aW9uLkRJRkZfSU5TRVJULCBsaW5lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNpZ24gPT09IFwiIFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1pbm9yIGVxdWFsaXR5LlxuICAgICAgICAgICAgICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtEaWZmT3BlcmF0aW9uLkRJRkZfRVFVQUwsIGxpbmVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2lnbiA9PT0gXCJAXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgb2YgbmV4dCBwYXRjaC5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNpZ24gPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQmxhbmsgbGluZT8gIFdoYXRldmVyLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV1RGP1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGF0Y2ggbW9kZSBcIicgKyBzaWduICsgJ1wiIGluOiAnICsgbGluZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRleHRQb2ludGVyKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGNoZXM7XG4gICAgfTtcbiAgICAvLyNlbmRyZWdpb24gUEFUQ0ggRlVOQ1RJT05TIChwdWJsaWMpXG4gICAgLy8jcmVnaW9uIERJRkYgRlVOQ1RJT05TIChwcml2YXRlKVxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gdHdvIHRleHRzLiBBc3N1bWVzIHRoYXQgdGhlIHRleHRzIGRvIG5vdFxuICAgICAqIGhhdmUgYW55IGNvbW1vbiBwcmVmaXggb3Igc3VmZml4LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyB0byBiZSBkaWZmZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgdG8gYmUgZGlmZmVkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2hlY2tsaW5lcyBTcGVlZHVwIGZsYWcuIElmIGZhbHNlLCB0aGVuIGRvbid0IHJ1biBhXG4gICAgICogbGluZS1sZXZlbCBkaWZmIGZpcnN0IHRvIGlkZW50aWZ5IHRoZSBjaGFuZ2VkIGFyZWFzLlxuICAgICAqIElmIHRydWUsIHRoZW4gcnVuIGEgZmFzdGVyLCBzbGlnaHRseSBsZXNzIG9wdGltYWwgZGlmZi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVhZGxpbmUgVGltZSB3aGVuIHRoZSBkaWZmIHNob3VsZCBiZSBjb21wbGV0ZSBieS5cbiAgICAgKiBAcmV0dXJucyB7RGlmZltdfSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cbiAgICAgKi9cbiAgICBEaWZmTWF0Y2hQYXRjaC5wcm90b3R5cGUuZGlmZl9jb21wdXRlXyA9IGZ1bmN0aW9uICh0ZXh0MSwgdGV4dDIsIGNoZWNrbGluZXMsIGRlYWRsaW5lKSB7XG4gICAgICAgIHZhciBkaWZmcztcbiAgICAgICAgaWYgKCF0ZXh0MSkge1xuICAgICAgICAgICAgLy8gSnVzdCBhZGQgc29tZSB0ZXh0IChzcGVlZHVwKS5cbiAgICAgICAgICAgIHJldHVybiBbW0RpZmZPcGVyYXRpb24uRElGRl9JTlNFUlQsIHRleHQyXV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0ZXh0Mikge1xuICAgICAgICAgICAgLy8gSnVzdCBkZWxldGUgc29tZSB0ZXh0IChzcGVlZHVwKS5cbiAgICAgICAgICAgIHJldHVybiBbW0RpZmZPcGVyYXRpb24uRElGRl9ERUxFVEUsIHRleHQxXV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvbmd0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDEgOiB0ZXh0MjtcbiAgICAgICAgdmFyIHNob3J0dGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQyIDogdGV4dDE7XG4gICAgICAgIHZhciBpID0gbG9uZ3RleHQuaW5kZXhPZihzaG9ydHRleHQpO1xuICAgICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIFNob3J0ZXIgdGV4dCBpcyBpbnNpZGUgdGhlIGxvbmdlciB0ZXh0IChzcGVlZHVwKS5cbiAgICAgICAgICAgIGRpZmZzID0gW1xuICAgICAgICAgICAgICAgIFtEaWZmT3BlcmF0aW9uLkRJRkZfSU5TRVJULCBsb25ndGV4dC5zdWJzdHJpbmcoMCwgaSldLFxuICAgICAgICAgICAgICAgIFtEaWZmT3BlcmF0aW9uLkRJRkZfRVFVQUwsIHNob3J0dGV4dF0sXG4gICAgICAgICAgICAgICAgW0RpZmZPcGVyYXRpb24uRElGRl9JTlNFUlQsIGxvbmd0ZXh0LnN1YnN0cmluZyhpICsgc2hvcnR0ZXh0Lmxlbmd0aCldXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgLy8gU3dhcCBpbnNlcnRpb25zIGZvciBkZWxldGlvbnMgaWYgZGlmZiBpcyByZXZlcnNlZC5cbiAgICAgICAgICAgIGlmICh0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkaWZmc1swXVswXSA9IERpZmZPcGVyYXRpb24uRElGRl9ERUxFVEU7XG4gICAgICAgICAgICAgICAgZGlmZnNbMl1bMF0gPSBEaWZmT3BlcmF0aW9uLkRJRkZfREVMRVRFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRpZmZzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG9ydHRleHQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAvLyBTaW5nbGUgY2hhcmFjdGVyIHN0cmluZy5cbiAgICAgICAgICAgIC8vIEFmdGVyIHRoZSBwcmV2aW91cyBzcGVlZHVwLCB0aGUgY2hhcmFjdGVyIGNhbid0IGJlIGFuIGVxdWFsaXR5LlxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBbRGlmZk9wZXJhdGlvbi5ESUZGX0RFTEVURSwgdGV4dDFdLFxuICAgICAgICAgICAgICAgIFtEaWZmT3BlcmF0aW9uLkRJRkZfSU5TRVJULCB0ZXh0Ml1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBwcm9ibGVtIGNhbiBiZSBzcGxpdCBpbiB0d28uXG4gICAgICAgIHZhciBobSA9IHRoaXMuZGlmZl9oYWxmTWF0Y2hfKHRleHQxLCB0ZXh0Mik7XG4gICAgICAgIGlmIChobSkge1xuICAgICAgICAgICAgLy8gQSBoYWxmLW1hdGNoIHdhcyBmb3VuZCwgc29ydCBvdXQgdGhlIHJldHVybiBkYXRhLlxuICAgICAgICAgICAgdmFyIHRleHQxQSA9IGhtWzBdO1xuICAgICAgICAgICAgdmFyIHRleHQxQiA9IGhtWzFdO1xuICAgICAgICAgICAgdmFyIHRleHQyQSA9IGhtWzJdO1xuICAgICAgICAgICAgdmFyIHRleHQyQiA9IGhtWzNdO1xuICAgICAgICAgICAgdmFyIG1pZENvbW1vbiA9IGhtWzRdO1xuICAgICAgICAgICAgLy8gU2VuZCBib3RoIHBhaXJzIG9mZiBmb3Igc2VwYXJhdGUgcHJvY2Vzc2luZy5cbiAgICAgICAgICAgIHZhciBkaWZmc0EgPSB0aGlzLmRpZmZfbWFpbih0ZXh0MUEsIHRleHQyQSwgY2hlY2tsaW5lcywgZGVhZGxpbmUpO1xuICAgICAgICAgICAgdmFyIGRpZmZzQiA9IHRoaXMuZGlmZl9tYWluKHRleHQxQiwgdGV4dDJCLCBjaGVja2xpbmVzLCBkZWFkbGluZSk7XG4gICAgICAgICAgICAvLyBNZXJnZSB0aGUgcmVzdWx0cy5cbiAgICAgICAgICAgIHJldHVybiBkaWZmc0EuY29uY2F0KFtbRGlmZk9wZXJhdGlvbi5ESUZGX0VRVUFMLCBtaWRDb21tb25dXSwgZGlmZnNCKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hlY2tsaW5lcyAmJiB0ZXh0MS5sZW5ndGggPiAxMDAgJiYgdGV4dDIubGVuZ3RoID4gMTAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaWZmX2xpbmVNb2RlXyh0ZXh0MSwgdGV4dDIsIGRlYWRsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kaWZmX2Jpc2VjdF8odGV4dDEsIHRleHQyLCBkZWFkbGluZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEbyBhIHF1aWNrIGxpbmUtbGV2ZWwgZGlmZiBvbiBib3RoIHN0cmluZ3MsIHRoZW4gcmUtZGlmZiB0aGUgcGFydHMgZm9yXG4gICAgICogZ3JlYXRlciBhY2N1cmFjeS5cbiAgICAgKiBUaGlzIHNwZWVkdXAgY2FuIHByb2R1Y2Ugbm9uLW1pbmltYWwgZGlmZnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIHRvIGJlIGRpZmZlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlYWRsaW5lIFRpbWUgd2hlbiB0aGUgZGlmZiBzaG91bGQgYmUgY29tcGxldGUgYnkuXG4gICAgICogQHJldHVybnMge0RpZmZbXX0gQXJyYXkgb2YgZGlmZiB0dXBsZXMuXG4gICAgICovXG4gICAgRGlmZk1hdGNoUGF0Y2gucHJvdG90eXBlLmRpZmZfbGluZU1vZGVfID0gZnVuY3Rpb24gKHRleHQxLCB0ZXh0MiwgZGVhZGxpbmUpIHtcbiAgICAgICAgLy8gU2NhbiB0aGUgdGV4dCBvbiBhIGxpbmUtYnktbGluZSBiYXNpcyBmaXJzdC5cbiAgICAgICAgdmFyIGEgPSB0aGlzLmRpZmZfbGluZXNUb0NoYXJzXyh0ZXh0MSwgdGV4dDIpO1xuICAgICAgICB0ZXh0MSA9IGEuY2hhcnMxO1xuICAgICAgICB0ZXh0MiA9IGEuY2hhcnMyO1xuICAgICAgICB2YXIgbGluZWFycmF5ID0gYS5saW5lQXJyYXk7XG4gICAgICAgIHZhciBkaWZmcyA9IHRoaXMuZGlmZl9tYWluKHRleHQxLCB0ZXh0MiwgZmFsc2UsIGRlYWRsaW5lKTtcbiAgICAgICAgLy8gQ29udmVydCB0aGUgZGlmZiBiYWNrIHRvIG9yaWdpbmFsIHRleHQuXG4gICAgICAgIHRoaXMuZGlmZl9jaGFyc1RvTGluZXNfKGRpZmZzLCBsaW5lYXJyYXkpO1xuICAgICAgICAvLyBFbGltaW5hdGUgZnJlYWsgbWF0Y2hlcyAoZS5nLiBibGFuayBsaW5lcylcbiAgICAgICAgdGhpcy5kaWZmX2NsZWFudXBTZW1hbnRpYyhkaWZmcyk7XG4gICAgICAgIC8vIFJlLWRpZmYgYW55IHJlcGxhY2VtZW50IGJsb2NrcywgdGhpcyB0aW1lIGNoYXJhY3Rlci1ieS1jaGFyYWN0ZXIuXG4gICAgICAgIC8vIEFkZCBhIGR1bW15IGVudHJ5IGF0IHRoZSBlbmQuXG4gICAgICAgIGRpZmZzLnB1c2goW0RpZmZPcGVyYXRpb24uRElGRl9FUVVBTCwgXCJcIl0pO1xuICAgICAgICB2YXIgcG9pbnRlciA9IDA7XG4gICAgICAgIHZhciBjb3VudERlbGV0ZSA9IDA7XG4gICAgICAgIHZhciBjb3VudEluc2VydCA9IDA7XG4gICAgICAgIHZhciB0ZXh0RGVsZXRlID0gXCJcIjtcbiAgICAgICAgdmFyIHRleHRJbnNlcnQgPSBcIlwiO1xuICAgICAgICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3dpdGNoIChkaWZmc1twb2ludGVyXVswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgRGlmZk9wZXJhdGlvbi5ESUZGX0lOU0VSVDpcbiAgICAgICAgICAgICAgICAgICAgY291bnRJbnNlcnQrKztcbiAgICAgICAgICAgICAgICAgICAgdGV4dEluc2VydCArPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBEaWZmT3BlcmF0aW9uLkRJRkZfREVMRVRFOlxuICAgICAgICAgICAgICAgICAgICBjb3VudERlbGV0ZSsrO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0RGVsZXRlICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIERpZmZPcGVyYXRpb24uRElGRl9FUVVBTDpcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBvbiByZWFjaGluZyBhbiBlcXVhbGl0eSwgY2hlY2sgZm9yIHByaW9yIHJlZHVuZGFuY2llcy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50RGVsZXRlID49IDEgJiYgY291bnRJbnNlcnQgPj0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIHRoZSBvZmZlbmRpbmcgcmVjb3JkcyBhbmQgYWRkIHRoZSBtZXJnZWQgb25lcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gY291bnREZWxldGUgLSBjb3VudEluc2VydCwgY291bnREZWxldGUgKyBjb3VudEluc2VydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyID0gcG9pbnRlciAtIGNvdW50RGVsZXRlIC0gY291bnRJbnNlcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ViRGlmZiA9IHRoaXMuZGlmZl9tYWluKHRleHREZWxldGUsIHRleHRJbnNlcnQsIGZhbHNlLCBkZWFkbGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gc3ViRGlmZi5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBzdWJEaWZmW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXIgPSBwb2ludGVyICsgc3ViRGlmZi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRJbnNlcnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudERlbGV0ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRleHREZWxldGUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0SW5zZXJ0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBkdW1teSBlbnRyeSBhdCB0aGUgZW5kLlxuICAgICAgICBkaWZmcy5wb3AoKTtcbiAgICAgICAgcmV0dXJuIGRpZmZzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgJ21pZGRsZSBzbmFrZScgb2YgYSBkaWZmLCBzcGxpdCB0aGUgcHJvYmxlbSBpbiB0d29cbiAgICAgKiBhbmQgcmV0dXJuIHRoZSByZWN1cnNpdmVseSBjb25zdHJ1Y3RlZCBkaWZmLlxuICAgICAqIFNlZSBNeWVycyAxOTg2IHBhcGVyOiBBbiBPKE5EKSBEaWZmZXJlbmNlIEFsZ29yaXRobSBhbmQgSXRzIFZhcmlhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIHRvIGJlIGRpZmZlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlYWRsaW5lIFRpbWUgYXQgd2hpY2ggdG8gYmFpbCBpZiBub3QgeWV0IGNvbXBsZXRlLlxuICAgICAqIEByZXR1cm5zIHtEaWZmW119IEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICAgICAqL1xuICAgIERpZmZNYXRjaFBhdGNoLnByb3RvdHlwZS5kaWZmX2Jpc2VjdF8gPSBmdW5jdGlvbiAodGV4dDEsIHRleHQyLCBkZWFkbGluZSkge1xuICAgICAgICAvLyBDYWNoZSB0aGUgdGV4dCBsZW5ndGhzIHRvIHByZXZlbnQgbXVsdGlwbGUgY2FsbHMuXG4gICAgICAgIHZhciB0ZXh0MUxlbmd0aCA9IHRleHQxLmxlbmd0aDtcbiAgICAgICAgdmFyIHRleHQyTGVuZ3RoID0gdGV4dDIubGVuZ3RoO1xuICAgICAgICB2YXIgbWF4RCA9IE1hdGguY2VpbCgodGV4dDFMZW5ndGggKyB0ZXh0Mkxlbmd0aCkgLyAyKTtcbiAgICAgICAgdmFyIHZPZmZzZXQgPSBtYXhEO1xuICAgICAgICB2YXIgdkxlbmd0aCA9IDIgKiBtYXhEO1xuICAgICAgICB2YXIgdjEgPSBuZXcgQXJyYXkodkxlbmd0aCk7XG4gICAgICAgIHZhciB2MiA9IG5ldyBBcnJheSh2TGVuZ3RoKTtcbiAgICAgICAgLy8gU2V0dGluZyBhbGwgZWxlbWVudHMgdG8gLTEgaXMgZmFzdGVyIGluIENocm9tZSAmIEZpcmVmb3ggdGhhbiBtaXhpbmdcbiAgICAgICAgLy8gaW50ZWdlcnMgYW5kIHVuZGVmaW5lZC5cbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB2TGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAgIHYxW3hdID0gLTE7XG4gICAgICAgICAgICB2Mlt4XSA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHYxW3ZPZmZzZXQgKyAxXSA9IDA7XG4gICAgICAgIHYyW3ZPZmZzZXQgKyAxXSA9IDA7XG4gICAgICAgIHZhciBkZWx0YSA9IHRleHQxTGVuZ3RoIC0gdGV4dDJMZW5ndGg7XG4gICAgICAgIC8vIElmIHRoZSB0b3RhbCBudW1iZXIgb2YgY2hhcmFjdGVycyBpcyBvZGQsIHRoZW4gdGhlIGZyb250IHBhdGggd2lsbCBjb2xsaWRlXG4gICAgICAgIC8vIHdpdGggdGhlIHJldmVyc2UgcGF0aC5cbiAgICAgICAgdmFyIGZyb250ID0gKGRlbHRhICUgMiAhPT0gMCk7XG4gICAgICAgIC8vIE9mZnNldHMgZm9yIHN0YXJ0IGFuZCBlbmQgb2YgayBsb29wLlxuICAgICAgICAvLyBQcmV2ZW50cyBtYXBwaW5nIG9mIHNwYWNlIGJleW9uZCB0aGUgZ3JpZC5cbiAgICAgICAgdmFyIGsxU3RhcnQgPSAwO1xuICAgICAgICB2YXIgazFFbmQgPSAwO1xuICAgICAgICB2YXIgazJTdGFydCA9IDA7XG4gICAgICAgIHZhciBrMkVuZCA9IDA7XG4gICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgbWF4RDsgZCsrKSB7XG4gICAgICAgICAgICAvLyBCYWlsIG91dCBpZiBkZWFkbGluZSBpcyByZWFjaGVkLlxuICAgICAgICAgICAgaWYgKERhdGUubm93KCkgPiBkZWFkbGluZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2FsayB0aGUgZnJvbnQgcGF0aCBvbmUgc3RlcC5cbiAgICAgICAgICAgIGZvciAodmFyIGsxID0gLWQgKyBrMVN0YXJ0OyBrMSA8PSBkIC0gazFFbmQ7IGsxICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgazFPZmZzZXQgPSB2T2Zmc2V0ICsgazE7XG4gICAgICAgICAgICAgICAgdmFyIHgxID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmIChrMSA9PT0gLWQgfHwgKGsxICE9PSBkICYmIHYxW2sxT2Zmc2V0IC0gMV0gPCB2MVtrMU9mZnNldCArIDFdKSkge1xuICAgICAgICAgICAgICAgICAgICB4MSA9IHYxW2sxT2Zmc2V0ICsgMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB4MSA9IHYxW2sxT2Zmc2V0IC0gMV0gKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgeTEgPSB4MSAtIGsxO1xuICAgICAgICAgICAgICAgIHdoaWxlICh4MSA8IHRleHQxTGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICYmIHkxIDwgdGV4dDJMZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgJiYgdGV4dDEuY2hhckF0KHgxKSA9PT0gdGV4dDIuY2hhckF0KHkxKSkge1xuICAgICAgICAgICAgICAgICAgICB4MSsrO1xuICAgICAgICAgICAgICAgICAgICB5MSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2MVtrMU9mZnNldF0gPSB4MTtcbiAgICAgICAgICAgICAgICBpZiAoeDEgPiB0ZXh0MUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSYW4gb2ZmIHRoZSByaWdodCBvZiB0aGUgZ3JhcGguXG4gICAgICAgICAgICAgICAgICAgIGsxRW5kICs9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHkxID4gdGV4dDJMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmFuIG9mZiB0aGUgYm90dG9tIG9mIHRoZSBncmFwaC5cbiAgICAgICAgICAgICAgICAgICAgazFTdGFydCArPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmcm9udCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgazJPZmZzZXQgPSB2T2Zmc2V0ICsgZGVsdGEgLSBrMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGsyT2Zmc2V0ID49IDAgJiYgazJPZmZzZXQgPCB2TGVuZ3RoICYmIHYyW2syT2Zmc2V0XSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1pcnJvciB4MiBvbnRvIHRvcC1sZWZ0IGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHgyID0gdGV4dDFMZW5ndGggLSB2MltrMk9mZnNldF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeDEgPj0geDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdmVybGFwIGRldGVjdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRpZmZfYmlzZWN0U3BsaXRfKHRleHQxLCB0ZXh0MiwgeDEsIHkxLCBkZWFkbGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXYWxrIHRoZSByZXZlcnNlIHBhdGggb25lIHN0ZXAuXG4gICAgICAgICAgICBmb3IgKHZhciBrMiA9IC1kICsgazJTdGFydDsgazIgPD0gZCAtIGsyRW5kOyBrMiArPSAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGsyT2Zmc2V0ID0gdk9mZnNldCArIGsyO1xuICAgICAgICAgICAgICAgIHZhciB4MiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAoazIgPT09IC1kIHx8IChrMiAhPT0gZCAmJiB2MltrMk9mZnNldCAtIDFdIDwgdjJbazJPZmZzZXQgKyAxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgeDIgPSB2MltrMk9mZnNldCArIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeDIgPSB2MltrMk9mZnNldCAtIDFdICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHkyID0geDIgLSBrMjtcbiAgICAgICAgICAgICAgICB3aGlsZSAoeDIgPCB0ZXh0MUxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAmJiB5MiA8IHRleHQyTGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICYmIHRleHQxLmNoYXJBdCh0ZXh0MUxlbmd0aCAtIHgyIC0gMSkgPT09IHRleHQyLmNoYXJBdCh0ZXh0Mkxlbmd0aCAtIHkyIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgeDIrKztcbiAgICAgICAgICAgICAgICAgICAgeTIrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdjJbazJPZmZzZXRdID0geDI7XG4gICAgICAgICAgICAgICAgaWYgKHgyID4gdGV4dDFMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmFuIG9mZiB0aGUgbGVmdCBvZiB0aGUgZ3JhcGguXG4gICAgICAgICAgICAgICAgICAgIGsyRW5kICs9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHkyID4gdGV4dDJMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmFuIG9mZiB0aGUgdG9wIG9mIHRoZSBncmFwaC5cbiAgICAgICAgICAgICAgICAgICAgazJTdGFydCArPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghZnJvbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGsxT2Zmc2V0ID0gdk9mZnNldCArIGRlbHRhIC0gazI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrMU9mZnNldCA+PSAwICYmIGsxT2Zmc2V0IDwgdkxlbmd0aCAmJiB2MVtrMU9mZnNldF0gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeDEgPSB2MVtrMU9mZnNldF07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeTEgPSB2T2Zmc2V0ICsgeDEgLSBrMU9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1pcnJvciB4MiBvbnRvIHRvcC1sZWZ0IGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSB0ZXh0MUxlbmd0aCAtIHgyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHgxID49IHgyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3ZlcmxhcCBkZXRlY3RlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kaWZmX2Jpc2VjdFNwbGl0Xyh0ZXh0MSwgdGV4dDIsIHgxLCB5MSwgZGVhZGxpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIERpZmYgdG9vayB0b28gbG9uZyBhbmQgaGl0IHRoZSBkZWFkbGluZSBvclxuICAgICAgICAvLyBudW1iZXIgb2YgZGlmZnMgZXF1YWxzIG51bWJlciBvZiBjaGFyYWN0ZXJzLCBubyBjb21tb25hbGl0eSBhdCBhbGwuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBbRGlmZk9wZXJhdGlvbi5ESUZGX0RFTEVURSwgdGV4dDFdLFxuICAgICAgICAgICAgW0RpZmZPcGVyYXRpb24uRElGRl9JTlNFUlQsIHRleHQyXVxuICAgICAgICBdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gdGhlIGxvY2F0aW9uIG9mIHRoZSAnbWlkZGxlIHNuYWtlJywgc3BsaXQgdGhlIGRpZmYgaW4gdHdvIHBhcnRzXG4gICAgICogYW5kIHJlY3Vyc2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIHRvIGJlIGRpZmZlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggSW5kZXggb2Ygc3BsaXQgcG9pbnQgaW4gdGV4dDEuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgSW5kZXggb2Ygc3BsaXQgcG9pbnQgaW4gdGV4dDIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlYWRsaW5lIFRpbWUgYXQgd2hpY2ggdG8gYmFpbCBpZiBub3QgeWV0IGNvbXBsZXRlLlxuICAgICAqIEByZXR1cm5zIHtEaWZmW119IEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICAgICAqL1xuICAgIERpZmZNYXRjaFBhdGNoLnByb3RvdHlwZS5kaWZmX2Jpc2VjdFNwbGl0XyA9IGZ1bmN0aW9uICh0ZXh0MSwgdGV4dDIsIHgsIHksIGRlYWRsaW5lKSB7XG4gICAgICAgIHZhciB0ZXh0MUEgPSB0ZXh0MS5zdWJzdHJpbmcoMCwgeCk7XG4gICAgICAgIHZhciB0ZXh0MkEgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgeSk7XG4gICAgICAgIHZhciB0ZXh0MUIgPSB0ZXh0MS5zdWJzdHJpbmcoeCk7XG4gICAgICAgIHZhciB0ZXh0MkIgPSB0ZXh0Mi5zdWJzdHJpbmcoeSk7XG4gICAgICAgIC8vIENvbXB1dGUgYm90aCBkaWZmcyBzZXJpYWxseS5cbiAgICAgICAgdmFyIGRpZmZzQSA9IHRoaXMuZGlmZl9tYWluKHRleHQxQSwgdGV4dDJBLCBmYWxzZSwgZGVhZGxpbmUpO1xuICAgICAgICB2YXIgZGlmZnNCID0gdGhpcy5kaWZmX21haW4odGV4dDFCLCB0ZXh0MkIsIGZhbHNlLCBkZWFkbGluZSk7XG4gICAgICAgIHJldHVybiBkaWZmc0EuY29uY2F0KGRpZmZzQik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTcGxpdCB0d28gdGV4dHMgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzLiBSZWR1Y2UgdGhlIHRleHRzIHRvIGEgc3RyaW5nIG9mXG4gICAgICogaGFzaGVzIHdoZXJlIGVhY2ggVW5pY29kZSBjaGFyYWN0ZXIgcmVwcmVzZW50cyBvbmUgbGluZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIEZpcnN0IHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZy5cbiAgICAgKiBAcmV0dXJucyB7e2NoYXJzMTogc3RyaW5nLCBjaGFyczI6IHN0cmluZywgbGluZUFycmF5OiBzdHJpbmdbXX19XG4gICAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGVuY29kZWQgdGV4dDEsIHRoZSBlbmNvZGVkIHRleHQyIGFuZFxuICAgICAqIHRoZSBhcnJheSBvZiB1bmlxdWUgc3RyaW5ncy5cbiAgICAgKiBUaGUgemVyb3RoIGVsZW1lbnQgb2YgdGhlIGFycmF5IG9mIHVuaXF1ZSBzdHJpbmdzIGlzIGludGVudGlvbmFsbHkgYmxhbmsuXG4gICAgICovXG4gICAgRGlmZk1hdGNoUGF0Y2gucHJvdG90eXBlLmRpZmZfbGluZXNUb0NoYXJzXyA9IGZ1bmN0aW9uICh0ZXh0MSwgdGV4dDIpIHtcbiAgICAgICAgdmFyIGxpbmVBcnJheSA9IFtdOyAvLyBlLmcuIGxpbmVBcnJheVs0XSA9PSAnSGVsbG9cXG4nXG4gICAgICAgIHZhciBsaW5lSGFzaCA9IHt9OyAvLyBlLmcuIGxpbmVIYXNoWydIZWxsb1xcbiddID09IDRcbiAgICAgICAgLy8gJ1xceDAwJyBpcyBhIHZhbGlkIGNoYXJhY3RlciwgYnV0IHZhcmlvdXMgZGVidWdnZXJzIGRvbid0IGxpa2UgaXQuXG4gICAgICAgIC8vIFNvIHdlJ2xsIGluc2VydCBhIGp1bmsgZW50cnkgdG8gYXZvaWQgZ2VuZXJhdGluZyBhIG51bGwgY2hhcmFjdGVyLlxuICAgICAgICBsaW5lQXJyYXlbMF0gPSBcIlwiO1xuICAgICAgICAvLyBBbGxvY2F0ZSAyLzNyZHMgb2YgdGhlIHNwYWNlIGZvciB0ZXh0MSwgdGhlIHJlc3QgZm9yIHRleHQyLlxuICAgICAgICB2YXIgY2hhcnMxID0gdGhpcy5kaWZmX2xpbmVzVG9DaGFyc011bmdlXyh0ZXh0MSwgbGluZUFycmF5LCBsaW5lSGFzaCwgNDAwMDApO1xuICAgICAgICB2YXIgY2hhcnMyID0gdGhpcy5kaWZmX2xpbmVzVG9DaGFyc011bmdlXyh0ZXh0MiwgbGluZUFycmF5LCBsaW5lSGFzaCwgNjU1MzUpO1xuICAgICAgICByZXR1cm4geyBjaGFyczE6IGNoYXJzMSwgY2hhcnMyOiBjaGFyczIsIGxpbmVBcnJheTogbGluZUFycmF5IH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTcGxpdCBhIHRleHQgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzLiBSZWR1Y2UgdGhlIHRleHRzIHRvIGEgc3RyaW5nIG9mXG4gICAgICogaGFzaGVzIHdoZXJlIGVhY2ggVW5pY29kZSBjaGFyYWN0ZXIgcmVwcmVzZW50cyBvbmUgbGluZS5cbiAgICAgKiBNb2RpZmllcyBsaW5lYXJyYXkgYW5kIGxpbmVoYXNoIHRocm91Z2ggYmVpbmcgYSBjbG9zdXJlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBTdHJpbmcgdG8gZW5jb2RlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGxpbmVBcnJheSBBcnJheSBvZiB1bmlxdWUgc3RyaW5ncy5cbiAgICAgKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIG51bWJlcj59IGxpbmVIYXNoIExpbmUtaGFzaCBwYWlycy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4TGluZXNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBFbmNvZGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBEaWZmTWF0Y2hQYXRjaC5wcm90b3R5cGUuZGlmZl9saW5lc1RvQ2hhcnNNdW5nZV8gPSBmdW5jdGlvbiAodGV4dCwgbGluZUFycmF5LCBsaW5lSGFzaCwgbWF4TGluZXMpIHtcbiAgICAgICAgdmFyIGNoYXJzID0gXCJcIjtcbiAgICAgICAgLy8gV2FsayB0aGUgdGV4dCwgcHVsbGluZyBvdXQgYSBzdWJzdHJpbmcgZm9yIGVhY2ggbGluZS5cbiAgICAgICAgLy8gdGV4dC5zcGxpdCgnXFxuJykgd291bGQgd291bGQgdGVtcG9yYXJpbHkgZG91YmxlIG91ciBtZW1vcnkgZm9vdHByaW50LlxuICAgICAgICAvLyBNb2RpZnlpbmcgdGV4dCB3b3VsZCBjcmVhdGUgbWFueSBsYXJnZSBzdHJpbmdzIHRvIGdhcmJhZ2UgY29sbGVjdC5cbiAgICAgICAgdmFyIGxpbmVTdGFydCA9IDA7XG4gICAgICAgIHZhciBsaW5lRW5kID0gLTE7XG4gICAgICAgIC8vIEtlZXBpbmcgb3VyIG93biBsZW5ndGggdmFyaWFibGUgaXMgZmFzdGVyIHRoYW4gbG9va2luZyBpdCB1cC5cbiAgICAgICAgdmFyIGxpbmVBcnJheUxlbmd0aCA9IGxpbmVBcnJheS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsaW5lRW5kIDwgdGV4dC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBsaW5lRW5kID0gdGV4dC5pbmRleE9mKFwiXFxuXCIsIGxpbmVTdGFydCk7XG4gICAgICAgICAgICBpZiAobGluZUVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsaW5lRW5kID0gdGV4dC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxpbmUgPSB0ZXh0LnN1YnN0cmluZyhsaW5lU3RhcnQsIGxpbmVFbmQgKyAxKTtcbiAgICAgICAgICAgIGlmIChsaW5lSGFzaC5oYXNPd25Qcm9wZXJ0eVxuICAgICAgICAgICAgICAgID8gbGluZUhhc2guaGFzT3duUHJvcGVydHkobGluZSlcbiAgICAgICAgICAgICAgICA6IChsaW5lSGFzaFtsaW5lXSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgIGNoYXJzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGluZUhhc2hbbGluZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVBcnJheUxlbmd0aCA9PT0gbWF4TGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQmFpbCBvdXQgYXQgNjU1MzUgYmVjYXVzZVxuICAgICAgICAgICAgICAgICAgICAvLyBTdHJpbmcuZnJvbUNoYXJDb2RlKDY1NTM2KSA9PSBTdHJpbmcuZnJvbUNoYXJDb2RlKDApXG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSB0ZXh0LnN1YnN0cmluZyhsaW5lU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICBsaW5lRW5kID0gdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoYXJzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGluZUFycmF5TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsaW5lSGFzaFtsaW5lXSA9IGxpbmVBcnJheUxlbmd0aDtcbiAgICAgICAgICAgICAgICBsaW5lQXJyYXlbbGluZUFycmF5TGVuZ3RoKytdID0gbGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmVTdGFydCA9IGxpbmVFbmQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFycztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlaHlkcmF0ZSB0aGUgdGV4dCBpbiBhIGRpZmYgZnJvbSBhIHN0cmluZyBvZiBsaW5lIGhhc2hlcyB0byByZWFsIGxpbmVzIG9mXG4gICAgICogdGV4dC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtEaWZmW119IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGxpbmVBcnJheSBBcnJheSBvZiB1bmlxdWUgc3RyaW5ncy5cbiAgICAgKi9cbiAgICBEaWZmTWF0Y2hQYXRjaC5wcm90b3R5cGUuZGlmZl9jaGFyc1RvTGluZXNfID0gZnVuY3Rpb24gKGRpZmZzLCBsaW5lQXJyYXkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWZmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoYXJzID0gZGlmZnNbaV1bMV07XG4gICAgICAgICAgICB2YXIgdGV4dCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGFycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHRleHRbal0gPSBsaW5lQXJyYXlbY2hhcnMuY2hhckNvZGVBdChqKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaWZmc1tpXVsxXSA9IHRleHQuam9pbihcIlwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGlmIHRoZSBzdWZmaXggb2Ygb25lIHN0cmluZyBpcyB0aGUgcHJlZml4IG9mIGFub3RoZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBGaXJzdCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIFNlY29uZCBzdHJpbmcuXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvbW1vbiB0byB0aGUgZW5kIG9mIHRoZSBmaXJzdFxuICAgICAqIHN0cmluZyBhbmQgdGhlIHN0YXJ0IG9mIHRoZSBzZWNvbmQgc3RyaW5nLlxuICAgICAqL1xuICAgIERpZmZNYXRjaFBhdGNoLnByb3RvdHlwZS5kaWZmX2NvbW1vbk92ZXJsYXBfID0gZnVuY3Rpb24gKHRleHQxLCB0ZXh0Mikge1xuICAgICAgICAvLyBDYWNoZSB0aGUgdGV4dCBsZW5ndGhzIHRvIHByZXZlbnQgbXVsdGlwbGUgY2FsbHMuXG4gICAgICAgIHZhciB0ZXh0MUxlbmd0aCA9IHRleHQxLmxlbmd0aDtcbiAgICAgICAgdmFyIHRleHQyTGVuZ3RoID0gdGV4dDIubGVuZ3RoO1xuICAgICAgICAvLyBFbGltaW5hdGUgdGhlIG51bGwgY2FzZS5cbiAgICAgICAgaWYgKHRleHQxTGVuZ3RoID09PSAwIHx8IHRleHQyTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnVuY2F0ZSB0aGUgbG9uZ2VyIHN0cmluZy5cbiAgICAgICAgaWYgKHRleHQxTGVuZ3RoID4gdGV4dDJMZW5ndGgpIHtcbiAgICAgICAgICAgIHRleHQxID0gdGV4dDEuc3Vic3RyaW5nKHRleHQxTGVuZ3RoIC0gdGV4dDJMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRleHQxTGVuZ3RoIDwgdGV4dDJMZW5ndGgpIHtcbiAgICAgICAgICAgIHRleHQyID0gdGV4dDIuc3Vic3RyaW5nKDAsIHRleHQxTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGV4dExlbmd0aCA9IG1hdGgubWluKHRleHQxTGVuZ3RoLCB0ZXh0Mkxlbmd0aCk7XG4gICAgICAgIC8vIFF1aWNrIGNoZWNrIGZvciB0aGUgd29yc3QgY2FzZS5cbiAgICAgICAgaWYgKHRleHQxID09PSB0ZXh0Mikge1xuICAgICAgICAgICAgcmV0dXJuIHRleHRMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RhcnQgYnkgbG9va2luZyBmb3IgYSBzaW5nbGUgY2hhcmFjdGVyIG1hdGNoXG4gICAgICAgIC8vIGFuZCBpbmNyZWFzZSBsZW5ndGggdW50aWwgbm8gbWF0Y2ggaXMgZm91bmQuXG4gICAgICAgIC8vIFBlcmZvcm1hbmNlIGFuYWx5c2lzOiBodHRwczovL25laWwuZnJhc2VyLm5hbWUvbmV3cy8yMDEwLzExLzA0L1xuICAgICAgICB2YXIgYmVzdCA9IDA7XG4gICAgICAgIHZhciBsZW5ndGggPSAxO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSB0ZXh0MS5zdWJzdHJpbmcodGV4dExlbmd0aCAtIGxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgZm91bmQgPSB0ZXh0Mi5pbmRleE9mKHBhdHRlcm4pO1xuICAgICAgICAgICAgaWYgKGZvdW5kID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBiZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVuZ3RoICs9IGZvdW5kO1xuICAgICAgICAgICAgaWYgKGZvdW5kID09PSAwIHx8XG4gICAgICAgICAgICAgICAgdGV4dDEuc3Vic3RyaW5nKHRleHRMZW5ndGggLSBsZW5ndGgpID09PSB0ZXh0Mi5zdWJzdHJpbmcoMCwgbGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIGJlc3QgPSBsZW5ndGg7XG4gICAgICAgICAgICAgICAgbGVuZ3RoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERvIHRoZSB0d28gdGV4dHMgc2hhcmUgYSBzdWJzdHJpbmcgd2hpY2ggaXMgYXQgbGVhc3QgaGFsZiB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgICAqIGxvbmdlciB0ZXh0P1xuICAgICAqIFRoaXMgc3BlZWR1cCBjYW4gcHJvZHVjZSBub24tbWluaW1hbCBkaWZmcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIEZpcnN0IHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZy5cbiAgICAgKiBAcmV0dXJucyB7KEhhbGZNYXRjaEFycmF5IHwgbnVsbCl9IEZpdmUgZWxlbWVudCBBcnJheSwgY29udGFpbmluZyB0aGUgcHJlZml4IG9mXG4gICAgICogdGV4dDEsIHRoZSBzdWZmaXggb2YgdGV4dDEsIHRoZSBwcmVmaXggb2YgdGV4dDIsIHRoZSBzdWZmaXggb2ZcbiAgICAgKiB0ZXh0MiBhbmQgdGhlIGNvbW1vbiBtaWRkbGUuIE9yIG51bGwgaWYgdGhlcmUgd2FzIG5vIG1hdGNoLlxuICAgICAqL1xuICAgIERpZmZNYXRjaFBhdGNoLnByb3RvdHlwZS5kaWZmX2hhbGZNYXRjaF8gPSBmdW5jdGlvbiAodGV4dDEsIHRleHQyKSB7XG4gICAgICAgIGlmICh0aGlzLmRpZmZUaW1lb3V0IDw9IDApIHtcbiAgICAgICAgICAgIC8vIERvbid0IHJpc2sgcmV0dXJuaW5nIGEgbm9uLW9wdGltYWwgZGlmZiBpZiB3ZSBoYXZlIHVubGltaXRlZCB0aW1lLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvbmd0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDEgOiB0ZXh0MjtcbiAgICAgICAgdmFyIHNob3J0dGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQyIDogdGV4dDE7XG4gICAgICAgIGlmIChsb25ndGV4dC5sZW5ndGggPCA0IHx8IHNob3J0dGV4dC5sZW5ndGggKiAyIDwgbG9uZ3RleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gUG9pbnRsZXNzLlxuICAgICAgICB9XG4gICAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoZSBzZWNvbmQgcXVhcnRlciBpcyB0aGUgc2VlZCBmb3IgYSBoYWxmLW1hdGNoLlxuICAgICAgICB2YXIgaG0xID0gdGhpcy5kaWZmX2hhbGZNYXRjaElfKGxvbmd0ZXh0LCBzaG9ydHRleHQsIE1hdGguY2VpbChsb25ndGV4dC5sZW5ndGggLyA0KSk7XG4gICAgICAgIC8vIENoZWNrIGFnYWluIGJhc2VkIG9uIHRoZSB0aGlyZCBxdWFydGVyLlxuICAgICAgICB2YXIgaG0yID0gdGhpcy5kaWZmX2hhbGZNYXRjaElfKGxvbmd0ZXh0LCBzaG9ydHRleHQsIE1hdGguY2VpbChsb25ndGV4dC5sZW5ndGggLyAyKSk7XG4gICAgICAgIHZhciBobTtcbiAgICAgICAgaWYgKCFobTEgJiYgIWhtMikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWhtMikge1xuICAgICAgICAgICAgaG0gPSBobTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWhtMSkge1xuICAgICAgICAgICAgaG0gPSBobTI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBCb3RoIG1hdGNoZWQuIFNlbGVjdCB0aGUgbG9uZ2VzdC5cbiAgICAgICAgICAgIGhtID0gaG0xWzRdLmxlbmd0aCA+IGhtMls0XS5sZW5ndGggPyBobTEgOiBobTI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSBoYWxmLW1hdGNoIHdhcyBmb3VuZCwgc29ydCBvdXQgdGhlIHJldHVybiBkYXRhLlxuICAgICAgICB2YXIgdGV4dDFBO1xuICAgICAgICB2YXIgdGV4dDFCO1xuICAgICAgICB2YXIgdGV4dDJBO1xuICAgICAgICB2YXIgdGV4dDJCO1xuICAgICAgICB2YXIgbWlkQ29tbW9uID0gaG1bNF07XG4gICAgICAgIGlmICh0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRleHQxQSA9IGhtWzBdO1xuICAgICAgICAgICAgdGV4dDFCID0gaG1bMV07XG4gICAgICAgICAgICB0ZXh0MkEgPSBobVsyXTtcbiAgICAgICAgICAgIHRleHQyQiA9IGhtWzNdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGV4dDJBID0gaG1bMF07XG4gICAgICAgICAgICB0ZXh0MkIgPSBobVsxXTtcbiAgICAgICAgICAgIHRleHQxQSA9IGhtWzJdO1xuICAgICAgICAgICAgdGV4dDFCID0gaG1bM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0ZXh0MUEsIHRleHQxQiwgdGV4dDJBLCB0ZXh0MkIsIG1pZENvbW1vbl07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEb2VzIGEgc3Vic3RyaW5nIG9mIHNob3J0dGV4dCBleGlzdCB3aXRoaW4gbG9uZ3RleHQgc3VjaCB0aGF0IHRoZSBzdWJzdHJpbmdcbiAgICAgKiBpcyBhdCBsZWFzdCBoYWxmIHRoZSBsZW5ndGggb2YgbG9uZ3RleHQ/XG4gICAgICogQ2xvc3VyZSwgYnV0IGRvZXMgbm90IHJlZmVyZW5jZSBhbnkgZXh0ZXJuYWwgdmFyaWFibGVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbG9uZ3RleHQgTG9uZ2VyIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2hvcnR0ZXh0IFNob3J0ZXIgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpIFN0YXJ0IGluZGV4IG9mIHF1YXJ0ZXIgbGVuZ3RoIHN1YnN0cmluZyB3aXRoaW4gbG9uZ3RleHQuXG4gICAgICogQHJldHVybnMgeyhIYWxmTWF0Y2hBcnJheSB8IG51bGwpfSBGaXZlIGVsZW1lbnQgQXJyYXksIGNvbnRhaW5pbmcgdGhlIHByZWZpeCBvZlxuICAgICAqIGxvbmd0ZXh0LCB0aGUgc3VmZml4IG9mIGxvbmd0ZXh0LCB0aGUgcHJlZml4IG9mIHNob3J0dGV4dCwgdGhlIHN1ZmZpeFxuICAgICAqIG9mIHNob3J0dGV4dCBhbmQgdGhlIGNvbW1vbiBtaWRkbGUuIE9yIG51bGwgaWYgdGhlcmUgd2FzIG5vIG1hdGNoLlxuICAgICAqL1xuICAgIERpZmZNYXRjaFBhdGNoLnByb3RvdHlwZS5kaWZmX2hhbGZNYXRjaElfID0gZnVuY3Rpb24gKGxvbmd0ZXh0LCBzaG9ydHRleHQsIGkpIHtcbiAgICAgICAgLy8gU3RhcnQgd2l0aCBhIDEvNCBsZW5ndGggc3Vic3RyaW5nIGF0IHBvc2l0aW9uIGkgYXMgYSBzZWVkLlxuICAgICAgICB2YXIgc2VlZCA9IGxvbmd0ZXh0LnN1YnN0cmluZyhpLCBpICsgTWF0aC5mbG9vcihsb25ndGV4dC5sZW5ndGggLyA0KSk7XG4gICAgICAgIHZhciBiZXN0Q29tbW9uID0gXCJcIjtcbiAgICAgICAgdmFyIGJlc3RMb25ndGV4dEE7XG4gICAgICAgIHZhciBiZXN0TG9uZ3RleHRCO1xuICAgICAgICB2YXIgYmVzdFNob3J0dGV4dEE7XG4gICAgICAgIHZhciBiZXN0U2hvcnR0ZXh0QjtcbiAgICAgICAgLy8gSW5pdGlhbC5cbiAgICAgICAgdmFyIGogPSBzaG9ydHRleHQuaW5kZXhPZihzZWVkLCAwKTtcbiAgICAgICAgd2hpbGUgKGogIT09IC0xKSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4TGVuZ3RoID0gdGhpcy5kaWZmX2NvbW1vblByZWZpeChsb25ndGV4dC5zdWJzdHJpbmcoaSksIHNob3J0dGV4dC5zdWJzdHJpbmcoaikpO1xuICAgICAgICAgICAgdmFyIHN1ZmZpeExlbmd0aCA9IHRoaXMuZGlmZl9jb21tb25TdWZmaXgobG9uZ3RleHQuc3Vic3RyaW5nKDAsIGkpLCBzaG9ydHRleHQuc3Vic3RyaW5nKDAsIGopKTtcbiAgICAgICAgICAgIGlmIChiZXN0Q29tbW9uLmxlbmd0aCA8IHN1ZmZpeExlbmd0aCArIHByZWZpeExlbmd0aCkge1xuICAgICAgICAgICAgICAgIGJlc3RDb21tb24gPSBzaG9ydHRleHQuc3Vic3RyaW5nKGogLSBzdWZmaXhMZW5ndGgsIGopXG4gICAgICAgICAgICAgICAgICAgICsgc2hvcnR0ZXh0LnN1YnN0cmluZyhqLCBqICsgcHJlZml4TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBiZXN0TG9uZ3RleHRBID0gbG9uZ3RleHQuc3Vic3RyaW5nKDAsIGkgLSBzdWZmaXhMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGJlc3RMb25ndGV4dEIgPSBsb25ndGV4dC5zdWJzdHJpbmcoaSArIHByZWZpeExlbmd0aCk7XG4gICAgICAgICAgICAgICAgYmVzdFNob3J0dGV4dEEgPSBzaG9ydHRleHQuc3Vic3RyaW5nKDAsIGogLSBzdWZmaXhMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGJlc3RTaG9ydHRleHRCID0gc2hvcnR0ZXh0LnN1YnN0cmluZyhqICsgcHJlZml4TGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0ZXAuXG4gICAgICAgICAgICBqID0gc2hvcnR0ZXh0LmluZGV4T2Yoc2VlZCwgaiArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiZXN0Q29tbW9uLmxlbmd0aCAqIDIgPj0gbG9uZ3RleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGJlc3RMb25ndGV4dEEsXG4gICAgICAgICAgICAgICAgYmVzdExvbmd0ZXh0QixcbiAgICAgICAgICAgICAgICBiZXN0U2hvcnR0ZXh0QSxcbiAgICAgICAgICAgICAgICBiZXN0U2hvcnR0ZXh0QixcbiAgICAgICAgICAgICAgICBiZXN0Q29tbW9uXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gdHdvIHN0cmluZ3MsIGNvbXB1dGUgYSBzY29yZSByZXByZXNlbnRpbmcgd2hldGhlciB0aGUgaW50ZXJuYWxcbiAgICAgKiBib3VuZGFyeSBmYWxscyBvbiBsb2dpY2FsIGJvdW5kYXJpZXMuXG4gICAgICogU2NvcmVzIHJhbmdlIGZyb20gNiAoYmVzdCkgdG8gMCAod29yc3QpLlxuICAgICAqIENsb3N1cmUsIGJ1dCBkb2VzIG5vdCByZWZlcmVuY2UgYW55IGV4dGVybmFsIHZhcmlhYmxlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9uZSBGaXJzdCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR3byBTZWNvbmQgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBzY29yZS5cbiAgICAgKi9cbiAgICBEaWZmTWF0Y2hQYXRjaC5wcm90b3R5cGUuZGlmZl9jbGVhbnVwU2VtYW50aWNTY29yZV8gPSBmdW5jdGlvbiAob25lLCB0d28pIHtcbiAgICAgICAgaWYgKCFvbmUgfHwgIXR3bykge1xuICAgICAgICAgICAgLy8gRWRnZXMgYXJlIHRoZSBiZXN0LlxuICAgICAgICAgICAgcmV0dXJuIDY7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRWFjaCBwb3J0IG9mIHRoaXMgZnVuY3Rpb24gYmVoYXZlcyBzbGlnaHRseSBkaWZmZXJlbnRseSBkdWUgdG9cbiAgICAgICAgLy8gc3VidGxlIGRpZmZlcmVuY2VzIGluIGVhY2ggbGFuZ3VhZ2UncyBkZWZpbml0aW9uIG9mIHRoaW5ncyBsaWtlXG4gICAgICAgIC8vICd3aGl0ZXNwYWNlJy4gU2luY2UgdGhpcyBmdW5jdGlvbidzIHB1cnBvc2UgaXMgbGFyZ2VseSBjb3NtZXRpYyxcbiAgICAgICAgLy8gdGhlIGNob2ljZSBoYXMgYmVlbiBtYWRlIHRvIHVzZSBlYWNoIGxhbmd1YWdlJ3MgbmF0aXZlIGZlYXR1cmVzXG4gICAgICAgIC8vIHJhdGhlciB0aGFuIGZvcmNlIHRvdGFsIGNvbmZvcm1pdHkuXG4gICAgICAgIHZhciBjaGFyMSA9IG9uZS5jaGFyQXQob25lLmxlbmd0aCAtIDEpO1xuICAgICAgICB2YXIgY2hhcjIgPSB0d28uY2hhckF0KDApO1xuICAgICAgICB2YXIgbm9uQWxwaGFOdW1lcmljMSA9IGNoYXIxLm1hdGNoKE5PTl9BTFBIQV9OVU1FUklDX1JFR0VYKTtcbiAgICAgICAgdmFyIG5vbkFscGhhTnVtZXJpYzIgPSBjaGFyMi5tYXRjaChOT05fQUxQSEFfTlVNRVJJQ19SRUdFWCk7XG4gICAgICAgIHZhciB3aGl0ZXNwYWNlMSA9IG5vbkFscGhhTnVtZXJpYzEgJiYgY2hhcjEubWF0Y2goV0hJVEVTUEFDRV9SRUdFWCk7XG4gICAgICAgIHZhciB3aGl0ZXNwYWNlMiA9IG5vbkFscGhhTnVtZXJpYzIgJiYgY2hhcjIubWF0Y2goV0hJVEVTUEFDRV9SRUdFWCk7XG4gICAgICAgIHZhciBsaW5lQnJlYWsxID0gd2hpdGVzcGFjZTEgJiYgY2hhcjEubWF0Y2goTElORUJSRUFLX1JFR0VYKTtcbiAgICAgICAgdmFyIGxpbmVCcmVhazIgPSB3aGl0ZXNwYWNlMiAmJiBjaGFyMi5tYXRjaChMSU5FQlJFQUtfUkVHRVgpO1xuICAgICAgICB2YXIgYmxhbmtMaW5lMSA9IGxpbmVCcmVhazEgJiYgb25lLm1hdGNoKEJMQU5LTElORV9FTkRfUkVHRVgpO1xuICAgICAgICB2YXIgYmxhbmtMaW5lMiA9IGxpbmVCcmVhazIgJiYgdHdvLm1hdGNoKEJMQU5LTElORV9TVEFSVF9SRUdFWCk7XG4gICAgICAgIGlmIChibGFua0xpbmUxIHx8IGJsYW5rTGluZTIpIHtcbiAgICAgICAgICAgIC8vIEZpdmUgcG9pbnRzIGZvciBibGFuayBsaW5lcy5cbiAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxpbmVCcmVhazEgfHwgbGluZUJyZWFrMikge1xuICAgICAgICAgICAgLy8gRm91ciBwb2ludHMgZm9yIGxpbmUgYnJlYWtzLlxuICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9uQWxwaGFOdW1lcmljMSAmJiAhd2hpdGVzcGFjZTEgJiYgd2hpdGVzcGFjZTIpIHtcbiAgICAgICAgICAgIC8vIFRocmVlIHBvaW50cyBmb3IgZW5kIG9mIHNlbnRlbmNlcy5cbiAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHdoaXRlc3BhY2UxIHx8IHdoaXRlc3BhY2UyKSB7XG4gICAgICAgICAgICAvLyBUd28gcG9pbnRzIGZvciB3aGl0ZXNwYWNlLlxuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9uQWxwaGFOdW1lcmljMSB8fCBub25BbHBoYU51bWVyaWMyKSB7XG4gICAgICAgICAgICAvLyBPbmUgcG9pbnQgZm9yIG5vbi1hbHBoYW51bWVyaWMuXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIC8vI2VuZHJlZ2lvbiBESUZGIEZVTkNUSU9OUyAocHJpdmF0ZSlcbiAgICAvLyNyZWdpb24gTUFUQ0ggRlVOQ1RJT05TIChwcml2YXRlKVxuICAgIC8qKlxuICAgICAqIExvY2F0ZSB0aGUgYmVzdCBpbnN0YW5jZSBvZiAncGF0dGVybicgaW4gJ3RleHQnIG5lYXIgJ2xvYycgdXNpbmcgdGhlXG4gICAgICogQml0YXAgYWxnb3JpdGhtLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG9jIFRoZSBsb2NhdGlvbiB0byBzZWFyY2ggYXJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEJlc3QgbWF0Y2ggaW5kZXggb3IgLTEuXG4gICAgICovXG4gICAgRGlmZk1hdGNoUGF0Y2gucHJvdG90eXBlLm1hdGNoX2JpdGFwXyA9IGZ1bmN0aW9uICh0ZXh0LCBwYXR0ZXJuLCBsb2MpIHtcbiAgICAgICAgaWYgKHBhdHRlcm4ubGVuZ3RoID4gdGhpcy5tYXRjaE1heEJpdHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhdHRlcm4gdG9vIGxvbmcgZm9yIHRoaXMgYnJvd3NlclwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBhbHBoYWJldC5cbiAgICAgICAgdmFyIHMgPSB0aGlzLm1hdGNoX2FscGhhYmV0XyhwYXR0ZXJuKTtcbiAgICAgICAgLy8gSGlnaGVzdCBzY29yZSBiZXlvbmQgd2hpY2ggd2UgZ2l2ZSB1cC5cbiAgICAgICAgdmFyIHNjb3JlVGhyZXNob2xkID0gdGhpcy5tYXRjaFRocmVzaG9sZDtcbiAgICAgICAgLy8gSXMgdGhlcmUgYSBuZWFyYnkgZXhhY3QgbWF0Y2g/IChzcGVlZHVwKVxuICAgICAgICB2YXIgYmVzdExvYyA9IHRleHQuaW5kZXhPZihwYXR0ZXJuLCBsb2MpO1xuICAgICAgICBpZiAoYmVzdExvYyAhPT0gLTEpIHtcbiAgICAgICAgICAgIHNjb3JlVGhyZXNob2xkID0gbWF0aC5taW4odGhpcy5tYXRjaF9iaXRhcFNjb3JlXygwLCBiZXN0TG9jLCBwYXR0ZXJuLCBsb2MpLCBzY29yZVRocmVzaG9sZCk7XG4gICAgICAgICAgICAvLyBXaGF0IGFib3V0IGluIHRoZSBvdGhlciBkaXJlY3Rpb24/IChzcGVlZHVwKVxuICAgICAgICAgICAgYmVzdExvYyA9IHRleHQubGFzdEluZGV4T2YocGF0dGVybiwgbG9jICsgcGF0dGVybi5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKGJlc3RMb2MgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc2NvcmVUaHJlc2hvbGQgPSBtYXRoLm1pbih0aGlzLm1hdGNoX2JpdGFwU2NvcmVfKDAsIGJlc3RMb2MsIHBhdHRlcm4sIGxvYyksIHNjb3JlVGhyZXNob2xkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBiaXQgYXJyYXlzLlxuICAgICAgICB2YXIgbWF0Y2htYXNrID0gMSA8PCAocGF0dGVybi5sZW5ndGggLSAxKTtcbiAgICAgICAgYmVzdExvYyA9IC0xO1xuICAgICAgICB2YXIgYmluTWluO1xuICAgICAgICB2YXIgYmluTWlkO1xuICAgICAgICB2YXIgYmluTWF4ID0gcGF0dGVybi5sZW5ndGggKyB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgdmFyIGxhc3RSRDtcbiAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBwYXR0ZXJuLmxlbmd0aDsgZCsrKSB7XG4gICAgICAgICAgICAvLyBTY2FuIGZvciB0aGUgYmVzdCBtYXRjaDsgZWFjaCBpdGVyYXRpb24gYWxsb3dzIGZvciBvbmUgbW9yZSBlcnJvci5cbiAgICAgICAgICAgIC8vIFJ1biBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIGhvdyBmYXIgZnJvbSAnbG9jJyB3ZSBjYW4gc3RyYXkgYXQgdGhpc1xuICAgICAgICAgICAgLy8gZXJyb3IgbGV2ZWwuXG4gICAgICAgICAgICBiaW5NaW4gPSAwO1xuICAgICAgICAgICAgYmluTWlkID0gYmluTWF4O1xuICAgICAgICAgICAgd2hpbGUgKGJpbk1pbiA8IGJpbk1pZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoX2JpdGFwU2NvcmVfKGQsIGxvYyArIGJpbk1pZCwgcGF0dGVybiwgbG9jKSA8PSBzY29yZVRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICBiaW5NaW4gPSBiaW5NaWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBiaW5NYXggPSBiaW5NaWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJpbk1pZCA9IE1hdGguZmxvb3IoKGJpbk1heCAtIGJpbk1pbikgLyAyICsgYmluTWluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVzZSB0aGUgcmVzdWx0IGZyb20gdGhpcyBpdGVyYXRpb24gYXMgdGhlIG1heGltdW0gZm9yIHRoZSBuZXh0LlxuICAgICAgICAgICAgYmluTWF4ID0gYmluTWlkO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gbWF0aC5tYXgoMSwgbG9jIC0gYmluTWlkICsgMSk7XG4gICAgICAgICAgICB2YXIgZmluaXNoID0gbWF0aC5taW4obG9jICsgYmluTWlkLCB0ZXh0Lmxlbmd0aCkgKyBwYXR0ZXJuLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciByZCA9IEFycmF5KGZpbmlzaCArIDIpO1xuICAgICAgICAgICAgcmRbZmluaXNoICsgMV0gPSAoMSA8PCBkKSAtIDE7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gZmluaXNoOyBqID49IHN0YXJ0OyBqLS0pIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgYWxwaGFiZXQgKHMpIGlzIGEgc3BhcnNlIGhhc2gsIHNvIHRoZSBmb2xsb3dpbmcgbGluZSBnZW5lcmF0ZXNcbiAgICAgICAgICAgICAgICAvLyB3YXJuaW5ncy5cbiAgICAgICAgICAgICAgICB2YXIgY2hhck1hdGNoID0gc1t0ZXh0LmNoYXJBdChqIC0gMSldO1xuICAgICAgICAgICAgICAgIGlmIChkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IHBhc3M6IGV4YWN0IG1hdGNoLlxuICAgICAgICAgICAgICAgICAgICByZFtqXSA9ICgocmRbaiArIDFdIDw8IDEpIHwgMSkgJiBjaGFyTWF0Y2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdWJzZXF1ZW50IHBhc3NlczogZnV6enkgbWF0Y2guXG4gICAgICAgICAgICAgICAgICAgIHJkW2pdID0gKCgocmRbaiArIDFdIDw8IDEpIHwgMSkgJiBjaGFyTWF0Y2gpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICgoKGxhc3RSRFtqICsgMV0gfCBsYXN0UkRbal0pIDw8IDEpIHwgMSkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFJEW2ogKyAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJkW2pdICYgbWF0Y2htYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY29yZSA9IHRoaXMubWF0Y2hfYml0YXBTY29yZV8oZCwgaiAtIDEsIHBhdHRlcm4sIGxvYyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWF0Y2ggd2lsbCBhbG1vc3QgY2VydGFpbmx5IGJlIGJldHRlciB0aGFuIGFueSBleGlzdGluZyBtYXRjaC5cbiAgICAgICAgICAgICAgICAgICAgLy8gQnV0IGNoZWNrIGFueXdheS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3JlIDw9IHNjb3JlVGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUb2xkIHlvdSBzby5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3JlVGhyZXNob2xkID0gc2NvcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TG9jID0gaiAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmVzdExvYyA+IGxvYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gcGFzc2luZyBsb2MsIGRvbid0IGV4Y2VlZCBvdXIgY3VycmVudCBkaXN0YW5jZSBmcm9tIGxvYy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG1hdGgubWF4KDEsIDIgKiBsb2MgLSBiZXN0TG9jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFscmVhZHkgcGFzc2VkIGxvYywgZG93bmhpbGwgZnJvbSBoZXJlIG9uIGluLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm8gaG9wZSBmb3IgYSAoYmV0dGVyKSBtYXRjaCBhdCBncmVhdGVyIGVycm9yIGxldmVscy5cbiAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoX2JpdGFwU2NvcmVfKGQgKyAxLCBsb2MsIHBhdHRlcm4sIGxvYykgPiBzY29yZVRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdFJEID0gcmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJlc3RMb2M7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlIGFuZCByZXR1cm4gdGhlIHNjb3JlIGZvciBhIG1hdGNoIHdpdGggZSBlcnJvcnMgYW5kIHggbG9jYXRpb24uXG4gICAgICogQWNjZXNzZXMgbG9jIGFuZCBwYXR0ZXJuIHRocm91Z2ggYmVpbmcgYSBjbG9zdXJlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZSBOdW1iZXIgb2YgZXJyb3JzIGluIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IExvY2F0aW9uIG9mIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvYyBUaGUgbG9jYXRpb24gdG8gc2VhcmNoIGFyb3VuZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBPdmVyYWxsIHNjb3JlIGZvciBtYXRjaCAoMC4wID0gZ29vZCwgMS4wID0gYmFkKS5cbiAgICAgKi9cbiAgICBEaWZmTWF0Y2hQYXRjaC5wcm90b3R5cGUubWF0Y2hfYml0YXBTY29yZV8gPSBmdW5jdGlvbiAoZSwgeCwgcGF0dGVybiwgbG9jKSB7XG4gICAgICAgIHZhciBhY2N1cmFjeSA9IGUgLyBwYXR0ZXJuLmxlbmd0aDtcbiAgICAgICAgdmFyIHByb3hpbWl0eSA9IE1hdGguYWJzKGxvYyAtIHgpO1xuICAgICAgICBpZiAoIXRoaXMubWF0Y2hEaXN0YW5jZSkge1xuICAgICAgICAgICAgLy8gRG9kZ2UgZGl2aWRlIGJ5IHplcm8gZXJyb3IuXG4gICAgICAgICAgICByZXR1cm4gcHJveGltaXR5ID8gMS4wIDogYWNjdXJhY3k7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjY3VyYWN5ICsgKHByb3hpbWl0eSAvIHRoaXMubWF0Y2hEaXN0YW5jZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSBhbHBoYWJldCBmb3IgdGhlIEJpdGFwIGFsZ29yaXRobS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdHRlcm4gVGhlIHRleHQgdG8gZW5jb2RlLlxuICAgICAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBudW1iZXI+fSBIYXNoIG9mIGNoYXJhY3RlciBsb2NhdGlvbnMuXG4gICAgICovXG4gICAgRGlmZk1hdGNoUGF0Y2gucHJvdG90eXBlLm1hdGNoX2FscGhhYmV0XyA9IGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gICAgICAgIHZhciBzID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc1twYXR0ZXJuLmNoYXJBdChpKV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc1twYXR0ZXJuLmNoYXJBdChpKV0gfD0gMSA8PCAocGF0dGVybi5sZW5ndGggLSBpIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgICAvLyNlbmRyZWdpb24gTUFUQ0ggRlVOQ1RJT05TIChwcml2YXRlKVxuICAgIC8vI3JlZ2lvbiBQQVRDSCBGVU5DVElPTlMgKHByaXZhdGUpXG4gICAgLyoqXG4gICAgICogSW5jcmVhc2UgdGhlIGNvbnRleHQgdW50aWwgaXQgaXMgdW5pcXVlLFxuICAgICAqIGJ1dCBkb24ndCBsZXQgdGhlIHBhdHRlcm4gZXhwYW5kIGJleW9uZCBNYXRjaF9NYXhCaXRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1BhdGNoT2JqZWN0fSBwYXRjaCBUaGUgcGF0Y2ggdG8gZ3Jvdy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBTb3VyY2UgdGV4dC5cbiAgICAgKi9cbiAgICBEaWZmTWF0Y2hQYXRjaC5wcm90b3R5cGUucGF0Y2hfYWRkQ29udGV4dF8gPSBmdW5jdGlvbiAocGF0Y2gsIHRleHQpIHtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGNoLnN0YXJ0MiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcInBhdGNoIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGF0dGVybiA9IHRleHQuc3Vic3RyaW5nKHBhdGNoLnN0YXJ0MiwgcGF0Y2guc3RhcnQyICsgcGF0Y2gubGVuZ3RoMSk7XG4gICAgICAgIHZhciBwYWRkaW5nID0gMDtcbiAgICAgICAgLy8gTG9vayBmb3IgdGhlIGZpcnN0IGFuZCBsYXN0IG1hdGNoZXMgb2YgcGF0dGVybiBpbiB0ZXh0LiBJZiB0d28gZGlmZmVyZW50XG4gICAgICAgIC8vIG1hdGNoZXMgYXJlIGZvdW5kLCBpbmNyZWFzZSB0aGUgcGF0dGVybiBsZW5ndGguXG4gICAgICAgIHdoaWxlICh0ZXh0LmluZGV4T2YocGF0dGVybikgIT09IHRleHQubGFzdEluZGV4T2YocGF0dGVybikgJiZcbiAgICAgICAgICAgIHBhdHRlcm4ubGVuZ3RoIDwgKHRoaXMubWF0Y2hNYXhCaXRzIC0gdGhpcy5wYXRjaE1hcmdpbiAtIHRoaXMucGF0Y2hNYXJnaW4pKSB7XG4gICAgICAgICAgICBwYWRkaW5nICs9IHRoaXMucGF0Y2hNYXJnaW47XG4gICAgICAgICAgICBwYXR0ZXJuID0gdGV4dC5zdWJzdHJpbmcocGF0Y2guc3RhcnQyIC0gcGFkZGluZywgcGF0Y2guc3RhcnQyICsgcGF0Y2gubGVuZ3RoMSArIHBhZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBvbmUgY2h1bmsgZm9yIGdvb2QgbHVjay5cbiAgICAgICAgcGFkZGluZyArPSB0aGlzLnBhdGNoTWFyZ2luO1xuICAgICAgICAvLyBBZGQgdGhlIHByZWZpeC5cbiAgICAgICAgdmFyIHByZWZpeCA9IHRleHQuc3Vic3RyaW5nKHBhdGNoLnN0YXJ0MiAtIHBhZGRpbmcsIHBhdGNoLnN0YXJ0Mik7XG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIHBhdGNoLmRpZmZzLnVuc2hpZnQoW0RpZmZPcGVyYXRpb24uRElGRl9FUVVBTCwgcHJlZml4XSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBzdWZmaXguXG4gICAgICAgIHZhciBzdWZmaXggPSB0ZXh0LnN1YnN0cmluZyhwYXRjaC5zdGFydDIgKyBwYXRjaC5sZW5ndGgxLCBwYXRjaC5zdGFydDIgKyBwYXRjaC5sZW5ndGgxICsgcGFkZGluZyk7XG4gICAgICAgIGlmIChzdWZmaXgpIHtcbiAgICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW0RpZmZPcGVyYXRpb24uRElGRl9FUVVBTCwgc3VmZml4XSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUm9sbCBiYWNrIHRoZSBzdGFydCBwb2ludHMuXG4gICAgICAgIHBhdGNoLnN0YXJ0MSAtPSBwcmVmaXgubGVuZ3RoO1xuICAgICAgICBwYXRjaC5zdGFydDIgLT0gcHJlZml4Lmxlbmd0aDtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBsZW5ndGhzLlxuICAgICAgICBwYXRjaC5sZW5ndGgxICs9IHByZWZpeC5sZW5ndGggKyBzdWZmaXgubGVuZ3RoO1xuICAgICAgICBwYXRjaC5sZW5ndGgyICs9IHByZWZpeC5sZW5ndGggKyBzdWZmaXgubGVuZ3RoO1xuICAgIH07XG4gICAgcmV0dXJuIERpZmZNYXRjaFBhdGNoO1xufSgpKTtcbmV4cG9ydCB7IERpZmZNYXRjaFBhdGNoIH07XG4iLCJleHBvcnQgKiBmcm9tIFwiLi9EaWZmTWF0Y2hQYXRjaFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vUGF0Y2hPYmplY3RcIjtcbiIsImV4cG9ydCAqIGZyb20gXCIuL2NvcmVcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3R5cGVzXCI7XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNkQTs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNYQTtBQUNBOzs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeGtFQTtBQUNBOzs7QUNEQTtBQUFBO0FBQUE7QUFBQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///820\n')}});